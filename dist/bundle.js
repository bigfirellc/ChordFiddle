/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/chordjs/lib/chord.js":
/*!*******************************************!*\
  !*** ./node_modules/chordjs/lib/chord.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Chord = /*#__PURE__*/function () {\n  function Chord(_ref) {\n    var base = _ref.base,\n        modifier = _ref.modifier,\n        suffix = _ref.suffix,\n        bassBase = _ref.bassBase,\n        bassModifier = _ref.bassModifier;\n\n    _classCallCheck(this, Chord);\n\n    this.base = base || null;\n    this.modifier = modifier || null;\n    this.suffix = suffix || null;\n    this.bassBase = bassBase || null;\n    this.bassModifier = bassModifier || null;\n  }\n\n  _createClass(Chord, [{\n    key: \"clone\",\n    value: function clone() {\n      var base = this.base,\n          modifier = this.modifier,\n          suffix = this.suffix,\n          bassBase = this.bassBase,\n          bassModifier = this.bassModifier;\n      return new this.constructor({\n        base: base,\n        modifier: modifier,\n        suffix: suffix,\n        bassBase: bassBase,\n        bassModifier: bassModifier\n      });\n    }\n  }, {\n    key: \"set\",\n    value: function set(properties) {\n      return new this.constructor(_objectSpread({\n        base: this.base,\n        modifier: this.modifier,\n        suffix: this.suffix,\n        bassBase: this.bassBase,\n        bassModifier: this.bassModifier\n      }, properties));\n    }\n  }]);\n\n  return Chord;\n}();\n\nvar _default = Chord;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/chordjs/lib/chord.js?");

/***/ }),

/***/ "./node_modules/chordjs/lib/chord_symbol.js":
/*!**************************************************!*\
  !*** ./node_modules/chordjs/lib/chord_symbol.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _functions = __webpack_require__(/*! ./functions */ \"./node_modules/chordjs/lib/functions.js\");\n\nvar _chord = _interopRequireDefault(__webpack_require__(/*! ./chord */ \"./node_modules/chordjs/lib/chord.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar ChordSymbol = /*#__PURE__*/function (_Chord) {\n  _inherits(ChordSymbol, _Chord);\n\n  var _super = _createSuper(ChordSymbol);\n\n  function ChordSymbol() {\n    _classCallCheck(this, ChordSymbol);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ChordSymbol, [{\n    key: \"normalize\",\n    value: function normalize() {\n      return (0, _functions.processChord)(this, _functions.normalize);\n    }\n  }, {\n    key: \"switchModifier\",\n    value: function switchModifier() {\n      return (0, _functions.processChord)(this, _functions.switchModifier);\n    }\n  }, {\n    key: \"useModifier\",\n    value: function useModifier(newModifier) {\n      return (0, _functions.processChord)(this, _functions.useModifier, newModifier);\n    }\n  }, {\n    key: \"transposeUp\",\n    value: function transposeUp() {\n      return (0, _functions.processChord)(this, _functions.transposeUp);\n    }\n  }, {\n    key: \"transposeDown\",\n    value: function transposeDown() {\n      return (0, _functions.processChord)(this, _functions.transposeDown);\n    }\n  }, {\n    key: \"transpose\",\n    value: function transpose(delta) {\n      return (0, _functions.processChord)(this, _functions.transpose, delta);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var chordString = this.base + (this.modifier || '') + (this.suffix || '');\n\n      if (this.bassBase) {\n        return \"\".concat(chordString, \"/\").concat(this.bassBase).concat(this.bassModifier || '');\n      }\n\n      return chordString;\n    }\n  }]);\n\n  return ChordSymbol;\n}(_chord[\"default\"]);\n\nvar _default = ChordSymbol;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/chordjs/lib/chord_symbol.js?");

/***/ }),

/***/ "./node_modules/chordjs/lib/functions.js":
/*!***********************************************!*\
  !*** ./node_modules/chordjs/lib/functions.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.keyUp = keyUp;\nexports.keyDown = keyDown;\nexports.normalize = normalize;\nexports.internalSwitchModifier = internalSwitchModifier;\nexports.switchModifier = switchModifier;\nexports.useModifier = useModifier;\nexports.transposeUp = transposeUp;\nexports.transposeDown = transposeDown;\nexports.transpose = transpose;\nexports.processChord = processChord;\nexports.deprecate = deprecate;\nexports.isEmptyString = isEmptyString;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar A = 'A'.charCodeAt(0);\nvar G = 'G'.charCodeAt(0);\n\nfunction keyChange(key, delta) {\n  var charCode;\n  charCode = key.toUpperCase().charCodeAt(0);\n  charCode += delta;\n\n  if (charCode > G) {\n    charCode = A;\n  }\n\n  if (charCode < A) {\n    charCode = G;\n  }\n\n  return String.fromCharCode(charCode);\n}\n\nfunction keyUp(key) {\n  return keyChange(key, 1);\n}\n\nfunction keyDown(key) {\n  return keyChange(key, -1);\n}\n\nfunction normalize(base, modifier) {\n  if (modifier === '#' && /^(B|E)$/.test(base)) {\n    return [keyUp(base), null];\n  }\n\n  if (modifier === 'b' && /^(C|F)$/.test(base)) {\n    return [keyDown(base), null];\n  }\n\n  return [base, modifier];\n}\n\nfunction internalSwitchModifier(base, modifier) {\n  if (modifier === '#') {\n    return [keyUp(base), 'b'];\n  }\n\n  if (modifier === 'b') {\n    return [keyDown(base), '#'];\n  }\n\n  throw new Error(\"Unexpected modifier \".concat(modifier));\n}\n\nfunction switchModifier(base, modifier) {\n  var _normalize = normalize(base, modifier),\n      _normalize2 = _slicedToArray(_normalize, 2),\n      normalizedBase = _normalize2[0],\n      normalizedModifier = _normalize2[1];\n\n  if (modifier) {\n    return internalSwitchModifier(normalizedBase, normalizedModifier);\n  }\n\n  return [normalizedBase, normalizedModifier];\n}\n\nfunction useModifier(base, modifier, newModifier) {\n  if (modifier && modifier !== newModifier) {\n    return internalSwitchModifier(base, modifier);\n  }\n\n  return [base, modifier];\n}\n\nfunction repeatProcessor(base, modifier, processor, amount) {\n  var processedBase = base,\n      processedModifier = modifier;\n\n  for (var i = 0; i < amount; i += 1) {\n    var _processor = processor(processedBase, processedModifier);\n\n    var _processor2 = _slicedToArray(_processor, 2);\n\n    processedBase = _processor2[0];\n    processedModifier = _processor2[1];\n  }\n\n  return [processedBase, processedModifier];\n}\n\nfunction transposeUp(base, modifier) {\n  var _normalize3 = normalize(base, modifier),\n      _normalize4 = _slicedToArray(_normalize3, 2),\n      normalizedBase = _normalize4[0],\n      normalizedModifier = _normalize4[1];\n\n  if (normalizedModifier === 'b') {\n    return [normalizedBase, null];\n  }\n\n  if (normalizedModifier === '#') {\n    return [keyUp(normalizedBase), null];\n  }\n\n  if (/^(B|E)$/.test(normalizedBase)) {\n    return [keyUp(normalizedBase), null];\n  }\n\n  return [normalizedBase, '#'];\n}\n\nfunction transposeDown(base, modifier) {\n  var _normalize5 = normalize(base, modifier),\n      _normalize6 = _slicedToArray(_normalize5, 2),\n      normalizedBase = _normalize6[0],\n      normalizedModifier = _normalize6[1];\n\n  if (normalizedModifier === 'b') {\n    return [keyDown(normalizedBase), null];\n  }\n\n  if (normalizedModifier === '#') {\n    return [normalizedBase, null];\n  }\n\n  if (/^(C|F)$/.test(normalizedBase)) {\n    return [keyDown(normalizedBase), null];\n  }\n\n  return [normalizedBase, 'b'];\n}\n\nfunction transpose(base, modifier, delta) {\n  var newBase = base,\n      newModifier = modifier;\n\n  if (delta < 0) {\n    var _repeatProcessor = repeatProcessor(base, modifier, transposeDown, Math.abs(delta));\n\n    var _repeatProcessor2 = _slicedToArray(_repeatProcessor, 2);\n\n    newBase = _repeatProcessor2[0];\n    newModifier = _repeatProcessor2[1];\n  } else if (delta > 0) {\n    var _repeatProcessor3 = repeatProcessor(base, modifier, transposeUp, delta);\n\n    var _repeatProcessor4 = _slicedToArray(_repeatProcessor3, 2);\n\n    newBase = _repeatProcessor4[0];\n    newModifier = _repeatProcessor4[1];\n  }\n\n  return useModifier(newBase, newModifier, modifier);\n}\n\nfunction processChord(sourceChord, processor, processorArg) {\n  var chord = sourceChord.clone();\n\n  var _processor3 = processor(sourceChord.base, sourceChord.modifier, processorArg);\n\n  var _processor4 = _slicedToArray(_processor3, 2);\n\n  chord.base = _processor4[0];\n  chord.modifier = _processor4[1];\n\n  if (sourceChord.bassBase) {\n    var _processor5 = processor(sourceChord.bassBase, sourceChord.bassModifier, processorArg);\n\n    var _processor6 = _slicedToArray(_processor5, 2);\n\n    chord.bassBase = _processor6[0];\n    chord.bassModifier = _processor6[1];\n  }\n\n  return chord;\n}\n\nfunction deprecate(message) {\n  try {\n    throw new Error(\"DEPRECATION: \".concat(message));\n  } catch (e) {\n    if ((typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && typeof process.emitWarning === 'function') {\n      process.emitWarning(\"\".concat(message, \"\\n\").concat(e.stack));\n    } else {\n      console.warn(\"\".concat(message, \"\\n\").concat(e.stack));\n    }\n  }\n}\n\nfunction isEmptyString(string) {\n  return string === null || string === undefined || string === '';\n}\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/chordjs/lib/functions.js?");

/***/ }),

/***/ "./node_modules/chordjs/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/chordjs/lib/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"parse\", ({\n  enumerable: true,\n  get: function get() {\n    return _parse2[\"default\"];\n  }\n}));\nexports[\"default\"] = void 0;\n\nvar _parse2 = _interopRequireDefault(__webpack_require__(/*! ./parse */ \"./node_modules/chordjs/lib/parse.js\"));\n\nvar _functions = __webpack_require__(/*! ./functions */ \"./node_modules/chordjs/lib/functions.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _default = {\n  parse: function parse(chordString) {\n    (0, _functions.deprecate)('Chord.parse is deprecated, please use: import { parse } from \\'chordjs\\'; const chord = parse(\\'Esus\\');');\n    return (0, _parse2[\"default\"])(chordString);\n  }\n};\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/chordjs/lib/index.js?");

/***/ }),

/***/ "./node_modules/chordjs/lib/numeric_chord.js":
/*!***************************************************!*\
  !*** ./node_modules/chordjs/lib/numeric_chord.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _chord = _interopRequireDefault(__webpack_require__(/*! ./chord */ \"./node_modules/chordjs/lib/chord.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar NumericChord = /*#__PURE__*/function (_Chord) {\n  _inherits(NumericChord, _Chord);\n\n  var _super = _createSuper(NumericChord);\n\n  function NumericChord(_ref) {\n    var base = _ref.base,\n        modifier = _ref.modifier,\n        suffix = _ref.suffix,\n        bassBase = _ref.bassBase,\n        bassModifier = _ref.bassModifier;\n\n    _classCallCheck(this, NumericChord);\n\n    return _super.call(this, {\n      base: parseInt(base, 10),\n      modifier: modifier,\n      suffix: suffix,\n      bassBase: parseInt(bassBase, 10),\n      bassModifier: bassModifier\n    });\n  }\n\n  _createClass(NumericChord, [{\n    key: \"toString\",\n    value: function toString() {\n      var chordString = (this.modifier || '') + this.base + (this.suffix || '');\n\n      if (this.bassBase) {\n        return \"\".concat(chordString, \"/\").concat(this.bassModifier || '').concat(this.bassBase);\n      }\n\n      return chordString;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      return this.clone();\n    }\n  }, {\n    key: \"switchModifier\",\n    value: function switchModifier() {\n      return this.clone();\n    }\n  }, {\n    key: \"transpose\",\n    value: function transpose() {\n      return this.clone();\n    }\n  }, {\n    key: \"transposeUp\",\n    value: function transposeUp() {\n      return this.clone();\n    }\n  }, {\n    key: \"transposeDown\",\n    value: function transposeDown() {\n      return this.clone();\n    }\n  }, {\n    key: \"useModifier\",\n    value: function useModifier() {\n      return this.clone();\n    }\n  }]);\n\n  return NumericChord;\n}(_chord[\"default\"]);\n\nvar _default = NumericChord;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/chordjs/lib/numeric_chord.js?");

/***/ }),

/***/ "./node_modules/chordjs/lib/parse.js":
/*!*******************************************!*\
  !*** ./node_modules/chordjs/lib/parse.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _chord_symbol = _interopRequireDefault(__webpack_require__(/*! ./chord_symbol */ \"./node_modules/chordjs/lib/chord_symbol.js\"));\n\nvar _numeric_chord = _interopRequireDefault(__webpack_require__(/*! ./numeric_chord */ \"./node_modules/chordjs/lib/numeric_chord.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); _groups.set(_this, groups || _groups.get(re)); return _setPrototypeOf(_this, BabelRegExp.prototype); } _inherits(BabelRegExp, RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === \"string\") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\\$<([^>]+)>/g, function (_, name) { return \"$\" + groups[name]; })); } else if (typeof substitution === \"function\") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; if (_typeof(args[args.length - 1]) !== \"object\") { args = [].slice.call(args); args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar chordRegex = /*#__PURE__*/_wrapRegExp(/^([A-G])(#|b)?((?:(?![\\t-\\r \\/\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF])[\\s\\S])*)(\\/([A-G])(#|b)?)?$/i, {\n  base: 1,\n  modifier: 2,\n  suffix: 3,\n  bassBase: 5,\n  bassModifier: 6\n});\n\nvar numericChordRegex = /*#__PURE__*/_wrapRegExp(/^(#|b)?([1-7])((?:(?![\\t-\\r \\/\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF])[\\s\\S])*)(\\/(#|b)?([0-7]))?$/, {\n  modifier: 1,\n  base: 2,\n  suffix: 3,\n  bassModifier: 5,\n  bassBase: 6\n});\n\nvar classMapping = [[numericChordRegex, _numeric_chord[\"default\"]], [chordRegex, _chord_symbol[\"default\"]]];\n\nfunction parse(chordString) {\n  for (var i = 0, count = classMapping.length; i < count; i += 1) {\n    var _classMapping$i = _slicedToArray(classMapping[i], 2),\n        regex = _classMapping$i[0],\n        Klass = _classMapping$i[1];\n\n    var match = chordString.match(regex);\n\n    if (match) {\n      return new Klass(match.groups);\n    }\n  }\n\n  return null;\n}\n\nvar _default = parse;\nexports[\"default\"] = _default;\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/chordjs/lib/parse.js?");

/***/ }),

/***/ "./node_modules/chordsheetjs/lib/module.js":
/*!*************************************************!*\
  !*** ./node_modules/chordsheetjs/lib/module.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CHORUS\": () => (/* binding */ $234747a9630b4642$export$8db6c706fc9142b2),\n/* harmony export */   \"Chord\": () => (/* binding */ $5e3a0c5a6197f95b$export$2e2bcd8739ae039),\n/* harmony export */   \"ChordLyricsPair\": () => (/* binding */ $f7a904d05353aafa$export$2e2bcd8739ae039),\n/* harmony export */   \"ChordProFormatter\": () => (/* binding */ $feb758e68dd351a4$export$2e2bcd8739ae039),\n/* harmony export */   \"ChordProParser\": () => (/* binding */ $8e2b91641771a21c$export$2e2bcd8739ae039),\n/* harmony export */   \"ChordSheetParser\": () => (/* binding */ $9c17b505581d81bb$export$2e2bcd8739ae039),\n/* harmony export */   \"ChordSheetSerializer\": () => (/* binding */ $2a399cf90c614489$export$2e2bcd8739ae039),\n/* harmony export */   \"ChordsOverWordsParser\": () => (/* binding */ $b72f5288e28a9b64$export$2e2bcd8739ae039),\n/* harmony export */   \"Comment\": () => (/* binding */ $df4ad73a744c94b3$export$2e2bcd8739ae039),\n/* harmony export */   \"Composite\": () => (/* binding */ $ba84a02c63f26e83$export$2e2bcd8739ae039),\n/* harmony export */   \"HtmlDivFormatter\": () => (/* binding */ $de6608cf7e39dfee$export$2e2bcd8739ae039),\n/* harmony export */   \"HtmlTableFormatter\": () => (/* binding */ $fdcc84db82790d90$export$2e2bcd8739ae039),\n/* harmony export */   \"INDETERMINATE\": () => (/* binding */ $234747a9630b4642$export$c5a6fe907430212e),\n/* harmony export */   \"Key\": () => (/* binding */ $918eb2016ac61e41$export$2e2bcd8739ae039),\n/* harmony export */   \"Line\": () => (/* binding */ $06eb272065540fc1$export$2e2bcd8739ae039),\n/* harmony export */   \"Literal\": () => (/* binding */ $758385c5b662d76d$export$2e2bcd8739ae039),\n/* harmony export */   \"Metadata\": () => (/* binding */ $fdb42fd3b59812d4$export$2e2bcd8739ae039),\n/* harmony export */   \"NONE\": () => (/* binding */ $234747a9630b4642$export$c53d0f541b41b88e),\n/* harmony export */   \"NUMERIC\": () => (/* binding */ $234747a9630b4642$export$4d318981b5a83836),\n/* harmony export */   \"Paragraph\": () => (/* binding */ $55861b6d10167265$export$2e2bcd8739ae039),\n/* harmony export */   \"SYMBOL\": () => (/* binding */ $234747a9630b4642$export$27c95a7104c1f7aa),\n/* harmony export */   \"Song\": () => (/* binding */ $7860c26c4d50915f$export$2e2bcd8739ae039),\n/* harmony export */   \"TAB\": () => (/* binding */ $234747a9630b4642$export$f1c9dd0f5207dd5e),\n/* harmony export */   \"Tag\": () => (/* binding */ $b3836272a1374d85$export$2e2bcd8739ae039),\n/* harmony export */   \"Ternary\": () => (/* binding */ $d6f43bad3b61b86a$export$2e2bcd8739ae039),\n/* harmony export */   \"TextFormatter\": () => (/* binding */ $06a0261003eb9ba9$export$2e2bcd8739ae039),\n/* harmony export */   \"UltimateGuitarParser\": () => (/* binding */ $7c59209366f6488e$export$2e2bcd8739ae039),\n/* harmony export */   \"VERSE\": () => (/* binding */ $234747a9630b4642$export$4b194284baed1659),\n/* harmony export */   \"default\": () => (/* binding */ $149c1bd638913645$export$2e2bcd8739ae039),\n/* harmony export */   \"parseChord\": () => (/* binding */ $5e3a0c5a6197f95b$export$621b8187b24d90c6)\n/* harmony export */ });\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.get */ \"./node_modules/lodash.get/index.js\");\n/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// eslint-disable-next-line import/no-cycle\n\nclass $33b2f875bada793c$var$AstComponent {\n    line = null;\n    column = null;\n    offset = null;\n    constructor(traceInfo = null){\n        if (traceInfo) {\n            this.line = traceInfo.line || null;\n            this.column = traceInfo.column || null;\n            this.offset = traceInfo.offset || null;\n        }\n    }\n}\nvar $33b2f875bada793c$export$2e2bcd8739ae039 = $33b2f875bada793c$var$AstComponent;\n\n\nclass $b5c6143e2fff9a4c$var$Evaluatable extends (0, $33b2f875bada793c$export$2e2bcd8739ae039) {\n}\nvar $b5c6143e2fff9a4c$export$2e2bcd8739ae039 = $b5c6143e2fff9a4c$var$Evaluatable;\n\n\nclass $758385c5b662d76d$var$Literal extends (0, $b5c6143e2fff9a4c$export$2e2bcd8739ae039) {\n    constructor(expression){\n        super();\n        this.string = expression;\n    }\n    evaluate() {\n        return this.string;\n    }\n    isRenderable() {\n        return true;\n    }\n    clone() {\n        return new $758385c5b662d76d$var$Literal(this.string);\n    }\n}\nvar $758385c5b662d76d$export$2e2bcd8739ae039 = $758385c5b662d76d$var$Literal;\n\n\n// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 2.1.0 )\n//\n// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs\n\"use strict\";\nfunction $7cb09a9be1aff7bc$var$peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) return str;\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n}\nclass $7cb09a9be1aff7bc$export$f21cea08b0dd60e8 extends Error {\n    static buildMessage(expected, found) {\n        function hex(ch) {\n            return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n        function literalEscape(s) {\n            return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, (ch)=>\"\\\\x0\" + hex(ch)).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch)=>\"\\\\x\" + hex(ch));\n        }\n        function classEscape(s) {\n            return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, (ch)=>\"\\\\x0\" + hex(ch)).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch)=>\"\\\\x\" + hex(ch));\n        }\n        function describeExpectation(expectation) {\n            switch(expectation.type){\n                case \"literal\":\n                    return '\"' + literalEscape(expectation.text) + '\"';\n                case \"class\":\n                    const escapedParts = expectation.parts.map((part)=>{\n                        return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n                    });\n                    return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n                case \"any\":\n                    return \"any character\";\n                case \"end\":\n                    return \"end of input\";\n                case \"other\":\n                    return expectation.description;\n            }\n        }\n        function describeExpected(expected1) {\n            const descriptions = expected1.map(describeExpectation);\n            let i;\n            let j;\n            descriptions.sort();\n            if (descriptions.length > 0) {\n                for(i = 1, j = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {\n                    descriptions[j] = descriptions[i];\n                    j++;\n                }\n                descriptions.length = j;\n            }\n            switch(descriptions.length){\n                case 1:\n                    return descriptions[0];\n                case 2:\n                    return descriptions[0] + \" or \" + descriptions[1];\n                default:\n                    return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n            }\n        }\n        function describeFound(found1) {\n            return found1 ? '\"' + literalEscape(found1) + '\"' : \"end of input\";\n        }\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    }\n    constructor(message, expected, found, location){\n        super();\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n        if (typeof Object.setPrototypeOf === \"function\") Object.setPrototypeOf(this, $7cb09a9be1aff7bc$export$f21cea08b0dd60e8.prototype);\n        else this.__proto__ = $7cb09a9be1aff7bc$export$f21cea08b0dd60e8.prototype;\n        if (typeof Error.captureStackTrace === \"function\") Error.captureStackTrace(this, $7cb09a9be1aff7bc$export$f21cea08b0dd60e8);\n    }\n    format(sources) {\n        let str = \"Error: \" + this.message;\n        if (this.location) {\n            let src = null;\n            let k;\n            for(k = 0; k < sources.length; k++)if (sources[k].source === this.location.source) {\n                src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n                break;\n            }\n            let s = this.location.start;\n            let loc = this.location.source + \":\" + s.line + \":\" + s.column;\n            if (src) {\n                let e = this.location.end;\n                let filler = $7cb09a9be1aff7bc$var$peg$padEnd(\"\", s.line.toString().length, \" \");\n                let line = src[s.line - 1];\n                let last = s.line === e.line ? e.column : line.length + 1;\n                str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + $7cb09a9be1aff7bc$var$peg$padEnd(\"\", s.column - 1, \" \") + $7cb09a9be1aff7bc$var$peg$padEnd(\"\", last - s.column, \"^\");\n            } else str += \"\\n at \" + loc;\n        }\n        return str;\n    }\n}\nfunction $7cb09a9be1aff7bc$var$peg$parse(input, options) {\n    options = options !== undefined ? options : {};\n    const peg$FAILED = {};\n    const peg$source = options.grammarSource;\n    const peg$startRuleFunctions = {\n        Chord: peg$parseChord\n    };\n    let peg$startRuleFunction = peg$parseChord;\n    const peg$c0 = function(chord) {\n        return {\n            type: \"chord\",\n            ...chord,\n            column: location().start.column\n        };\n    };\n    const peg$c1 = \"#\";\n    const peg$c2 = peg$literalExpectation(\"#\", false);\n    const peg$c3 = \"b\";\n    const peg$c4 = peg$literalExpectation(\"b\", false);\n    const peg$c5 = /^[a-zA-Z0-9()#+]/;\n    const peg$c6 = peg$classExpectation([\n        [\n            \"a\",\n            \"z\"\n        ],\n        [\n            \"A\",\n            \"Z\"\n        ],\n        [\n            \"0\",\n            \"9\"\n        ],\n        \"(\",\n        \")\",\n        \"#\",\n        \"+\"\n    ], false, false);\n    const peg$c7 = function(root, modifier, suffix, bass) {\n        return {\n            base: root,\n            modifier: modifier,\n            suffix: suffix,\n            ...bass,\n            chordType: \"symbol\"\n        };\n    };\n    const peg$c8 = /^[A-Ga-g]/;\n    const peg$c9 = peg$classExpectation([\n        [\n            \"A\",\n            \"G\"\n        ],\n        [\n            \"a\",\n            \"g\"\n        ]\n    ], false, false);\n    const peg$c10 = \"/\";\n    const peg$c11 = peg$literalExpectation(\"/\", false);\n    const peg$c12 = function(root, modifier) {\n        return {\n            bassBase: root,\n            bassModifier: modifier\n        };\n    };\n    const peg$c13 = function(modifier, root, suffix, bass) {\n        return {\n            base: root,\n            modifier: modifier,\n            suffix: suffix,\n            ...bass,\n            chordType: \"numeral\"\n        };\n    };\n    const peg$c14 = \"III\";\n    const peg$c15 = peg$literalExpectation(\"III\", false);\n    const peg$c16 = \"iii\";\n    const peg$c17 = peg$literalExpectation(\"iii\", false);\n    const peg$c18 = \"VII\";\n    const peg$c19 = peg$literalExpectation(\"VII\", false);\n    const peg$c20 = \"vii\";\n    const peg$c21 = peg$literalExpectation(\"vii\", false);\n    const peg$c22 = \"II\";\n    const peg$c23 = peg$literalExpectation(\"II\", false);\n    const peg$c24 = \"ii\";\n    const peg$c25 = peg$literalExpectation(\"ii\", false);\n    const peg$c26 = \"IV\";\n    const peg$c27 = peg$literalExpectation(\"IV\", false);\n    const peg$c28 = \"iv\";\n    const peg$c29 = peg$literalExpectation(\"iv\", false);\n    const peg$c30 = \"VI\";\n    const peg$c31 = peg$literalExpectation(\"VI\", false);\n    const peg$c32 = \"vi\";\n    const peg$c33 = peg$literalExpectation(\"vi\", false);\n    const peg$c34 = \"I\";\n    const peg$c35 = peg$literalExpectation(\"I\", false);\n    const peg$c36 = \"i\";\n    const peg$c37 = peg$literalExpectation(\"i\", false);\n    const peg$c38 = \"V\";\n    const peg$c39 = peg$literalExpectation(\"V\", false);\n    const peg$c40 = \"v\";\n    const peg$c41 = peg$literalExpectation(\"v\", false);\n    const peg$c42 = function(modifier, root) {\n        return {\n            bassBase: root,\n            bassModifier: modifier\n        };\n    };\n    const peg$c43 = function(modifier, root, suffix, bass) {\n        return {\n            base: root,\n            modifier: modifier,\n            suffix: suffix,\n            ...bass,\n            chordType: \"numeric\"\n        };\n    };\n    const peg$c44 = /^[1-7]/;\n    const peg$c45 = peg$classExpectation([\n        [\n            \"1\",\n            \"7\"\n        ]\n    ], false, false);\n    let peg$currPos = 0;\n    let peg$savedPos = 0;\n    const peg$posDetailsCache = [\n        {\n            line: 1,\n            column: 1\n        }\n    ];\n    let peg$maxFailPos = 0;\n    let peg$maxFailExpected = [];\n    let peg$silentFails = 0;\n    let peg$result;\n    if (options.startRule !== undefined) {\n        if (!(options.startRule in peg$startRuleFunctions)) throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + '\".');\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n    }\n    function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location1) {\n        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError([\n            peg$otherExpectation(description)\n        ], input.substring(peg$savedPos, peg$currPos), location1);\n    }\n    function error(message, location1) {\n        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location1);\n    }\n    function peg$literalExpectation(text1, ignoreCase) {\n        return {\n            type: \"literal\",\n            text: text1,\n            ignoreCase: ignoreCase\n        };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n        return {\n            type: \"class\",\n            parts: parts,\n            inverted: inverted,\n            ignoreCase: ignoreCase\n        };\n    }\n    function peg$anyExpectation() {\n        return {\n            type: \"any\"\n        };\n    }\n    function peg$endExpectation() {\n        return {\n            type: \"end\"\n        };\n    }\n    function peg$otherExpectation(description) {\n        return {\n            type: \"other\",\n            description: description\n        };\n    }\n    function peg$computePosDetails(pos) {\n        let details = peg$posDetailsCache[pos];\n        let p;\n        if (details) return details;\n        else {\n            p = pos - 1;\n            while(!peg$posDetailsCache[p])p--;\n            details = peg$posDetailsCache[p];\n            details = {\n                line: details.line,\n                column: details.column\n            };\n            while(p < pos){\n                if (input.charCodeAt(p) === 10) {\n                    details.line++;\n                    details.column = 1;\n                } else details.column++;\n                p++;\n            }\n            peg$posDetailsCache[pos] = details;\n            return details;\n        }\n    }\n    function peg$computeLocation(startPos, endPos) {\n        const startPosDetails = peg$computePosDetails(startPos);\n        const endPosDetails = peg$computePosDetails(endPos);\n        return {\n            source: peg$source,\n            start: {\n                offset: startPos,\n                line: startPosDetails.line,\n                column: startPosDetails.column\n            },\n            end: {\n                offset: endPos,\n                line: endPosDetails.line,\n                column: endPosDetails.column\n            }\n        };\n    }\n    function peg$fail(expected1) {\n        if (peg$currPos < peg$maxFailPos) return;\n        if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected1);\n    }\n    function peg$buildSimpleError(message, location1) {\n        return new $7cb09a9be1aff7bc$export$f21cea08b0dd60e8(message, [], \"\", location1);\n    }\n    function peg$buildStructuredError(expected1, found, location1) {\n        return new $7cb09a9be1aff7bc$export$f21cea08b0dd60e8($7cb09a9be1aff7bc$export$f21cea08b0dd60e8.buildMessage(expected1, found), expected1, found, location1);\n    }\n    function peg$parseChord() {\n        let s0, s1;\n        s0 = peg$currPos;\n        s1 = peg$parseNumeral();\n        if (s1 === peg$FAILED) {\n            s1 = peg$parseNumeric();\n            if (s1 === peg$FAILED) s1 = peg$parseChordSymbol();\n        }\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c0(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parseChordModifier() {\n        let s0;\n        if (input.charCodeAt(peg$currPos) === 35) {\n            s0 = peg$c1;\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c2);\n        }\n        if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 98) {\n                s0 = peg$c3;\n                peg$currPos++;\n            } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c4);\n            }\n        }\n        return s0;\n    }\n    function peg$parseChordSuffix() {\n        let s0, s1;\n        s0 = [];\n        if (peg$c5.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c6);\n        }\n        while(s1 !== peg$FAILED){\n            s0.push(s1);\n            if (peg$c5.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c6);\n            }\n        }\n        return s0;\n    }\n    function peg$parseChordSymbol() {\n        let s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$parseChordSymbolRoot();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseChordModifier();\n            if (s2 === peg$FAILED) s2 = null;\n            if (s2 !== peg$FAILED) {\n                s3 = peg$currPos;\n                s4 = peg$parseChordSuffix();\n                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);\n                else s3 = s4;\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parseChordSymbolBass();\n                    if (s4 === peg$FAILED) s4 = null;\n                    if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c7(s1, s2, s3, s4);\n                        s0 = s1;\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseChordSymbolRoot() {\n        let s0;\n        if (peg$c8.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c9);\n        }\n        return s0;\n    }\n    function peg$parseChordSymbolBass() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c10;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c11);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseChordSymbolRoot();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseChordModifier();\n                if (s3 === peg$FAILED) s3 = null;\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c12(s2, s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseNumeral() {\n        let s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$parseChordModifier();\n        if (s1 === peg$FAILED) s1 = null;\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseNumeralRoot();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$currPos;\n                s4 = peg$parseChordSuffix();\n                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);\n                else s3 = s4;\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parseNumeralBass();\n                    if (s4 === peg$FAILED) s4 = null;\n                    if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c13(s1, s2, s3, s4);\n                        s0 = s1;\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseNumeralRoot() {\n        let s0;\n        if (input.substr(peg$currPos, 3) === peg$c14) {\n            s0 = peg$c14;\n            peg$currPos += 3;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c15);\n        }\n        if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3) === peg$c16) {\n                s0 = peg$c16;\n                peg$currPos += 3;\n            } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c17);\n            }\n            if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 3) === peg$c18) {\n                    s0 = peg$c18;\n                    peg$currPos += 3;\n                } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) peg$fail(peg$c19);\n                }\n                if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 3) === peg$c20) {\n                        s0 = peg$c20;\n                        peg$currPos += 3;\n                    } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) peg$fail(peg$c21);\n                    }\n                    if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 2) === peg$c22) {\n                            s0 = peg$c22;\n                            peg$currPos += 2;\n                        } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) peg$fail(peg$c23);\n                        }\n                        if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 2) === peg$c24) {\n                                s0 = peg$c24;\n                                peg$currPos += 2;\n                            } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) peg$fail(peg$c25);\n                            }\n                            if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 2) === peg$c26) {\n                                    s0 = peg$c26;\n                                    peg$currPos += 2;\n                                } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) peg$fail(peg$c27);\n                                }\n                                if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 2) === peg$c28) {\n                                        s0 = peg$c28;\n                                        peg$currPos += 2;\n                                    } else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) peg$fail(peg$c29);\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 2) === peg$c30) {\n                                            s0 = peg$c30;\n                                            peg$currPos += 2;\n                                        } else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) peg$fail(peg$c31);\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                            if (input.substr(peg$currPos, 2) === peg$c32) {\n                                                s0 = peg$c32;\n                                                peg$currPos += 2;\n                                            } else {\n                                                s0 = peg$FAILED;\n                                                if (peg$silentFails === 0) peg$fail(peg$c33);\n                                            }\n                                            if (s0 === peg$FAILED) {\n                                                if (input.charCodeAt(peg$currPos) === 73) {\n                                                    s0 = peg$c34;\n                                                    peg$currPos++;\n                                                } else {\n                                                    s0 = peg$FAILED;\n                                                    if (peg$silentFails === 0) peg$fail(peg$c35);\n                                                }\n                                                if (s0 === peg$FAILED) {\n                                                    if (input.charCodeAt(peg$currPos) === 105) {\n                                                        s0 = peg$c36;\n                                                        peg$currPos++;\n                                                    } else {\n                                                        s0 = peg$FAILED;\n                                                        if (peg$silentFails === 0) peg$fail(peg$c37);\n                                                    }\n                                                    if (s0 === peg$FAILED) {\n                                                        if (input.charCodeAt(peg$currPos) === 86) {\n                                                            s0 = peg$c38;\n                                                            peg$currPos++;\n                                                        } else {\n                                                            s0 = peg$FAILED;\n                                                            if (peg$silentFails === 0) peg$fail(peg$c39);\n                                                        }\n                                                        if (s0 === peg$FAILED) {\n                                                            if (input.charCodeAt(peg$currPos) === 118) {\n                                                                s0 = peg$c40;\n                                                                peg$currPos++;\n                                                            } else {\n                                                                s0 = peg$FAILED;\n                                                                if (peg$silentFails === 0) peg$fail(peg$c41);\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parseNumeralBass() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c10;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c11);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseChordModifier();\n            if (s2 === peg$FAILED) s2 = null;\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseNumeralRoot();\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c42(s2, s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseNumeric() {\n        let s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$parseChordModifier();\n        if (s1 === peg$FAILED) s1 = null;\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseNumericRoot();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$currPos;\n                s4 = peg$parseChordSuffix();\n                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);\n                else s3 = s4;\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parseNumericBass();\n                    if (s4 === peg$FAILED) s4 = null;\n                    if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c43(s1, s2, s3, s4);\n                        s0 = s1;\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseNumericRoot() {\n        let s0;\n        if (peg$c44.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c45);\n        }\n        return s0;\n    }\n    function peg$parseNumericBass() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c10;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c11);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseChordModifier();\n            if (s2 === peg$FAILED) s2 = null;\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseNumericRoot();\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c42(s2, s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;\n    else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());\n        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n}\nconst $7cb09a9be1aff7bc$export$98e6a39c04603d36 = $7cb09a9be1aff7bc$var$peg$parse;\n\n\n/**\n * Used to mark a paragraph as verse\n * @constant\n * @type {string}\n */ const $234747a9630b4642$export$4b194284baed1659 = \"verse\";\nconst $234747a9630b4642$export$8db6c706fc9142b2 = \"chorus\";\nconst $234747a9630b4642$export$c53d0f541b41b88e = \"none\";\nconst $234747a9630b4642$export$c5a6fe907430212e = \"indeterminate\";\nconst $234747a9630b4642$export$f1c9dd0f5207dd5e = \"tab\";\nconst $234747a9630b4642$export$27c95a7104c1f7aa = \"symbol\";\nconst $234747a9630b4642$export$4d318981b5a83836 = \"numeric\";\nconst $234747a9630b4642$export$1321df9b16c30c6a = \"numeral\";\nconst $234747a9630b4642$export$6145372d252f6576 = [\n    \"I\",\n    \"II\",\n    \"III\",\n    \"IV\",\n    \"V\",\n    \"VI\",\n    \"VII\"\n];\n\n\nconst $172dbd369d182971$var$A = \"A\".charCodeAt(0);\nconst $172dbd369d182971$var$G = \"G\".charCodeAt(0);\nconst $172dbd369d182971$var$TRANSPOSE_DISTANCE_MAJOR = {\n    1: 0,\n    2: 2,\n    3: 4,\n    4: 5,\n    5: 7,\n    6: 9,\n    7: 11\n};\nconst $172dbd369d182971$var$TRANSPOSE_DISTANCE_MINOR = {\n    1: 0,\n    2: 2,\n    3: 3,\n    4: 5,\n    5: 7,\n    6: 8,\n    7: 11\n};\nfunction $172dbd369d182971$var$keyToCharCode(key) {\n    return key.toUpperCase().charCodeAt(0);\n}\nfunction $172dbd369d182971$var$clamp(note, min, max) {\n    let newNote = note;\n    if (newNote < min) newNote += 7;\n    else if (newNote > max) newNote -= 7;\n    return newNote;\n}\nfunction $172dbd369d182971$var$numeralToNumber(numeral) {\n    for(let i = 0, count = (0, $234747a9630b4642$export$6145372d252f6576).length; i < count; i += 1){\n        const romanNumeral = (0, $234747a9630b4642$export$6145372d252f6576)[i];\n        if (romanNumeral === numeral || romanNumeral.toLowerCase() === numeral) return i + 1;\n    }\n    return null;\n}\nfunction $172dbd369d182971$var$numberToNumeral(number) {\n    return (0, $234747a9630b4642$export$6145372d252f6576)[number - 1];\n}\nclass $172dbd369d182971$var$Note {\n    minor = false;\n    constructor({ note: note , type: type , minor: minor = false  }){\n        this._note = note;\n        this.type = type;\n        this.minor = minor;\n    }\n    static parse(note) {\n        const noteString = note.toString();\n        if (/^[A-Ga-g]$/.test(noteString)) return new $172dbd369d182971$var$Note({\n            note: noteString.toUpperCase(),\n            type: (0, $234747a9630b4642$export$27c95a7104c1f7aa)\n        });\n        if (/^[1-7]$/.test(noteString)) return new $172dbd369d182971$var$Note({\n            note: parseInt(noteString, 10),\n            type: (0, $234747a9630b4642$export$4d318981b5a83836)\n        });\n        const romanNumeralValue = $172dbd369d182971$var$numeralToNumber(noteString);\n        if (romanNumeralValue) return new $172dbd369d182971$var$Note({\n            note: romanNumeralValue,\n            type: (0, $234747a9630b4642$export$1321df9b16c30c6a),\n            minor: noteString.toLowerCase() === note\n        });\n        throw new Error(`Invalid note ${note}`);\n    }\n    toNumeral() {\n        if (this.isNumeral()) return this.clone();\n        if (this.isNumeric()) return this.set({\n            type: (0, $234747a9630b4642$export$1321df9b16c30c6a)\n        });\n        throw new Error(`Converting a ${this.type} note to numeral is not supported`);\n    }\n    toNumeric() {\n        if (this.isNumeric()) return this.clone();\n        if (this.isNumeral()) return this.set({\n            type: (0, $234747a9630b4642$export$4d318981b5a83836)\n        });\n        throw new Error(`Converting a ${this.type} note to numeric is not supported`);\n    }\n    isMinor() {\n        return this.minor;\n    }\n    equals(otherNote) {\n        return this._note === otherNote._note && this.type === otherNote.type && this.minor === otherNote.minor;\n    }\n    clone() {\n        return this.set({});\n    }\n    up() {\n        return this.change(1);\n    }\n    down() {\n        return this.change(-1);\n    }\n    isOneOf(...options) {\n        return options.includes(this._note);\n    }\n    isNumeric() {\n        return this.is((0, $234747a9630b4642$export$4d318981b5a83836));\n    }\n    isChordSymbol() {\n        return this.is((0, $234747a9630b4642$export$27c95a7104c1f7aa));\n    }\n    isNumeral() {\n        return this.is((0, $234747a9630b4642$export$1321df9b16c30c6a));\n    }\n    is(noteType) {\n        return this.type === noteType;\n    }\n    getTransposeDistance(minor) {\n        if (typeof this._note === \"number\") {\n            if (minor && this._note in $172dbd369d182971$var$TRANSPOSE_DISTANCE_MINOR) return $172dbd369d182971$var$TRANSPOSE_DISTANCE_MINOR[this._note];\n            if (this._note in $172dbd369d182971$var$TRANSPOSE_DISTANCE_MAJOR) return $172dbd369d182971$var$TRANSPOSE_DISTANCE_MAJOR[this._note];\n        }\n        return 0;\n    }\n    change(delta) {\n        if (this.isChordSymbol()) {\n            let charCode;\n            charCode = $172dbd369d182971$var$keyToCharCode(this._note);\n            charCode += delta;\n            charCode = $172dbd369d182971$var$clamp(charCode, $172dbd369d182971$var$A, $172dbd369d182971$var$G);\n            return this.set({\n                note: String.fromCharCode(charCode)\n            });\n        }\n        let newNote = $172dbd369d182971$var$clamp(this._note + delta, 1, 7);\n        if (newNote < 1) newNote += 7;\n        else if (newNote > 7) newNote -= 7;\n        return this.set({\n            note: newNote\n        });\n    }\n    get note() {\n        if (this.isNumeral()) {\n            const numeral = $172dbd369d182971$var$numberToNumeral(this._note);\n            if (this.isMinor()) return numeral.toLowerCase();\n            return numeral;\n        }\n        return this._note;\n    }\n    toString() {\n        const note = this.note;\n        switch(this.type){\n            case 0, $234747a9630b4642$export$1321df9b16c30c6a:\n                return `${this.minor ? note.toLowerCase() : note.toUpperCase()}`;\n            default:\n                return `${this.note}`;\n        }\n    }\n    set(properties) {\n        return new $172dbd369d182971$var$Note({\n            note: this._note,\n            type: this.type,\n            minor: this.minor,\n            ...properties\n        });\n    }\n}\nvar $172dbd369d182971$export$2e2bcd8739ae039 = $172dbd369d182971$var$Note;\n\n\n\nconst $a2e1bf5465822273$var$enharmonics = {\n    \"Ab\": {\n        \"B\": \"Cb\"\n    },\n    \"Cb\": {\n        \"B\": \"Cb\",\n        \"A#\": \"Bb\",\n        \"E\": \"Fb\"\n    },\n    \"C\": {\n        \"C#\": \"Db\",\n        \"D#\": \"Eb\",\n        \"F#\": \"Gb\",\n        \"G#\": \"Ab\",\n        \"A#\": \"Bb\"\n    },\n    \"C#\": {\n        \"Eb\": \"D#\",\n        \"Bb\": \"A#\"\n    },\n    \"Db\": {\n        \"B\": \"Cb\",\n        \"F#\": \"Gb\"\n    },\n    \"D\": {\n        \"D#\": \"Eb\",\n        \"A#\": \"Bb\",\n        \"Gb\": \"F#\"\n    },\n    \"Eb\": {\n        \"D#\": \"Eb\",\n        \"F#\": \"Gb\",\n        \"G#\": \"Ab\",\n        \"A#\": \"Bb\"\n    },\n    \"E\": {\n        \"Ab\": \"G#\",\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\",\n        \"Db\": \"C#\",\n        \"Eb\": \"D#\"\n    },\n    \"F\": {\n        \"A#\": \"Bb\",\n        \"F#\": \"Gb\",\n        \"C#\": \"Db\",\n        \"D#\": \"Eb\",\n        \"G#\": \"Ab\"\n    },\n    \"F#\": {\n        \"Bb\": \"A#\",\n        \"Eb\": \"D#\"\n    },\n    \"Gb\": {\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\",\n        \"G#\": \"Ab\",\n        \"B\": \"Cb\",\n        \"E\": \"Fb\"\n    },\n    \"G\": {\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\",\n        \"G#\": \"Ab\",\n        \"C#\": \"Db\"\n    },\n    \"G#\": {\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\",\n        \"Cb\": \"B#\"\n    },\n    \"Am\": {\n        \"Gb\": \"G\",\n        \"G#\": \"Ab\",\n        \"F#\": \"Gb\",\n        \"C#\": \"Db\",\n        \"D#\": \"Eb\",\n        \"A#\": \"Bb\"\n    },\n    \"Bbm\": {\n        \"Cb\": \"B\",\n        \"Gb\": \"F#\"\n    },\n    \"Bm\": {\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\"\n    },\n    \"C#m\": {\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\",\n        \"Gb\": \"F#\"\n    },\n    \"Cm\": {\n        \"G#\": \"Ab\",\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\",\n        \"F#\": \"Gb\",\n        \"C#\": \"Db\"\n    },\n    \"Dm\": {\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\",\n        \"F#\": \"Gb\",\n        \"G#\": \"Ab\",\n        \"C#\": \"Db\"\n    },\n    \"Em\": {\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\",\n        \"C#\": \"Db\"\n    },\n    \"F#m\": {\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\",\n        \"Gb\": \"F#\",\n        \"Ab\": \"G#\",\n        \"Db\": \"C#\"\n    },\n    \"Fm\": {\n        \"G#\": \"Ab\",\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\",\n        \"F#\": \"Gb\",\n        \"C#\": \"Db\"\n    },\n    \"Gm\": {\n        \"G#\": \"Ab\",\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\",\n        \"C#\": \"Db\",\n        \"F#\": \"Gb\"\n    },\n    \"G#m\": {\n        \"A#\": \"Bb\",\n        \"D#\": \"Eb\"\n    },\n    \"B\": {\n        \"Eb\": \"D#\"\n    }\n};\nvar $a2e1bf5465822273$export$2e2bcd8739ae039 = $a2e1bf5465822273$var$enharmonics;\n\n\n\nconst $974bd1d260bb1d53$export$d332d76d125f0cbe = (line)=>line.items.some((item)=>item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039) && !!item.chords);\nconst $974bd1d260bb1d53$export$e3f63561d52b936d = (item)=>\"evaluate\" in item && typeof item.evaluate === \"function\";\nconst $974bd1d260bb1d53$export$bc3bea8325045070 = (string, length)=>{\n    let paddedString = string;\n    for(let l = string.length; l < length; l += 1, paddedString += \" \");\n    return paddedString;\n};\nconst $974bd1d260bb1d53$export$ee27c052bca048fb = (object)=>!!object && object.length > 0;\nconst $974bd1d260bb1d53$export$844ec244b1367d54 = (obj)=>typeof obj === \"string\";\nfunction $974bd1d260bb1d53$var$dasherize(string) {\n    return string.replace(/[A-Z]/g, (match)=>`-${match.toLowerCase()}`);\n}\nfunction $974bd1d260bb1d53$export$59d377d2a2e0150a(css, scope = \"\") {\n    return Object.entries(css).map(([selector, styles])=>{\n        const rules = Object.entries(styles).map(([property, value])=>`${$974bd1d260bb1d53$var$dasherize(property)}: ${value};`).join(\"\\n  \");\n        const scopedSelector = `${scope} ${selector}`.trim();\n        return `\n${scopedSelector} {\n  ${rules}\n}`.substring(1);\n    }).join(\"\\n\\n\");\n}\nfunction $974bd1d260bb1d53$export$b680e6b2c82f8c2f(message) {\n    try {\n        throw new Error(`DEPRECATION: ${message}`);\n    } catch (e) {\n        const error = e;\n        const proc = globalThis.process;\n        if (typeof proc === \"object\" && typeof proc.emitWarning === \"function\") proc.emitWarning(`${message}\\n${error.stack}`);\n        else console.warn(`${message}\\n${error.stack}`);\n    }\n}\nfunction $974bd1d260bb1d53$export$c73e2a74b163f89e(message) {\n    throw new Error(`BREAKING CHANGE: ${message}`);\n}\nfunction $974bd1d260bb1d53$export$78d1711480f95c3e(string) {\n    return string === null || string === undefined || string === \"\";\n}\nfunction $974bd1d260bb1d53$export$51fabfbeed747719(suffix) {\n    if (typeof suffix !== \"string\") return false;\n    return suffix[0] === \"m\" && suffix.substring(0, 3).toLowerCase() !== \"maj\";\n}\nfunction $974bd1d260bb1d53$export$ba13e0e2f19e61a1(string) {\n    return string.replace(/\\r\\n?/g, \"\\n\");\n}\n\n\nconst $918eb2016ac61e41$var$FLAT = \"b\";\nconst $918eb2016ac61e41$var$SHARP = \"#\";\nconst $918eb2016ac61e41$var$symbolKeyRegex = /^(?<note>[A-G])(?<modifier>#|b)?(?<minor>m)?$/i;\nconst $918eb2016ac61e41$var$numericKeyRegex = /^(?<modifier>#|b)?(?<note>[1-7])(?<minor>m)?$/;\nconst $918eb2016ac61e41$var$numeralKeyRegex = /^(?<modifier>#|b)?(?<note>I{1,3}|IV|VI{0,2}|i{1,3}|iv|vi{0,2})$/;\nconst $918eb2016ac61e41$var$regexes = [\n    $918eb2016ac61e41$var$symbolKeyRegex,\n    $918eb2016ac61e41$var$numericKeyRegex,\n    $918eb2016ac61e41$var$numeralKeyRegex\n];\nfunction $918eb2016ac61e41$var$modifierTransposition(modifier) {\n    switch(modifier){\n        case $918eb2016ac61e41$var$SHARP:\n            return 1;\n        case $918eb2016ac61e41$var$FLAT:\n            return -1;\n        default:\n            return 0;\n    }\n}\n/**\n * Represents a key, such as Eb (symbol), #3 (numeric) or VII (numeral).\n *\n * The only function considered public API is `Key.distance`\n */ class $918eb2016ac61e41$var$Key {\n    modifier = null;\n    minor = false;\n    static parse(keyString) {\n        if (!keyString || (0, $974bd1d260bb1d53$export$78d1711480f95c3e)(keyString)) return null;\n        for(let i = 0, count = $918eb2016ac61e41$var$regexes.length; i < count; i += 1){\n            const match = keyString.match($918eb2016ac61e41$var$regexes[i]);\n            if (match) {\n                const { note: note , modifier: modifier , minor: minor  } = match.groups;\n                return new $918eb2016ac61e41$var$Key({\n                    note: note,\n                    modifier: modifier,\n                    minor: !!minor\n                });\n            }\n        }\n        return null;\n    }\n    static parseOrFail(keyString) {\n        const parsed = this.parse(keyString);\n        if (!parsed) throw new Error(`Failed to parse ${keyString}`);\n        return parsed;\n    }\n    static wrap(keyStringOrObject) {\n        if (keyStringOrObject instanceof $918eb2016ac61e41$var$Key) return keyStringOrObject;\n        return this.parse(keyStringOrObject);\n    }\n    static wrapOrFail(keyStringOrObject = null) {\n        if (keyStringOrObject === null) throw new Error(\"Unexpected null key\");\n        const wrapped = this.wrap(keyStringOrObject);\n        if (wrapped === null) throw new Error(`Failed: invalid key ${keyStringOrObject}`);\n        return wrapped;\n    }\n    static toString(keyStringOrObject) {\n        return `${$918eb2016ac61e41$var$Key.wrapOrFail(keyStringOrObject)}`;\n    }\n    /**\n   * Calculates the distance in semitones between one key and another.\n   * @param {Key | string} oneKey the key\n   * @param {Key | string} otherKey the other key\n   * @return {number} the distance in semitones\n   */ static distance(oneKey, otherKey) {\n        return this.wrapOrFail(oneKey).distanceTo(otherKey);\n    }\n    distanceTo(otherKey) {\n        const otherKeyObj = $918eb2016ac61e41$var$Key.wrapOrFail(otherKey);\n        let key = this.useModifier(otherKeyObj.modifier);\n        let delta = 0;\n        while(!key.equals(otherKeyObj) && delta < 20){\n            key = key.transposeUp().useModifier(otherKeyObj.modifier);\n            delta += 1;\n        }\n        return delta;\n    }\n    constructor({ note: note , modifier: modifier = null , minor: minor = false  }){\n        this.note = note instanceof (0, $172dbd369d182971$export$2e2bcd8739ae039) ? note : (0, $172dbd369d182971$export$2e2bcd8739ae039).parse(note);\n        this.modifier = modifier || null;\n        this.minor = minor || false;\n        if (this.minor) this.note.minor = true;\n    }\n    isMinor() {\n        return this.minor || this.note.isMinor();\n    }\n    clone() {\n        return this.set({});\n    }\n    toChordSymbol(key) {\n        if (this.is((0, $234747a9630b4642$export$27c95a7104c1f7aa))) return this.clone();\n        const transposeDistance = this.note.getTransposeDistance(key.minor) + $918eb2016ac61e41$var$modifierTransposition(this.modifier);\n        return key.transpose(transposeDistance).normalize().useModifier(key.modifier);\n    }\n    toChordSymbolString(key) {\n        return this.toChordSymbol(key).toString();\n    }\n    is(type) {\n        return this.note.is(type);\n    }\n    isNumeric() {\n        return this.is((0, $234747a9630b4642$export$4d318981b5a83836));\n    }\n    isChordSymbol() {\n        return this.is((0, $234747a9630b4642$export$27c95a7104c1f7aa));\n    }\n    isNumeral() {\n        return this.is((0, $234747a9630b4642$export$1321df9b16c30c6a));\n    }\n    equals(otherKey) {\n        return this.note.equals(otherKey.note) && this.modifier === otherKey.modifier;\n    }\n    toNumeric(key = null) {\n        if (this.isNumeric()) return this.clone();\n        if (this.isNumeral()) return this.set({\n            note: this.note.toNumeric()\n        });\n        if (!key) throw new Error(\"key is required\");\n        return this.transposeNoteUpToKey(1, key);\n    }\n    toNumericString(key = null) {\n        return this.toNumeric(key).toString();\n    }\n    toNumeral(key = null) {\n        if (this.isNumeral()) return this.clone();\n        if (this.isNumeric()) return this.set({\n            note: this.note.toNumeral()\n        });\n        if (key) return this.transposeNoteUpToKey(\"I\", key);\n        return this.clone();\n    }\n    toNumeralString(key = null) {\n        return this.toNumeral(key).toString();\n    }\n    toString({ showMinor: showMinor = true  } = {}) {\n        switch(this.note.type){\n            case 0, $234747a9630b4642$export$27c95a7104c1f7aa:\n                return this.formatChordSymbolString(showMinor);\n            case 0, $234747a9630b4642$export$4d318981b5a83836:\n                return this.formatNumericString(showMinor);\n            case 0, $234747a9630b4642$export$1321df9b16c30c6a:\n                return this.formatNumeralString();\n            default:\n                throw new Error(`Unexpected note type ${this.note.type}`);\n        }\n    }\n    formatChordSymbolString(showMinor) {\n        return `${this.note}${this.modifier || \"\"}${this.minor && showMinor ? \"m\" : \"\"}`;\n    }\n    formatNumericString(showMinor) {\n        return `${this.modifier || \"\"}${this.note}${this.minor && showMinor ? \"m\" : \"\"}`;\n    }\n    formatNumeralString() {\n        return `${this.modifier || \"\"}${this.note}`;\n    }\n    transpose(delta) {\n        if (delta === 0) return this;\n        const originalModifier = this.modifier;\n        let transposedKey = this.clone();\n        const func = delta < 0 ? \"transposeDown\" : \"transposeUp\";\n        for(let i = 0, count = Math.abs(delta); i < count; i += 1)transposedKey = transposedKey[func]();\n        return transposedKey.useModifier(originalModifier);\n    }\n    transposeUp() {\n        if (this.modifier === $918eb2016ac61e41$var$FLAT) return this.set({\n            modifier: null\n        });\n        if (this.note.isOneOf(3, 7, \"E\", \"B\")) return this.set({\n            note: this.note.up()\n        });\n        if (this.modifier === $918eb2016ac61e41$var$SHARP) return this.set({\n            note: this.note.up(),\n            modifier: null\n        });\n        return this.set({\n            modifier: $918eb2016ac61e41$var$SHARP\n        });\n    }\n    transposeDown() {\n        if (this.modifier === $918eb2016ac61e41$var$SHARP) return this.set({\n            modifier: null\n        });\n        if (this.note.isOneOf(1, 4, \"C\", \"F\")) return this.set({\n            note: this.note.down()\n        });\n        if (this.modifier === $918eb2016ac61e41$var$FLAT) return this.set({\n            note: this.note.down(),\n            modifier: null\n        });\n        return this.set({\n            modifier: $918eb2016ac61e41$var$FLAT\n        });\n    }\n    useModifier(newModifier) {\n        if (this.modifier === $918eb2016ac61e41$var$FLAT && newModifier === $918eb2016ac61e41$var$SHARP) return this.set({\n            note: this.note.down(),\n            modifier: $918eb2016ac61e41$var$SHARP\n        });\n        if (this.modifier === $918eb2016ac61e41$var$SHARP && newModifier === $918eb2016ac61e41$var$FLAT) return this.set({\n            note: this.note.up(),\n            modifier: $918eb2016ac61e41$var$FLAT\n        });\n        return this.clone();\n    }\n    normalize() {\n        if (this.modifier === $918eb2016ac61e41$var$SHARP && this.note.isOneOf(3, 7, \"E\", \"B\")) return this.set({\n            note: this.note.up(),\n            modifier: null\n        });\n        if (this.modifier === $918eb2016ac61e41$var$FLAT && this.note.isOneOf(1, 4, \"C\", \"F\")) return this.set({\n            note: this.note.down(),\n            modifier: null\n        });\n        return this.clone();\n    }\n    removeMinor() {\n        return this.set({\n            minor: false\n        });\n    }\n    normalizeEnharmonics(key) {\n        if (key) {\n            const rootKeyString = $918eb2016ac61e41$var$Key.wrapOrFail(key).toString({\n                showMinor: true\n            });\n            const enharmonics = (0, $a2e1bf5465822273$export$2e2bcd8739ae039)[rootKeyString];\n            const thisKeyString = this.toString({\n                showMinor: false\n            });\n            if (enharmonics && enharmonics[thisKeyString]) return $918eb2016ac61e41$var$Key.parseOrFail(enharmonics[thisKeyString]);\n        }\n        return this.clone();\n    }\n    set(attributes) {\n        return new $918eb2016ac61e41$var$Key({\n            note: this.note.clone(),\n            modifier: this.modifier,\n            minor: this.minor,\n            ...attributes\n        });\n    }\n    transposeNoteUpToKey(note, key) {\n        let numericKey = new $918eb2016ac61e41$var$Key({\n            note: note\n        });\n        let symbolKey = key.clone();\n        const reference = this.clone().normalize().useModifier(key.modifier).normalizeEnharmonics(key);\n        while(!symbolKey.equals(reference)){\n            numericKey = numericKey.transposeUp().useModifier(key.modifier);\n            symbolKey = symbolKey.transposeUp().normalize().useModifier(key.modifier).normalizeEnharmonics(key);\n        }\n        return numericKey;\n    }\n}\nvar $918eb2016ac61e41$export$2e2bcd8739ae039 = $918eb2016ac61e41$var$Key;\n\n\nconst $7ec1df4bbc0938c9$var$mapping = {\n    \"2\": \"2\",\n    \"4\": \"sus\",\n    \"5\": \"5\",\n    \"6\": \"6\",\n    \"7\": \"7\",\n    \"9\": \"9\",\n    \"11\": \"11\",\n    \"13\": \"13\",\n    \"42\": \"4(2)\",\n    \"69\": \"6(9)\",\n    \"(#4)\": \"(#4)\",\n    \"#4\": \"(#4)\",\n    \"+4\": \"(#4)\",\n    \"(+4)\": \"(#4)\",\n    \"(11)\": \"(11)\",\n    \"add11\": \"(11)\",\n    \"(add11)\": \"(11)\",\n    \"(13)\": \"(13)\",\n    \"add13\": \"(13)\",\n    \"(add13)\": \"(13)\",\n    \"(2)\": \"(2)\",\n    \"add2\": \"(2)\",\n    \"(add2)\": \"(2)\",\n    \"(4)\": \"(4)\",\n    \"add4\": \"(4)\",\n    \"(add4)\": \"(4)\",\n    \"sus(4)\": \"(4)\",\n    \"(6)\": \"(6)\",\n    \"add6\": \"(6)\",\n    \"(add6)\": \"(6)\",\n    \"(7)\": \"(7)\",\n    \"(9)\": \"(9)\",\n    \"add9\": \"(9)\",\n    \"(add9)\": \"(9)\",\n    \"(b5)\": \"(b5)\",\n    \"-5\": \"(b5)\",\n    \"(-5)\": \"(b5)\",\n    \"b5\": \"(b5)\",\n    \"2(6)\": \"2(6)\",\n    \"(b6)\": \"(b6)\",\n    \"(unis)\": \"(unis)\",\n    \"unis\": \"(unis)\",\n    \"[blank]\": \"[blank]\",\n    \"maj\": \"[blank]\",\n    \"major\": \"[blank]\",\n    \"M\": \"[blank]\",\n    \"ma\": \"[blank]\",\n    \"Ma\": \"[blank]\",\n    \"Majj\": \"[blank]\",\n    \"+\": \"+\",\n    \"aug\": \"+\",\n    \"(#5)\": \"+\",\n    \"#5\": \"+\",\n    \"+5\": \"+\",\n    \"(+5)\": \"+\",\n    \"x\": \"+\",\n    \"dom11\": \"11\",\n    \"dom 11\": \"11\",\n    \"11(#5)\": \"11(#5)\",\n    \"11#5\": \"11(#5)\",\n    \"11+5\": \"11(#5)\",\n    \"11(+5)\": \"11(#5)\",\n    \"11(#9)\": \"11(#9)\",\n    \"11#9\": \"11(#9)\",\n    \"11+9\": \"11(#9)\",\n    \"11(+9)\": \"11(#9)\",\n    \"11(b13)\": \"11(b13)\",\n    \"11b13\": \"11(b13)\",\n    \"11-13\": \"11(b13)\",\n    \"11(-13)\": \"11(b13)\",\n    \"11(b5)\": \"11(b5)\",\n    \"11b5\": \"11(b5)\",\n    \"11-5\": \"11(b5)\",\n    \"11(-5)\": \"11(b5)\",\n    \"11(b9)\": \"11(b9)\",\n    \"11b9\": \"11(b9)\",\n    \"11-9\": \"11(b9)\",\n    \"11(-9)\": \"11(b9)\",\n    \"11sus4\": \"11sus4\",\n    \"11sus\": \"11sus4\",\n    \"m11sus4\": \"11sus4\",\n    \"m11sus\": \"11sus4\",\n    \"dom13\": \"13\",\n    \"dom 13\": \"13\",\n    \"13(#11)\": \"13(#11)\",\n    \"13#11\": \"13(#11)\",\n    \"13+11\": \"13(#11)\",\n    \"13(+11)\": \"13(#11)\",\n    \"13(#5)\": \"13(#5)\",\n    \"13#5\": \"13(#5)\",\n    \"13+5\": \"13(#5)\",\n    \"13(+5)\": \"13(#5)\",\n    \"13(#9)\": \"13(#9)\",\n    \"13#9\": \"13(#9)\",\n    \"13(+9)\": \"13(#9)\",\n    \"13+9\": \"13(#9)\",\n    \"13(#9#5)\": \"13(#9#5)\",\n    \"13#9#5\": \"13(#9#5)\",\n    \"13(+9+5)\": \"13(#9#5)\",\n    \"13+9+5\": \"13(#9#5)\",\n    \"13(#9b5)\": \"13(#9b5)\",\n    \"13#9b5\": \"13(#9b5)\",\n    \"13(+9-5)\": \"13(#9b5)\",\n    \"13+9-5\": \"13(#9b5)\",\n    \"13(add4)\": \"13(add4)\",\n    \"13(b5)\": \"13(b5)\",\n    \"13b5\": \"13(b5)\",\n    \"13-5\": \"13(b5)\",\n    \"13(-5)\": \"13(b5)\",\n    \"13(b9)\": \"13(b9)\",\n    \"13b9\": \"13(b9)\",\n    \"13-9\": \"13(b9)\",\n    \"13(-9)\": \"13(b9)\",\n    \"13(b9#5)\": \"13(b9#5)\",\n    \"13b9#5\": \"13(b9#5)\",\n    \"13-9+5\": \"13(b9#5)\",\n    \"13(-9+5)\": \"13(b9#5)\",\n    \"13(b9b5)\": \"13(b9b5)\",\n    \"13b9b5\": \"13(b9b5)\",\n    \"13-9-5\": \"13(b9b5)\",\n    \"13(-9-5)\": \"13(b9b5)\",\n    \"13sus4\": \"13sus4\",\n    \"13sus\": \"13sus4\",\n    \"m13sus4\": \"13sus4\",\n    \"m13sus\": \"13sus4\",\n    \"sus2\": \"2\",\n    \"add9(no3)\": \"2\",\n    \"2(#11)\": \"2(#11)\",\n    \"2(#4)\": \"2(#4)\",\n    \"2+4\": \"2(#4)\",\n    \"2#4\": \"2(#4)\",\n    \"2(+4)\": \"2(#4)\",\n    \"(#4)2\": \"2(#4)\",\n    \"2(#4)(#42)(2#4)\": \"2(#4)(#42)(2#4)\",\n    \"2(+7)\": \"2(+7)\",\n    \"2(4)\": \"2(4)\",\n    \"sus2(4)\": \"2(4)\",\n    \"2(ma7)\": \"2(ma7)\",\n    \"2(no3)\": \"2(no3)\",\n    \"4(2)\": \"4(2)\",\n    \"sus42\": \"4(2)\",\n    \"no3\": \"5\",\n    \"(no3)\": \"5\",\n    \"(no 3)\": \"5\",\n    \"(no 3rd)\": \"5\",\n    \"5(no3)\": \"5\",\n    \"6(2)\": \"6(2)\",\n    \"6(b9)\": \"6(b9)\",\n    \"6(no3)\": \"6(no3)\",\n    \"6(9)\": \"6(9)\",\n    \"6(add9)\": \"6(9)\",\n    \"dom7\": \"7\",\n    \"dom 7\": \"7\",\n    \"dom 7th\": \"7\",\n    \"7(#11)\": \"7(#11)\",\n    \"7#11\": \"7(#11)\",\n    \"7+11\": \"7(#11)\",\n    \"7(+11)\": \"7(#11)\",\n    \"7(#5)\": \"7(#5)\",\n    \"aug7\": \"7(#5)\",\n    \"7#5\": \"7(#5)\",\n    \"7+5\": \"7(#5)\",\n    \"7(+5)\": \"7(#5)\",\n    \"x7\": \"7(#5)\",\n    \"aug 7\": \"7(#5)\",\n    \"aug 7th\": \"7(#5)\",\n    \"7(#5#11)\": \"7(#5#11)\",\n    \"7#5#11\": \"7(#5#11)\",\n    \"7+5+11\": \"7(#5#11)\",\n    \"7(+5+11)\": \"7(#5#11)\",\n    \"7(#9)\": \"7(#9)\",\n    \"7#9\": \"7(#9)\",\n    \"7+9\": \"7(#9)\",\n    \"7(+9)\": \"7(#9)\",\n    \"7(#9#5)\": \"7(#9#5)\",\n    \"7(#5#9)\": \"7(#9#5)\",\n    \"7#5#9\": \"7(#9#5)\",\n    \"7+5+9\": \"7(#9#5)\",\n    \"7(+5+9)\": \"7(#9#5)\",\n    \"7(#9b13)\": \"7(#9b13)\",\n    \"7#9b13\": \"7(#9b13)\",\n    \"7(+9-13)\": \"7(#9b13)\",\n    \"7+9-13\": \"7(#9b13)\",\n    \"7(b13#9)\": \"7(#9b13)\",\n    \"7b13#9\": \"7(#9b13)\",\n    \"7-13+9\": \"7(#9b13)\",\n    \"7(-13+9)\": \"7(#9b13)\",\n    \"7(#9b5)\": \"7(#9b5)\",\n    \"7(6)\": \"7(6)\",\n    \"7(b13)\": \"7(b13)\",\n    \"7b13\": \"7(b13)\",\n    \"7-13\": \"7(b13)\",\n    \"7(-13)\": \"7(b13)\",\n    \"7(b5)\": \"7(b5)\",\n    \"7b5\": \"7(b5)\",\n    \"7-5\": \"7(b5)\",\n    \"7(-5)\": \"7(b5)\",\n    \"7(b5#11)\": \"7(b5#11)\",\n    \"7b5#11\": \"7(b5#11)\",\n    \"7-5+11\": \"7(b5#11)\",\n    \"7(-5+11)\": \"7(b5#11)\",\n    \"7(b5#9)\": \"7(b5#9)\",\n    \"7b5#9\": \"7(b5#9)\",\n    \"7-5+9\": \"7(b5#9)\",\n    \"7(-5+9)\": \"7(b5#9)\",\n    \"7(b5b9)\": \"7(b5b9)\",\n    \"7b5b9\": \"7(b5b9)\",\n    \"7-5-9\": \"7(b5b9)\",\n    \"7(-5-9)\": \"7(b5b9)\",\n    \"7(b9)\": \"7(b9)\",\n    \"7b9\": \"7(b9)\",\n    \"7-9\": \"7(b9)\",\n    \"7(-9)\": \"7(b9)\",\n    \"7(b9#5)\": \"7(b9#5)\",\n    \"7(#5b9)\": \"7(b9#5)\",\n    \"7#5b9\": \"7(b9#5)\",\n    \"7+5-9\": \"7(b9#5)\",\n    \"7(+5-9)\": \"7(b9#5)\",\n    \"7(b9b13)\": \"7(b9b13)\",\n    \"7b9b13\": \"7(b9b13)\",\n    \"7-9-13\": \"7(b9b13)\",\n    \"7(-9-13)\": \"7(b9b13)\",\n    \"7(b13b9)\": \"7(b9b13)\",\n    \"7b13b9\": \"7(b9b13)\",\n    \"7-13-9\": \"7(b9b13)\",\n    \"7(-13-9)\": \"7(b9b13)\",\n    \"7(b9b5)\": \"7(b9b5)\",\n    \"7(no3)\": \"7(no3)\",\n    \"7aug5\": \"7aug5\",\n    \"7b9sus4\": \"7b9sus4\",\n    \"7sus(6)\": \"7sus(6)\",\n    \"7sus(b9)\": \"7sus(b9)\",\n    \"7sus4\": \"7sus4\",\n    \"7sus\": \"7sus4\",\n    \"dom9\": \"9\",\n    \"dom 9\": \"9\",\n    \"9(#11)\": \"9(#11)\",\n    \"9#11\": \"9(#11)\",\n    \"9+11\": \"9(#11)\",\n    \"9(+11)\": \"9(#11)\",\n    \"9(#5)\": \"9(#5)\",\n    \"9#5\": \"9(#5)\",\n    \"9+5\": \"9(#5)\",\n    \"9(+5)\": \"9(#5)\",\n    \"aug9\": \"9(#5)\",\n    \"x9\": \"9(#5)\",\n    \"9(b13)\": \"9(b13)\",\n    \"9b13\": \"9(b13)\",\n    \"9-13\": \"9(b13)\",\n    \"9(-13)\": \"9(b13)\",\n    \"9(b5)\": \"9(b5)\",\n    \"9b5\": \"9(b5)\",\n    \"9-5\": \"9(b5)\",\n    \"9(-5)\": \"9(b5)\",\n    \"9aug\": \"9aug\",\n    \"9sus4\": \"9sus4\",\n    \"9sus\": \"9sus4\",\n    \"m9sus4\": \"9sus4\",\n    \"m9sus\": \"9sus4\",\n    \"b69(#11)\": \"b69(#11)\",\n    \"b69sus\": \"b69sus\",\n    \"b9sus\": \"b9sus\",\n    \"dim\": \"dim\",\n    \"m(b5)\": \"dim\",\n    \"mb5\": \"dim\",\n    \"m-5\": \"dim\",\n    \"m(-5)\": \"dim\",\n    \"-(b5)\": \"dim\",\n    \"-b5\": \"dim\",\n    \"dim7\": \"dim7\",\n    \"o7\": \"dim7\",\n    \"dim 7\": \"dim7\",\n    \"dim 7th\": \"dim7\",\n    \"m\": \"m\",\n    \"mi\": \"m\",\n    \"min\": \"m\",\n    \"minor\": \"m\",\n    \"-\": \"m\",\n    \"m(11)\": \"m(11)\",\n    \"m(add11)\": \"m(11)\",\n    \"m(4)\": \"m(4)\",\n    \"m(add4)\": \"m(4)\",\n    \"m(9)\": \"m(9)\",\n    \"m(add9)\": \"m(9)\",\n    \"m(ma7)\": \"m(ma7)\",\n    \"m(M7)\": \"m(ma7)\",\n    \"mi(maj7)\": \"m(ma7)\",\n    \"min(maj7)\": \"m(ma7)\",\n    \"m(maj7)\": \"m(ma7)\",\n    \"m(+7)\": \"m(ma7)\",\n    \"m+7\": \"m(ma7)\",\n    \"m(ma9)\": \"m(ma9)\",\n    \"m(M9)\": \"m(ma9)\",\n    \"mi(maj9)\": \"m(ma9)\",\n    \"min(maj9)\": \"m(ma9)\",\n    \"m(maj9)\": \"m(ma9)\",\n    \"m(+9)\": \"m(ma9)\",\n    \"m+9\": \"m(ma9)\",\n    \"m(no5)\": \"m(no5)\",\n    \"m11\": \"m11\",\n    \"mi11\": \"m11\",\n    \"min11\": \"m11\",\n    \"-11\": \"m11\",\n    \"m11(#5)\": \"m11(#5)\",\n    \"m11#5\": \"m11(#5)\",\n    \"m11+5\": \"m11(#5)\",\n    \"m11(+5)\": \"m11(#5)\",\n    \"-11(#5)\": \"m11(#5)\",\n    \"-11#5\": \"m11(#5)\",\n    \"m9+5\": \"m9(#5)\",\n    \"-11(+5)\": \"m11(#5)\",\n    \"m11(#9)\": \"m11(#9)\",\n    \"m11#9\": \"m11(#9)\",\n    \"m11+9\": \"m11(#9)\",\n    \"m11(+9)\": \"m11(#9)\",\n    \"-11(#9)\": \"m11(#9)\",\n    \"-11#9\": \"m11(#9)\",\n    \"-11+9\": \"m11(#9)\",\n    \"-11(+9)\": \"m11(#9)\",\n    \"m11(#9#5)\": \"m11(#9#5)\",\n    \"m11(#5#9)\": \"m11(#9#5)\",\n    \"m11#5#9\": \"m11(#9#5)\",\n    \"m11+5+9\": \"m11(#9#5)\",\n    \"m11(+5+9)\": \"m11(#9#5)\",\n    \"-11(#5#9)\": \"m11(#9#5)\",\n    \"-11#5#9\": \"m11(#9#5)\",\n    \"m9+5+9\": \"m11(#9#5)\",\n    \"-11(+5+9)\": \"m11(#9#5)\",\n    \"m11(#9b13)\": \"m11(#9b13)\",\n    \"m11#9b13\": \"m11(#9b13)\",\n    \"m11+9-13\": \"m11(#9b13)\",\n    \"m11(+9-13)\": \"m11(#9b13)\",\n    \"-11(#9b13)\": \"m11(#9b13)\",\n    \"-11#9b13\": \"m11(#9b13)\",\n    \"-11+9-13\": \"m11(#9b13)\",\n    \"-11(+9-13)\": \"m11(#9b13)\",\n    \"m11(b13)\": \"m11(b13)\",\n    \"m11b13\": \"m11(b13)\",\n    \"m11-13\": \"m11(b13)\",\n    \"m11(-13)\": \"m11(b13)\",\n    \"-11(b13)\": \"m11(b13)\",\n    \"-11b13\": \"m11(b13)\",\n    \"-11-13\": \"m11(b13)\",\n    \"-11(-13)\": \"m11(b13)\",\n    \"m11(b13#5)\": \"m11(b13#5)\",\n    \"m11(#5b13)\": \"m11(b13#5)\",\n    \"m11#5b13\": \"m11(b13#5)\",\n    \"m11+5-13\": \"m11(b13#5)\",\n    \"m11(+5-13)\": \"m11(b13#5)\",\n    \"-11(#5b13)\": \"m11(b13#5)\",\n    \"-11#5b13\": \"m11(b13#5)\",\n    \"-11+5-13\": \"m11(b13#5)\",\n    \"-11(+5-13)\": \"m11(b13#5)\",\n    \"m11(b5)\": \"m11(b5)\",\n    \"m11b5\": \"m11(b5)\",\n    \"m11-5\": \"m11(b5)\",\n    \"m11(-5)\": \"m11(b5)\",\n    \"-11(b5)\": \"m11(b5)\",\n    \"-11b5\": \"m11(b5)\",\n    \"-9-5\": \"m9(b5)\",\n    \"-11(-5)\": \"m11(b5)\",\n    \"m11(b5#9)\": \"m11(b5#9)\",\n    \"m11b5#9\": \"m11(b5#9)\",\n    \"m11-5+9\": \"m11(b5#9)\",\n    \"m11(-5+9)\": \"m11(b5#9)\",\n    \"-11(b5#9)\": \"m11(b5#9)\",\n    \"-11b5#9\": \"m11(b5#9)\",\n    \"-11-5+9\": \"m11(b5#9)\",\n    \"-11(-5+9)\": \"m11(b5#9)\",\n    \"m11(b5b13)\": \"m11(b5b13)\",\n    \"m11b5b13\": \"m11(b5b13)\",\n    \"m11(-5-13)\": \"m11(b5b13)\",\n    \"m11-5-13\": \"m11(b5b13)\",\n    \"-11(b5b13)\": \"m11(b5b13)\",\n    \"-11b5b13\": \"m11(b5b13)\",\n    \"-11(-5-13)\": \"m11(b5b13)\",\n    \"-11-5-13\": \"m11(b5b13)\",\n    \"m11(b5b9)\": \"m11(b5b9)\",\n    \"m11b5b9\": \"m11(b5b9)\",\n    \"m11-5-9\": \"m11(b5b9)\",\n    \"m11(-5-9)\": \"m11(b5b9)\",\n    \"-11(b5b9)\": \"m11(b5b9)\",\n    \"-11b5b9\": \"m11(b5b9)\",\n    \"-11-5-9\": \"m11(b5b9)\",\n    \"-11(-5-9)\": \"m11(b5b9)\",\n    \"m11(b9)\": \"m11(b9)\",\n    \"m11b9\": \"m11(b9)\",\n    \"m11(-9)\": \"m11(b9)\",\n    \"m11-9\": \"m11(b9)\",\n    \"-11(b9)\": \"m11(b9)\",\n    \"-11b9\": \"m11(b9)\",\n    \"-11(-9)\": \"m11(b9)\",\n    \"-11-9\": \"m11(b9)\",\n    \"m11(b9#5)\": \"m11(b9#5)\",\n    \"m11(#5b9)\": \"m11(b9#5)\",\n    \"m11#5b9\": \"m11(b9#5)\",\n    \"m11+5-9\": \"m11(b9#5)\",\n    \"m11(+5-9)\": \"m11(b9#5)\",\n    \"-11(#5b9)\": \"m11(b9#5)\",\n    \"-11#5b9\": \"m11(b9#5)\",\n    \"m9+5-9\": \"m11(b9#5)\",\n    \"-11(+5-9)\": \"m11(b9#5)\",\n    \"m11(b9b13)\": \"m11(b9b13)\",\n    \"m11b9b13\": \"m11(b9b13)\",\n    \"m11(-9-13)\": \"m11(b9b13)\",\n    \"m11-9-13\": \"m11(b9b13)\",\n    \"-11(b9b13)\": \"m11(b9b13)\",\n    \"-11b9b13\": \"m11(b9b13)\",\n    \"-11(-9-13)\": \"m11(b9b13)\",\n    \"-11-9-13\": \"m11(b9b13)\",\n    \"m13\": \"m13\",\n    \"mi13\": \"m13\",\n    \"min13\": \"m13\",\n    \"-13\": \"m13\",\n    \"m13(#11)\": \"m13(#11)\",\n    \"m13#11\": \"m13(#11)\",\n    \"m13+11\": \"m13(#11)\",\n    \"m13(+11)\": \"m13(#11)\",\n    \"-13(#11)\": \"m13(#11)\",\n    \"-13#11\": \"m13(#11)\",\n    \"-13+11\": \"m13(#11)\",\n    \"-13(+11)\": \"m13(#11)\",\n    \"m13(#5)\": \"m13(#5)\",\n    \"m13#5\": \"m13(#5)\",\n    \"m13+5\": \"m13(#5)\",\n    \"m13(+5)\": \"m13(#5)\",\n    \"-13(#5)\": \"m13(#5)\",\n    \"-13#5\": \"m13(#5)\",\n    \"-13(+5)\": \"m13(#5)\",\n    \"m13(#9)\": \"m13(#9)\",\n    \"m13#9\": \"m13(#9)\",\n    \"m13(+9)\": \"m13(#9)\",\n    \"m13+9\": \"m13(#9)\",\n    \"-13(#9)\": \"m13(#9)\",\n    \"-13#9\": \"m13(#9)\",\n    \"-13(+9)\": \"m13(#9)\",\n    \"-13+9\": \"m13(#9)\",\n    \"m13(b5)\": \"m13(b5)\",\n    \"m13b5\": \"m13(b5)\",\n    \"m13-5\": \"m13(b5)\",\n    \"m13(-5)\": \"m13(b5)\",\n    \"-13(b5)\": \"m13(b5)\",\n    \"-13b5\": \"m13(b5)\",\n    \"-13-5\": \"m13(b5)\",\n    \"-13(-5)\": \"m13(b5)\",\n    \"m13(b9)\": \"m13(b9)\",\n    \"m13b9\": \"m13(b9)\",\n    \"m13-9\": \"m13(b9)\",\n    \"m13(-9)\": \"m13(b9)\",\n    \"-13(b13)\": \"m13(b9)\",\n    \"-13b13\": \"m13(b9)\",\n    \"-13-13\": \"m13(b9)\",\n    \"-13(-13)\": \"m13(b9)\",\n    \"m2\": \"m2\",\n    \"mi2\": \"m2\",\n    \"min2\": \"m2\",\n    \"m(add2)\": \"m2\",\n    \"madd2\": \"m2\",\n    \"m4\": \"m4\",\n    \"m6\": \"m6\",\n    \"mi6\": \"m6\",\n    \"min6\": \"m6\",\n    \"-6\": \"m6\",\n    \"m6(#5)\": \"m6(#5)\",\n    \"m6(9)\": \"m6(9)\",\n    \"m6add9\": \"m6(9)\",\n    \"m6(add9)\": \"m6(9)\",\n    \"m69\": \"m6(9)\",\n    \"m6(ma7)\": \"m6(ma7)\",\n    \"m6(M7)\": \"m6(ma7)\",\n    \"m6(+7)\": \"m6(ma7)\",\n    \"m6M7\": \"m6(ma7)\",\n    \"m6+7\": \"m6(ma7)\",\n    \"m7\": \"m7\",\n    \"mi7\": \"m7\",\n    \"min7\": \"m7\",\n    \"-7\": \"m7\",\n    \"m7(#11)\": \"m7(#11)\",\n    \"m7#11\": \"m7(#11)\",\n    \"m7+11\": \"m7(#11)\",\n    \"m7(+11)\": \"m7(#11)\",\n    \"-7(#11)\": \"m7(#11)\",\n    \"-7#11\": \"m7(#11)\",\n    \"-7+11\": \"m7(#11)\",\n    \"-7(+11)\": \"m7(#11)\",\n    \"m7(#5)\": \"m7(#5)\",\n    \"m7#5\": \"m7(#5)\",\n    \"m7+5\": \"m7(#5)\",\n    \"m7(+5)\": \"m7(#5)\",\n    \"-7(#5)\": \"m7(#5)\",\n    \"-7#5\": \"m7(#5)\",\n    \"-7(+5)\": \"m7(#5)\",\n    \"m7(#9)\": \"m7(#9)\",\n    \"m7#9\": \"m7(#9)\",\n    \"m7+9\": \"m7(#9)\",\n    \"m7(+9)\": \"m7(#9)\",\n    \"-7(#9)\": \"m7(#9)\",\n    \"-7#9\": \"m7(#9)\",\n    \"-7(+9)\": \"m7(#9)\",\n    \"m7(11)\": \"m7(11)\",\n    \"m7(4)\": \"m7(4)\",\n    \"m7(add4)\": \"m7(4)\",\n    \"m7(add11)\": \"m7(4)\",\n    \"m74\": \"m7(4)\",\n    \"m7(6)\": \"m7(6)\",\n    \"m7(add6)\": \"m7(add6)\",\n    \"m7(b13)\": \"m7(b13)\",\n    \"m7b13\": \"m7(b13)\",\n    \"m7-13\": \"m7(b13)\",\n    \"m7(-13)\": \"m7(b13)\",\n    \"-7(b13)\": \"m7(b13)\",\n    \"-7b13\": \"m7(b13)\",\n    \"-7-13\": \"m7(b13)\",\n    \"-7(-13)\": \"m7(b13)\",\n    \"m7(b5)\": \"m7(b5)\",\n    \"m7b5\": \"m7(b5)\",\n    \"m7-5\": \"m7(b5)\",\n    \"m7(-5)\": \"m7(b5)\",\n    \"-7(b5)\": \"m7(b5)\",\n    \"-7b5\": \"m7(b5)\",\n    \"-7(-5)\": \"m7(b5)\",\n    \"m7(b9)\": \"m7(b9)\",\n    \"m7b9\": \"m7(b9)\",\n    \"m7-9\": \"m7(b9)\",\n    \"m7(-9)\": \"m7(b9)\",\n    \"-7(b9)\": \"m7(b9)\",\n    \"-7b9\": \"m7(b9)\",\n    \"-7(-9)\": \"m7(b9)\",\n    \"m7(no3)\": \"m7(no3)\",\n    \"min7(no3)\": \"m7(no3)\",\n    \"m7sus4\": \"m7sus4\",\n    \"m7sus\": \"m7sus4\",\n    \"m9\": \"m9\",\n    \"mi9\": \"m9\",\n    \"min9\": \"m9\",\n    \"-9\": \"m9\",\n    \"m9(#11)\": \"m9(#11)\",\n    \"m9#11\": \"m9(#11)\",\n    \"m9+11\": \"m9(#11)\",\n    \"m9(+11)\": \"m9(#11)\",\n    \"-9(#11)\": \"m9(#11)\",\n    \"-9#11\": \"m9(#11)\",\n    \"-9+11\": \"m9(#11)\",\n    \"-9(+11)\": \"m9(#11)\",\n    \"m9(#5)\": \"m9(#5)\",\n    \"m9#5\": \"m9(#5)\",\n    \"m9(+5)\": \"m9(#5)\",\n    \"-9(#5)\": \"m9(#5)\",\n    \"-9#5\": \"m9(#5)\",\n    \"-9(+5)\": \"m9(#5)\",\n    \"m9(#7)\": \"m9(#7)\",\n    \"m9(b13)\": \"m9(b13)\",\n    \"m9b13\": \"m9(b13)\",\n    \"m9-13\": \"m9(b13)\",\n    \"m9(-13)\": \"m9(b13)\",\n    \"-9(b13)\": \"m9(b13)\",\n    \"-9b13\": \"m9(b13)\",\n    \"-9-13\": \"m9(b13)\",\n    \"-9(-13)\": \"m9(b13)\",\n    \"m9(b5)\": \"m9(b5)\",\n    \"m9b5\": \"m9(b5)\",\n    \"m9-5\": \"m9(b5)\",\n    \"m9(-5)\": \"m9(b5)\",\n    \"-9(b5)\": \"m9(b5)\",\n    \"-9b5\": \"m9(b5)\",\n    \"-9(-5)\": \"m9(b5)\",\n    \"m9(ma7)\": \"m9(ma7)\",\n    \"m9(maj7)\": \"m9(ma7)\",\n    \"m9(+7)\": \"m9(ma7)\",\n    \"m9(M7)\": \"m9(ma7)\",\n    \"m9M7\": \"m9(ma7)\",\n    \"ma9\": \"ma9\",\n    \"maj9\": \"ma9\",\n    \"ma11\": \"ma11\",\n    \"11(#7)\": \"ma11\",\n    \"11#7\": \"ma11\",\n    \"11+7\": \"ma11\",\n    \"11(+7)\": \"ma11\",\n    \"+11\": \"ma11\",\n    \"M11\": \"ma11\",\n    \"ma11(#5)\": \"ma11(#5)\",\n    \"maj11#5\": \"ma11(#5)\",\n    \"maj11+5\": \"ma11(#5)\",\n    \"maj11(+5)\": \"ma11(#5)\",\n    \"+11(#5)\": \"ma11(#5)\",\n    \"+11#5\": \"ma11(#5)\",\n    \"M11+5\": \"ma11(#5)\",\n    \"+11(+5)\": \"ma11(#5)\",\n    \"maj11(#5)\": \"ma11(#5)\",\n    \"ma11#5\": \"ma11(#5)\",\n    \"ma11+5\": \"ma11(#5)\",\n    \"ma11(+5)\": \"ma11(#5)\",\n    \"ma11(#9)\": \"ma11(#9)\",\n    \"maj11#9\": \"ma11(#9)\",\n    \"maj11+9\": \"ma11(#9)\",\n    \"maj11(+9)\": \"ma11(#9)\",\n    \"+11(#9)\": \"ma11(#9)\",\n    \"+11#9\": \"ma11(#9)\",\n    \"M11+9\": \"ma11(#9)\",\n    \"+11(+9)\": \"ma11(#9)\",\n    \"maj11(#9)\": \"ma11(#9)\",\n    \"ma11#9\": \"ma11(#9)\",\n    \"ma11+9\": \"ma11(#9)\",\n    \"ma11(+9)\": \"ma11(#9)\",\n    \"ma11(b13)\": \"ma11(b13)\",\n    \"maj11b13\": \"ma11(b13)\",\n    \"maj11-13\": \"ma11(b13)\",\n    \"maj11(-13)\": \"ma11(b13)\",\n    \"+11(b13)\": \"ma11(b13)\",\n    \"+11b13\": \"ma11(b13)\",\n    \"M11-13\": \"ma11(b13)\",\n    \"+11(-13)\": \"ma11(b13)\",\n    \"maj11(b13)\": \"ma11(b13)\",\n    \"ma11b13\": \"ma11(b13)\",\n    \"ma11-13\": \"ma11(b13)\",\n    \"ma11(-13)\": \"ma11(b13)\",\n    \"ma11(b5)\": \"ma11(b5)\",\n    \"maj11b5\": \"ma11(b5)\",\n    \"maj11-5\": \"ma11(b5)\",\n    \"maj11(-5)\": \"ma11(b5)\",\n    \"+11(b5)\": \"ma11(b5)\",\n    \"+11b5\": \"ma11(b5)\",\n    \"M11-5\": \"ma11(b5)\",\n    \"+11(-5)\": \"ma11(b5)\",\n    \"maj11(b5)\": \"ma11(b5)\",\n    \"ma11b5\": \"ma11(b5)\",\n    \"ma11-5\": \"ma11(b5)\",\n    \"ma11(-5)\": \"ma11(b5)\",\n    \"ma11(b9)\": \"ma11(b9)\",\n    \"maj11b9\": \"ma11(b9)\",\n    \"maj11(-9)\": \"ma11(b9)\",\n    \"maj11-9\": \"ma11(b9)\",\n    \"+11(b9)\": \"ma11(b9)\",\n    \"+11b9\": \"ma11(b9)\",\n    \"M11(-9)\": \"ma11(b9)\",\n    \"+11-9\": \"ma11(b9)\",\n    \"maj11(b9)\": \"ma11(b9)\",\n    \"ma11b9\": \"ma11(b9)\",\n    \"ma11(-9)\": \"ma11(b9)\",\n    \"ma11-9\": \"ma11(b9)\",\n    \"ma13\": \"ma13\",\n    \"13(#7)\": \"ma13\",\n    \"+13\": \"ma13\",\n    \"M13\": \"ma13\",\n    \"ma13(#11)\": \"ma13(#11)\",\n    \"maj13#11\": \"ma13(#11)\",\n    \"maj13+11\": \"ma13(#11)\",\n    \"maj13(+11)\": \"ma13(#11)\",\n    \"+13(#11)\": \"ma13(#11)\",\n    \"+13#11\": \"ma13(#11)\",\n    \"M13+11\": \"ma13(#11)\",\n    \"+13(+11)\": \"ma13(#11)\",\n    \"maj13(#11)\": \"ma13(#11)\",\n    \"ma7#11\": \"ma9(#11)\",\n    \"ma13+11\": \"ma13(#11)\",\n    \"ma13(+11)\": \"ma13(#11)\",\n    \"ma13(#11#5)\": \"ma13(#11#5)\",\n    \"maj13#11#5\": \"ma13(#11#5)\",\n    \"maj13+11+5\": \"ma13(#11#5)\",\n    \"maj13(+11+5)\": \"ma13(#11#5)\",\n    \"+13(#11#5)\": \"ma13(#11#5)\",\n    \"+13#11#5\": \"ma13(#11#5)\",\n    \"M13+11+5\": \"ma13(#11#5)\",\n    \"+13(+11+5)\": \"ma13(#11#5)\",\n    \"maj13(#11#5)\": \"ma13(#11#5)\",\n    \"ma7#11#5\": \"ma9(#11#5)\",\n    \"ma13+11+5\": \"ma13(#11#5)\",\n    \"ma13(+11+5)\": \"ma13(#11#5)\",\n    \"ma13(#5)\": \"ma13(#5)\",\n    \"maj13#5\": \"ma13(#5)\",\n    \"maj13+5\": \"ma13(#5)\",\n    \"maj13(+5)\": \"ma13(#5)\",\n    \"+13(#5)\": \"ma13(#5)\",\n    \"+13#5\": \"ma13(#5)\",\n    \"M13+5\": \"ma13(#5)\",\n    \"+13(+5)\": \"ma13(#5)\",\n    \"maj13(#5)\": \"ma13(#5)\",\n    \"ma13#5\": \"ma13(#5)\",\n    \"ma13+5\": \"ma13(#5)\",\n    \"ma13(+5)\": \"ma13(#5)\",\n    \"ma13(#9)\": \"ma13(#9)\",\n    \"maj13#9\": \"ma13(#9)\",\n    \"maj13(+9)\": \"ma13(#9)\",\n    \"maj13+9\": \"ma13(#9)\",\n    \"+13(#9)\": \"ma13(#9)\",\n    \"+13#9\": \"ma13(#9)\",\n    \"M13(+9)\": \"ma13(#9)\",\n    \"+13+9\": \"ma13(#9)\",\n    \"maj13(#9)\": \"ma13(#9)\",\n    \"ma13#9\": \"ma13(#9)\",\n    \"ma13(+9)\": \"ma13(#9)\",\n    \"ma13+9\": \"ma13(#9)\",\n    \"ma13(#9#5)\": \"ma13(#9#5)\",\n    \"maj13#9#5\": \"ma13(#9#5)\",\n    \"maj13(+9+5)\": \"ma13(#9#5)\",\n    \"maj13+9+5\": \"ma13(#9#5)\",\n    \"+13(#9#5)\": \"ma13(#9#5)\",\n    \"+13#9#5\": \"ma13(#9#5)\",\n    \"M13(+9+5)\": \"ma13(#9#5)\",\n    \"+13+9+5\": \"ma13(#9#5)\",\n    \"maj13(#9#5)\": \"ma13(#9#5)\",\n    \"ma7#9#5\": \"ma13(#9#5)\",\n    \"ma13(+9+5)\": \"ma13(#9#5)\",\n    \"ma13+9+5\": \"ma13(#9#5)\",\n    \"ma13(b5)\": \"ma13(b5)\",\n    \"maj13b5\": \"ma13(b5)\",\n    \"maj13-5\": \"ma13(b5)\",\n    \"maj13(-5)\": \"ma13(b5)\",\n    \"+13(b5)\": \"ma13(b5)\",\n    \"+13b5\": \"ma13(b5)\",\n    \"M13-5\": \"ma13(b5)\",\n    \"+13(-5)\": \"ma13(b5)\",\n    \"maj13(b5)\": \"ma13(b5)\",\n    \"ma13b5\": \"ma13(b5)\",\n    \"ma13-5\": \"ma13(b5)\",\n    \"ma13(-5)\": \"ma13(b5)\",\n    \"ma13(b9)\": \"ma13(b9)\",\n    \"maj13b9\": \"ma13(b9)\",\n    \"maj13-9\": \"ma13(b9)\",\n    \"maj13(-9)\": \"ma13(b9)\",\n    \"+13(b9)\": \"ma13(b9)\",\n    \"+13b9\": \"ma13(b9)\",\n    \"M13-9\": \"ma13(b9)\",\n    \"+13(-9)\": \"ma13(b9)\",\n    \"maj13(b9)\": \"ma13(b9)\",\n    \"ma13b9\": \"ma13(b9)\",\n    \"ma13-9\": \"ma13(b9)\",\n    \"ma13(-9)\": \"ma13(b9)\",\n    \"ma13(b9#5)\": \"ma13(b9#5)\",\n    \"maj13b9#5\": \"ma13(b9#5)\",\n    \"maj13-9+5\": \"ma13(b9#5)\",\n    \"maj13(-9+5)\": \"ma13(b9#5)\",\n    \"+13(b9#5)\": \"ma13(b9#5)\",\n    \"+13b9#5\": \"ma13(b9#5)\",\n    \"M13-9+5\": \"ma13(b9#5)\",\n    \"+13(-9+5)\": \"ma13(b9#5)\",\n    \"maj13(b9#5)\": \"ma13(b9#5)\",\n    \"ma7b9#5\": \"ma13(b9#5)\",\n    \"ma13-9+5\": \"ma13(b9#5)\",\n    \"ma13(-9+5)\": \"ma13(b9#5)\",\n    \"ma6\": \"ma6\",\n    \"ma6(9)\": \"ma6(9)\",\n    \"ma69\": \"ma6(9)\",\n    \"ma7\": \"ma7\",\n    \"+7\": \"ma7\",\n    \"#7\": \"ma7\",\n    \"M7\": \"ma7\",\n    \"Maj7\": \"ma7\",\n    \"maj7\": \"ma7\",\n    \"(triangle)\": \"ma7\",\n    \"ma7(#11)\": \"ma7(#11)\",\n    \"maj7#11\": \"ma7(#11)\",\n    \"maj7+11\": \"ma7(#11)\",\n    \"maj7(+11)\": \"ma7(#11)\",\n    \"+7(#11)\": \"ma7(#11)\",\n    \"+7#11\": \"ma7(#11)\",\n    \"M7+11\": \"ma7(#11)\",\n    \"+7(+11)\": \"ma7(#11)\",\n    \"maj7(#11)\": \"ma7(#11)\",\n    \"ma7+11\": \"ma7(#11)\",\n    \"ma7(+11)\": \"ma7(#11)\",\n    \"ma7(#4)\": \"ma7(#4)\",\n    \"ma7(#5)\": \"ma7(#5)\",\n    \"maj7#5\": \"ma7(#5)\",\n    \"maj7+5\": \"ma7(#5)\",\n    \"maj7(+5)\": \"ma7(#5)\",\n    \"+7(#5)\": \"ma7(#5)\",\n    \"+7#5\": \"ma7(#5)\",\n    \"M7+5\": \"ma7(#5)\",\n    \"+7(+5)\": \"ma7(#5)\",\n    \"maj7(#5)\": \"ma7(#5)\",\n    \"ma7#5\": \"ma7(#5)\",\n    \"ma7+5\": \"ma7(#5)\",\n    \"ma7(+5)\": \"ma7(#5)\",\n    \"aug(M7)\": \"ma7(#5)\",\n    \"aug(+7)\": \"ma7(#5)\",\n    \"aug(ma7)\": \"ma7(#5)\",\n    \"aug(maj7)\": \"ma7(#5)\",\n    \"ma7(#9)\": \"ma7(#9)\",\n    \"maj7#9\": \"ma7(#9)\",\n    \"maj7+9\": \"ma7(#9)\",\n    \"maj7(+9)\": \"ma7(#9)\",\n    \"+7(#9)\": \"ma7(#9)\",\n    \"+7#9\": \"ma7(#9)\",\n    \"M7+9\": \"ma7(#9)\",\n    \"+7(+9)\": \"ma7(#9)\",\n    \"maj7(#9)\": \"ma7(#9)\",\n    \"ma7#9\": \"ma7(#9)\",\n    \"ma7+9\": \"ma7(#9)\",\n    \"ma7(+9)\": \"ma7(#9)\",\n    \"ma7(b13)\": \"ma7(b13)\",\n    \"maj7b13\": \"ma7(b13)\",\n    \"maj7-13\": \"ma7(b13)\",\n    \"maj7(-13)\": \"ma7(b13)\",\n    \"+7(b13)\": \"ma7(b13)\",\n    \"+7b13\": \"ma7(b13)\",\n    \"M7-13\": \"ma7(b13)\",\n    \"+7(-13)\": \"ma7(b13)\",\n    \"maj7(b13)\": \"ma7(b13)\",\n    \"ma7b13\": \"ma9(b13)\",\n    \"ma7-13\": \"ma7(b13)\",\n    \"ma7(-13)\": \"ma7(b13)\",\n    \"ma7(b5)\": \"ma7(b5)\",\n    \"maj7b5\": \"ma7(b5)\",\n    \"maj7-5\": \"ma7(b5)\",\n    \"maj7(-5)\": \"ma7(b5)\",\n    \"+7(b5)\": \"ma7(b5)\",\n    \"+7b5\": \"ma7(b5)\",\n    \"M7-5\": \"ma7(b5)\",\n    \"+7(-5)\": \"ma7(b5)\",\n    \"maj7(b5)\": \"ma7(b5)\",\n    \"ma7b5\": \"ma7(b5)\",\n    \"ma7-5\": \"ma7(b5)\",\n    \"ma7(-5)\": \"ma7(b5)\",\n    \"ma7(b9)\": \"ma7(b9)\",\n    \"maj7b9\": \"ma7(b9)\",\n    \"maj7-9\": \"ma7(b9)\",\n    \"maj7(-9)\": \"ma7(b9)\",\n    \"+7(b9)\": \"ma7(b9)\",\n    \"+7b9\": \"ma7(b9)\",\n    \"M7-9\": \"ma7(b9)\",\n    \"+7(-9)\": \"ma7(b9)\",\n    \"maj7(b9)\": \"ma7(b9)\",\n    \"ma7b9\": \"ma7(b9)\",\n    \"ma7-9\": \"ma7(b9)\",\n    \"ma7(-9)\": \"ma7(b9)\",\n    \"ma7(no3)\": \"ma7(no3)\",\n    \"9(#7)\": \"ma9\",\n    \"+9\": \"ma9\",\n    \"M9\": \"ma9\",\n    \"ma9(#11)\": \"ma9(#11)\",\n    \"maj9#11\": \"ma9(#11)\",\n    \"maj9+11\": \"ma9(#11)\",\n    \"maj9(+11)\": \"ma9(#11)\",\n    \"+9(#11)\": \"ma9(#11)\",\n    \"+9#11\": \"ma9(#11)\",\n    \"M9+11\": \"ma9(#11)\",\n    \"+9(+11)\": \"ma9(#11)\",\n    \"maj9(#11)\": \"ma9(#11)\",\n    \"ma9+11\": \"ma9(#11)\",\n    \"ma9(+11)\": \"ma9(#11)\",\n    \"ma9(#11#5)\": \"ma9(#11#5)\",\n    \"maj9#11#5\": \"ma9(#11#5)\",\n    \"maj9+11+5\": \"ma9(#11#5)\",\n    \"maj9(+11+5)\": \"ma9(#11#5)\",\n    \"+9(#11#5)\": \"ma9(#11#5)\",\n    \"+9#11#5\": \"ma9(#11#5)\",\n    \"M9+11+5\": \"ma9(#11#5)\",\n    \"+9(+11+5)\": \"ma9(#11#5)\",\n    \"maj9(#11#5)\": \"ma9(#11#5)\",\n    \"ma9+11+5\": \"ma9(#11#5)\",\n    \"ma9(+11+5)\": \"ma9(#11#5)\",\n    \"ma9(#4)\": \"ma9(#4)\",\n    \"ma9(#5)\": \"ma9(#5)\",\n    \"maj9#5\": \"ma9(#5)\",\n    \"maj9+5\": \"ma9(#5)\",\n    \"maj9(+5)\": \"ma9(#5)\",\n    \"+9(#5)\": \"ma9(#5)\",\n    \"+9#5\": \"ma9(#5)\",\n    \"M9+5\": \"ma9(#5)\",\n    \"+9(+5)\": \"ma9(#5)\",\n    \"maj9(#5)\": \"ma9(#5)\",\n    \"ma9#5\": \"ma9(#5)\",\n    \"ma9+5\": \"ma9(#5)\",\n    \"ma9(+5)\": \"ma9(#5)\",\n    \"ma9(13)\": \"ma9(13)\",\n    \"ma9(b13)\": \"ma9(b13)\",\n    \"maj9b13\": \"ma9(b13)\",\n    \"maj9-13\": \"ma9(b13)\",\n    \"maj9(-13)\": \"ma9(b13)\",\n    \"+9(b13)\": \"ma9(b13)\",\n    \"+9b13\": \"ma9(b13)\",\n    \"M9-13\": \"ma9(b13)\",\n    \"+9(-13)\": \"ma9(b13)\",\n    \"maj9(b13)\": \"ma9(b13)\",\n    \"ma9-13\": \"ma9(b13)\",\n    \"ma9(-13)\": \"ma9(b13)\",\n    \"ma9(b13#5)\": \"ma9(b13#5)\",\n    \"maj9b13#5\": \"ma9(b13#5)\",\n    \"maj9-13+5\": \"ma9(b13#5)\",\n    \"maj9(-13+5)\": \"ma9(b13#5)\",\n    \"+9(b13#5)\": \"ma9(b13#5)\",\n    \"+9b13#5\": \"ma9(b13#5)\",\n    \"M9-13+5\": \"ma9(b13#5)\",\n    \"+9(-13+5)\": \"ma9(b13#5)\",\n    \"maj9(b13#5)\": \"ma9(b13#5)\",\n    \"ma7b13#5\": \"ma9(b13#5)\",\n    \"ma9-13+5\": \"ma9(b13#5)\",\n    \"ma9(-13+5)\": \"ma9(b13#5)\",\n    \"ma9(b5)\": \"ma9(b5)\",\n    \"maj9b5\": \"ma9(b5)\",\n    \"maj9-5\": \"ma9(b5)\",\n    \"maj9(-5)\": \"ma9(b5)\",\n    \"+9(b5)\": \"ma9(b5)\",\n    \"+9b5\": \"ma9(b5)\",\n    \"M9-5\": \"ma9(b5)\",\n    \"+9(-5)\": \"ma9(b5)\",\n    \"maj9(b5)\": \"ma9(b5)\",\n    \"ma9b5\": \"ma9(b5)\",\n    \"ma9-5\": \"ma9(b5)\",\n    \"ma9(-5)\": \"ma9(b5)\",\n    \"sus\": \"sus\",\n    \"sus4\": \"sus\",\n    \"sus(no5)\": \"sus(no5)\",\n    \"sus#42\": \"sus#42\"\n};\nvar $7ec1df4bbc0938c9$export$2e2bcd8739ae039 = $7ec1df4bbc0938c9$var$mapping;\n\n\n\n\nfunction $5e3a0c5a6197f95b$var$normalizeChordSuffix(suffix) {\n    if (suffix === null) return null;\n    if ((0, $7ec1df4bbc0938c9$export$2e2bcd8739ae039)[suffix] === \"[blank]\") return null;\n    return (0, $7ec1df4bbc0938c9$export$2e2bcd8739ae039)[suffix] || suffix;\n}\n/**\n * Represents a Chord, consisting of a root, suffix (quality) and bass\n */ class $5e3a0c5a6197f95b$var$Chord {\n    /**\n   * Tries to parse a chord string into a chord\n   * Any leading or trailing whitespace is removed first, so a chord like `  \\n  E/G# \\r ` is valid.\n   * @param chordString the chord string, eg `Esus4/G#` or `1sus4/#3`.\n   * @returns {Chord|null}\n   */ static parse(chordString) {\n        try {\n            return this.parseOrFail(chordString);\n        } catch (_error) {\n            return null;\n        }\n    }\n    static parseOrFail(chordString) {\n        const ast = (0, $7cb09a9be1aff7bc$export$98e6a39c04603d36)(chordString.trim());\n        return new $5e3a0c5a6197f95b$var$Chord(ast);\n    }\n    /**\n   * Returns a deep copy of the chord\n   * @returns {Chord}\n   */ clone() {\n        return this.set({});\n    }\n    /**\n   * Converts the chord to a chord symbol, using the supplied key as a reference.\n   * For example, a numeric chord `#4` with reference key `E` will return the chord symbol `A#`.\n   * When the chord is already a chord symbol, it will return a clone of the object.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a\n   * numeric or numeral.\n   * @returns {Chord} the chord symbol\n   */ toChordSymbol(referenceKey = null) {\n        if (this.isChordSymbol()) return this.clone();\n        const keyObj = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrapOrFail(referenceKey);\n        let chordSymbolChord = new $5e3a0c5a6197f95b$var$Chord({\n            suffix: this.suffix ? $5e3a0c5a6197f95b$var$normalizeChordSuffix(this.suffix) : null,\n            root: this.root.toChordSymbol(keyObj),\n            bass: this.bass?.toChordSymbol(keyObj) || null\n        });\n        if (this.root.isMinor()) chordSymbolChord = chordSymbolChord.makeMinor();\n        chordSymbolChord = chordSymbolChord.normalize(referenceKey);\n        return chordSymbolChord;\n    }\n    /**\n   * Converts the chord to a chord symbol string, using the supplied key as a reference.\n   * For example, a numeric chord `#4` with reference key `E` will return the chord symbol `A#`.\n   * When the chord is already a chord symbol, it will return a string version of the chord.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a\n   * numeric or numeral.\n   * @returns {string} the chord symbol string\n   * @see {toChordSymbol}\n   */ toChordSymbolString(referenceKey = null) {\n        return this.toChordSymbol(referenceKey).toString();\n    }\n    /**\n   * Determines whether the chord is a chord symbol\n   * @returns {boolean}\n   */ isChordSymbol() {\n        return this.is((0, $234747a9630b4642$export$27c95a7104c1f7aa));\n    }\n    /**\n   * Converts the chord to a numeric chord, using the supplied key as a reference.\n   * For example, a chord symbol A# with reference key E will return the numeric chord #4.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol\n   * @returns {Chord} the numeric chord\n   */ toNumeric(referenceKey = null) {\n        if (this.isNumeric()) return this.clone();\n        if (this.isNumeral()) return this.transform((key)=>key.toNumeric());\n        const keyObj = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrapOrFail(referenceKey);\n        return new $5e3a0c5a6197f95b$var$Chord({\n            suffix: $5e3a0c5a6197f95b$var$normalizeChordSuffix(this.suffix),\n            root: this.root.toNumeric(keyObj),\n            bass: this.bass?.toNumeric(keyObj) || null\n        });\n    }\n    /**\n   * Converts the chord to a numeral chord, using the supplied key as a reference.\n   * For example, a chord symbol A# with reference key E will return the numeral chord #IV.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol\n   * @returns {Chord} the numeral chord\n   */ toNumeral(referenceKey = null) {\n        if (this.isNumeral()) return this.clone();\n        if (this.isNumeric()) return this.transform((key)=>key.toNumeral());\n        const keyObj = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrapOrFail(referenceKey);\n        return new $5e3a0c5a6197f95b$var$Chord({\n            suffix: $5e3a0c5a6197f95b$var$normalizeChordSuffix(this.suffix),\n            root: keyObj ? this.root.toNumeral(keyObj) : null,\n            bass: this.bass?.toNumeral(keyObj) || null\n        });\n    }\n    /**\n   * Converts the chord to a numeral chord string, using the supplied kye as a reference.\n   * For example, a chord symbol A# with reference key E will return the numeral chord #4.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol\n   * @returns {string} the numeral chord string\n   * @see {toNumeral}\n   */ toNumeralString(referenceKey = null) {\n        return this.toNumeral(referenceKey).toString();\n    }\n    /**\n   * Determines whether the chord is numeric\n   * @returns {boolean}\n   */ isNumeric() {\n        return this.is((0, $234747a9630b4642$export$4d318981b5a83836));\n    }\n    /**\n   * Converts the chord to a numeric chord string, using the supplied kye as a reference.\n   * For example, a chord symbol A# with reference key E will return the numeric chord #4.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol\n   * @returns {string} the numeric chord string\n   * @see {toNumeric}\n   */ toNumericString(referenceKey = null) {\n        return this.toNumeric(referenceKey).toString();\n    }\n    /**\n   * Determines whether the chord is a numeral\n   * @returns {boolean}\n   */ isNumeral() {\n        return this.is((0, $234747a9630b4642$export$1321df9b16c30c6a));\n    }\n    /**\n   * Converts the chord to a string, eg `Esus4/G#` or `1sus4/#3`\n   * @returns {string} the chord string\n   */ toString() {\n        const chordString = this.root.toString({\n            showMinor: false\n        }) + (this.suffix || \"\");\n        if (this.bass) return `${chordString}/${this.bass.toString()}`;\n        return chordString;\n    }\n    /**\n   * Normalizes the chord root and bass notes:\n   * - Fb becomes E\n   * - Cb becomes B\n   * - B# becomes C\n   * - E# becomes F\n   * - 4b becomes 3\n   * - 1b becomes 7\n   * - 7# becomes 1\n   * - 3# becomes 4\n   *\n   * Besides that it normalizes the suffix if `normalizeSuffix` is `true`.\n   * For example, `sus2` becomes `2`, `sus4` becomes `sus`.\n   * All suffix normalizations can be found in `src/normalize_mappings/suffix-mapping.txt`.\n   *\n   * When the chord is minor, bass notes are normalized off of the relative major\n   * of the root note. For example, `Em/A#` becomes `Em/Bb`.\n   * @param {Key|string} [key=null] the key to normalize to\n   * @param {Object} [options={}] options\n   * @param {boolean} [options.normalizeSuffix=true] whether to normalize the chord suffix after transposing\n   * @returns {Chord} the normalized chord\n   */ normalize(key = null, { normalizeSuffix: normalizeSuffix = true  } = {}) {\n        const suffix = normalizeSuffix ? $5e3a0c5a6197f95b$var$normalizeChordSuffix(this.suffix) : this.suffix;\n        let bassRootKey = this.root.normalize().normalizeEnharmonics(key);\n        if (this.root.isMinor() && this.bass) bassRootKey = this.root.transpose(3).removeMinor().normalize();\n        return this.set({\n            suffix: suffix,\n            root: this.root.normalize().normalizeEnharmonics(key),\n            bass: this.bass ? this.bass.normalize().normalizeEnharmonics(bassRootKey) : null\n        });\n    }\n    /**\n   * Switches to the specified modifier\n   * @param newModifier the modifier to use: `'#'` or `'b'`\n   * @returns {Chord} the new, changed chord\n   */ useModifier(newModifier) {\n        return this.transform((key)=>key.useModifier(newModifier));\n    }\n    /**\n   * Transposes the chord up by 1 semitone. Eg. A becomes A#, Eb becomes E\n   * @returns {Chord} the new, transposed chord\n   */ transposeUp() {\n        return this.transform((key)=>key.transposeUp());\n    }\n    /**\n   * Transposes the chord down by 1 semitone. Eg. A# becomes A, E becomes Eb\n   * @returns {Chord} the new, transposed chord\n   */ transposeDown() {\n        return this.transform((key)=>key.transposeDown());\n    }\n    /**\n   * Transposes the chord by the specified number of semitones\n   * @param delta de number of semitones\n   * @returns {Chord} the new, transposed chord\n   */ transpose(delta) {\n        return this.transform((key)=>key.transpose(delta));\n    }\n    constructor({ base: base = null , modifier: modifier = null , suffix: suffix = null , bassBase: bassBase = null , bassModifier: bassModifier = null , root: root = null , bass: bass = null  }){\n        this.suffix = suffix || null;\n        this.root = this.determineRoot(root, base, modifier, suffix);\n        this.bass = this.determineBass(bass, bassBase, bassModifier);\n    }\n    determineRoot(root, base, modifier, suffix) {\n        if (root) return root;\n        if (!base) throw new Error(\"Expected base\");\n        return new (0, $918eb2016ac61e41$export$2e2bcd8739ae039)({\n            note: base,\n            modifier: modifier,\n            minor: (0, $974bd1d260bb1d53$export$51fabfbeed747719)(suffix)\n        });\n    }\n    determineBass(bass, bassBase, bassModifier) {\n        if (bass) return bass;\n        if (bassBase) return new (0, $918eb2016ac61e41$export$2e2bcd8739ae039)({\n            note: bassBase,\n            modifier: bassModifier || null,\n            minor: false\n        });\n        return null;\n    }\n    makeMinor() {\n        if (!this.suffix || this.suffix[0] !== \"m\") return this.set({\n            suffix: `m${this.suffix || \"\"}`\n        });\n        return this.clone();\n    }\n    set(properties) {\n        return new $5e3a0c5a6197f95b$var$Chord({\n            root: this.root.clone(),\n            suffix: this.suffix,\n            bass: this.bass?.clone() || null,\n            ...properties\n        });\n    }\n    is(type) {\n        return this.root.is(type) && (!this.bass || this.bass.is(type));\n    }\n    transform(transformFunc) {\n        return this.set({\n            root: transformFunc(this.root),\n            bass: this.bass ? transformFunc(this.bass) : null\n        });\n    }\n}\nfunction $5e3a0c5a6197f95b$export$621b8187b24d90c6(chordString) {\n    (0, $974bd1d260bb1d53$export$b680e6b2c82f8c2f)(\"parseChord() is deprecated, please use Chord.parse() instead\");\n    return $5e3a0c5a6197f95b$var$Chord.parse(chordString);\n}\nvar $5e3a0c5a6197f95b$export$2e2bcd8739ae039 = $5e3a0c5a6197f95b$var$Chord;\n\n\n/**\n * Represents a chord with the corresponding (partial) lyrics\n */ class $f7a904d05353aafa$var$ChordLyricsPair {\n    /**\n   * Initialises a ChordLyricsPair\n   * @param {string} chords The chords\n   * @param {string} lyrics The lyrics\n   */ constructor(chords = \"\", lyrics = null){\n        /**\n     * The chords\n     * @member\n     * @type {string}\n     */ this.chords = chords || \"\";\n        /**\n     * The lyrics\n     * @member\n     * @type {string}\n     */ this.lyrics = lyrics || \"\";\n    }\n    /**\n   * Indicates whether a ChordLyricsPair should be visible in a formatted chord sheet (except for ChordPro sheets)\n   * @returns {boolean}\n   */ isRenderable() {\n        return true;\n    }\n    /**\n   * Returns a deep copy of the ChordLyricsPair, useful when programmatically transforming a song\n   * @returns {ChordLyricsPair}\n   */ clone() {\n        return new $f7a904d05353aafa$var$ChordLyricsPair(this.chords, this.lyrics);\n    }\n    toString() {\n        return `ChordLyricsPair(chords=${this.chords}, lyrics=${this.lyrics})`;\n    }\n    set({ chords: chords , lyrics: lyrics  }) {\n        return new $f7a904d05353aafa$var$ChordLyricsPair(chords || this.chords, lyrics || this.lyrics);\n    }\n    setLyrics(lyrics) {\n        return this.set({\n            lyrics: lyrics\n        });\n    }\n    transpose(delta, key = null, { normalizeChordSuffix: normalizeChordSuffix  } = {\n        normalizeChordSuffix: false\n    }) {\n        const chordObj = (0, $5e3a0c5a6197f95b$export$2e2bcd8739ae039).parse(this.chords.trim());\n        if (chordObj) {\n            let transposedChord = chordObj.transpose(delta);\n            if (key) transposedChord = transposedChord.normalize(key, {\n                normalizeSuffix: normalizeChordSuffix\n            });\n            return this.set({\n                chords: transposedChord.toString()\n            });\n        }\n        return this.clone();\n    }\n}\nvar $f7a904d05353aafa$export$2e2bcd8739ae039 = $f7a904d05353aafa$var$ChordLyricsPair;\n\n\n/**\n * Album meta directive. See https://www.chordpro.org/chordpro/directives-album/\n * @type {string}\n */ \nconst $b3836272a1374d85$export$10227cb086d1770c = \"album\";\nconst $b3836272a1374d85$export$17d8dfb3db842bf = \"artist\";\nconst $b3836272a1374d85$export$866f445d49bad88e = \"capo\";\nconst $b3836272a1374d85$export$a29989082612d0d9 = \"comment\";\nconst $b3836272a1374d85$export$98424633dc8c377f = \"composer\";\nconst $b3836272a1374d85$export$4ab8c75045d12480 = \"copyright\";\nconst $b3836272a1374d85$export$bacc88974c736870 = \"duration\";\nconst $b3836272a1374d85$export$1c874e9780385ecd = \"end_of_bridge\";\nconst $b3836272a1374d85$export$473c1a4819e5180b = \"end_of_chorus\";\nconst $b3836272a1374d85$export$66a0ef3ffeab32b7 = \"end_of_tab\";\nconst $b3836272a1374d85$export$640d294ab83f9040 = \"end_of_verse\";\nconst $b3836272a1374d85$export$7167c830cefcb6b5 = \"key\";\nconst $b3836272a1374d85$export$430b1920f5feeae = \"_key\";\nconst $b3836272a1374d85$export$a6901bd008617c61 = \"lyricist\";\nconst $b3836272a1374d85$export$3550cc87694d54e0 = \"start_of_bridge\";\nconst $b3836272a1374d85$export$4f5168acae064e01 = \"start_of_chorus\";\nconst $b3836272a1374d85$export$8dd1111100e0e88d = \"start_of_tab\";\nconst $b3836272a1374d85$export$deca399f8cd9b7dc = \"start_of_verse\";\nconst $b3836272a1374d85$export$5895c693c74b9cf4 = \"subtitle\";\nconst $b3836272a1374d85$export$bd8d57d0bc5a8478 = \"tempo\";\nconst $b3836272a1374d85$export$a9905336c0111a3a = \"time\";\nconst $b3836272a1374d85$export$f1e53f710478ceb4 = \"title\";\nconst $b3836272a1374d85$export$ae60ab9b4739fc3d = \"transpose\";\nconst $b3836272a1374d85$export$b7627374a6424f68 = \"new_key\";\nconst $b3836272a1374d85$export$90b88dc425a06a95 = \"year\";\nconst $b3836272a1374d85$export$2b0cbe6e95114098 = \"chordfont\";\nconst $b3836272a1374d85$export$1f62a95bf5703cac = \"chordsize\";\nconst $b3836272a1374d85$export$f7227d9f34d97bec = \"chordcolour\";\nconst $b3836272a1374d85$export$14fe4ba6e94df04d = \"textfont\";\nconst $b3836272a1374d85$export$f0dee7f48597f09a = \"textsize\";\nconst $b3836272a1374d85$export$d2ed2b49c006eb23 = \"textcolour\";\nconst $b3836272a1374d85$export$7e71e3df83ac1c9b = \"titlefont\";\nconst $b3836272a1374d85$export$6adbad8fc3f3d0e2 = \"titlesize\";\nconst $b3836272a1374d85$export$964db987ba9b8470 = \"titlecolour\";\nconst $b3836272a1374d85$var$TITLE_SHORT = \"t\";\nconst $b3836272a1374d85$var$SUBTITLE_SHORT = \"st\";\nconst $b3836272a1374d85$var$COMMENT_SHORT = \"c\";\nconst $b3836272a1374d85$var$START_OF_CHORUS_SHORT = \"soc\";\nconst $b3836272a1374d85$var$END_OF_CHORUS_SHORT = \"eoc\";\nconst $b3836272a1374d85$var$START_OF_TAB_SHORT = \"sot\";\nconst $b3836272a1374d85$var$END_OF_TAB_SHORT = \"eot\";\nconst $b3836272a1374d85$var$NEW_KEY_SHORT = \"nk\";\nconst $b3836272a1374d85$var$CHORDFONT_SHORT = \"cf\";\nconst $b3836272a1374d85$var$CHORDSIZE_SHORT = \"cs\";\nconst $b3836272a1374d85$var$TEXTFONT_SHORT = \"tf\";\nconst $b3836272a1374d85$var$TEXTSIZE_SHORT = \"ts\";\nconst $b3836272a1374d85$var$RENDERABLE_TAGS = [\n    $b3836272a1374d85$export$a29989082612d0d9\n];\nconst $b3836272a1374d85$export$57ecf0dc09effb3 = [\n    $b3836272a1374d85$export$10227cb086d1770c,\n    $b3836272a1374d85$export$17d8dfb3db842bf,\n    $b3836272a1374d85$export$866f445d49bad88e,\n    $b3836272a1374d85$export$98424633dc8c377f,\n    $b3836272a1374d85$export$4ab8c75045d12480,\n    $b3836272a1374d85$export$bacc88974c736870,\n    $b3836272a1374d85$export$7167c830cefcb6b5,\n    $b3836272a1374d85$export$a6901bd008617c61,\n    $b3836272a1374d85$export$bd8d57d0bc5a8478,\n    $b3836272a1374d85$export$a9905336c0111a3a,\n    $b3836272a1374d85$export$f1e53f710478ceb4,\n    $b3836272a1374d85$export$5895c693c74b9cf4,\n    $b3836272a1374d85$export$90b88dc425a06a95\n];\nconst $b3836272a1374d85$export$75d737e15c3fab80 = [\n    $b3836272a1374d85$export$430b1920f5feeae\n];\nconst $b3836272a1374d85$var$SECTION_DELIMITERS = [\n    $b3836272a1374d85$export$4f5168acae064e01,\n    $b3836272a1374d85$export$473c1a4819e5180b,\n    $b3836272a1374d85$export$8dd1111100e0e88d,\n    $b3836272a1374d85$export$66a0ef3ffeab32b7,\n    $b3836272a1374d85$export$deca399f8cd9b7dc,\n    $b3836272a1374d85$export$640d294ab83f9040\n];\nconst $b3836272a1374d85$var$INLINE_FONT_TAGS = [\n    $b3836272a1374d85$export$2b0cbe6e95114098,\n    $b3836272a1374d85$export$1f62a95bf5703cac,\n    $b3836272a1374d85$export$f7227d9f34d97bec,\n    $b3836272a1374d85$export$14fe4ba6e94df04d,\n    $b3836272a1374d85$export$f0dee7f48597f09a,\n    $b3836272a1374d85$export$d2ed2b49c006eb23\n];\nconst $b3836272a1374d85$var$DIRECTIVES_WITH_RENDERABLE_LABEL = [\n    $b3836272a1374d85$export$deca399f8cd9b7dc,\n    $b3836272a1374d85$export$4f5168acae064e01,\n    $b3836272a1374d85$export$3550cc87694d54e0,\n    $b3836272a1374d85$export$8dd1111100e0e88d\n];\nconst $b3836272a1374d85$var$ALIASES = {\n    [$b3836272a1374d85$var$TITLE_SHORT]: $b3836272a1374d85$export$f1e53f710478ceb4,\n    [$b3836272a1374d85$var$SUBTITLE_SHORT]: $b3836272a1374d85$export$5895c693c74b9cf4,\n    [$b3836272a1374d85$var$COMMENT_SHORT]: $b3836272a1374d85$export$a29989082612d0d9,\n    [$b3836272a1374d85$var$START_OF_CHORUS_SHORT]: $b3836272a1374d85$export$4f5168acae064e01,\n    [$b3836272a1374d85$var$END_OF_CHORUS_SHORT]: $b3836272a1374d85$export$473c1a4819e5180b,\n    [$b3836272a1374d85$var$START_OF_TAB_SHORT]: $b3836272a1374d85$export$8dd1111100e0e88d,\n    [$b3836272a1374d85$var$END_OF_TAB_SHORT]: $b3836272a1374d85$export$66a0ef3ffeab32b7,\n    [$b3836272a1374d85$var$NEW_KEY_SHORT]: $b3836272a1374d85$export$b7627374a6424f68,\n    [$b3836272a1374d85$var$CHORDFONT_SHORT]: $b3836272a1374d85$export$2b0cbe6e95114098,\n    [$b3836272a1374d85$var$CHORDSIZE_SHORT]: $b3836272a1374d85$export$1f62a95bf5703cac,\n    [$b3836272a1374d85$var$TEXTFONT_SHORT]: $b3836272a1374d85$export$14fe4ba6e94df04d,\n    [$b3836272a1374d85$var$TEXTSIZE_SHORT]: $b3836272a1374d85$export$f0dee7f48597f09a\n};\nconst $b3836272a1374d85$var$TAG_REGEX = /^([^:\\s]+)(:?\\s*(.+))?$/;\nconst $b3836272a1374d85$var$CUSTOM_META_TAG_NAME_REGEX = /^x_(.+)$/;\nfunction $b3836272a1374d85$export$3ef04055cb4a269a(tagName) {\n    return $b3836272a1374d85$export$75d737e15c3fab80.includes(tagName);\n}\nconst $b3836272a1374d85$var$translateTagNameAlias = (name)=>{\n    if (!name) return name;\n    const sanitizedName = name.trim();\n    if (sanitizedName in $b3836272a1374d85$var$ALIASES) return $b3836272a1374d85$var$ALIASES[sanitizedName];\n    return sanitizedName;\n};\n/**\n * Represents a tag/directive. See https://www.chordpro.org/chordpro/chordpro-directives/\n */ class $b3836272a1374d85$var$Tag extends (0, $33b2f875bada793c$export$2e2bcd8739ae039) {\n    _originalName = \"\";\n    _name = \"\";\n    _value = \"\";\n    _isMetaTag = false;\n    constructor(name, value = null, traceInfo = null){\n        super(traceInfo);\n        this.parseNameValue(name, value);\n    }\n    parseNameValue(name, value) {\n        if (name === \"meta\") this.parseMetaTag(value);\n        else {\n            this.name = name;\n            this.value = value || \"\";\n        }\n    }\n    parseMetaTag(value) {\n        if (!value) throw new Error(\"Expected value\");\n        const [metaName, metaValue] = value.split(/\\s(.+)/);\n        this.name = metaName;\n        this.value = metaValue || \"\";\n        this._isMetaTag = true;\n    }\n    static parse(tag) {\n        if (tag instanceof $b3836272a1374d85$var$Tag) return tag;\n        return this.parseWithRegex(tag, $b3836272a1374d85$var$TAG_REGEX);\n    }\n    static parseWithRegex(tag, regex) {\n        const matches = tag.match(regex);\n        if (matches !== null) return new $b3836272a1374d85$var$Tag(matches[1], matches[3] || null);\n        return null;\n    }\n    static parseOrFail(tag) {\n        const parsed = this.parse(tag);\n        if (!parsed) throw new Error(`Failed to parse ${tag}`);\n        return parsed;\n    }\n    isSectionDelimiter() {\n        return $b3836272a1374d85$var$SECTION_DELIMITERS.includes(this.name);\n    }\n    isInlineFontTag() {\n        return $b3836272a1374d85$var$INLINE_FONT_TAGS.includes(this.name);\n    }\n    set name(name) {\n        this._name = $b3836272a1374d85$var$translateTagNameAlias(name);\n        this._originalName = name;\n    }\n    /**\n   * The tag full name. When the original tag used the short name, `name` will return the full name.\n   * @member\n   * @type {string}\n   */ get name() {\n        return this._name.trim();\n    }\n    /**\n   * The original tag name that was used to construct the tag.\n   * @member\n   * @type {string}\n   */ get originalName() {\n        return this._originalName.trim();\n    }\n    set value(value) {\n        this._value = value || \"\";\n    }\n    /**\n   * The tag value\n   * @member\n   * @type {string}\n   */ get value() {\n        return `${this._value}`.trim();\n    }\n    /**\n   * Checks whether the tag value is a non-empty string.\n   * @returns {boolean}\n   */ hasValue() {\n        return this.value.length > 0;\n    }\n    /**\n   * Checks whether the tag is usually rendered inline. It currently only applies to comment tags.\n   * @returns {boolean}\n   */ isRenderable() {\n        return $b3836272a1374d85$var$RENDERABLE_TAGS.includes(this.name) || this.hasRenderableLabel();\n    }\n    /**\n   * Check whether this tag's label (if any) should be rendered, as applicable to tags like\n   * `start_of_verse` and `start_of_chorus`.\n   * See https://chordpro.org/chordpro/directives-env_chorus/, https://chordpro.org/chordpro/directives-env_verse/,\n   * https://chordpro.org/chordpro/directives-env_bridge/, https://chordpro.org/chordpro/directives-env_tab/\n   */ hasRenderableLabel() {\n        return $b3836272a1374d85$var$DIRECTIVES_WITH_RENDERABLE_LABEL.includes(this.name) && this.hasValue();\n    }\n    /**\n   * Checks whether the tag is either a standard meta tag or a custom meta directive (`{x_some_name}`)\n   * @returns {boolean}\n   */ isMetaTag() {\n        return this._isMetaTag || $b3836272a1374d85$var$CUSTOM_META_TAG_NAME_REGEX.test(this.name) || $b3836272a1374d85$export$57ecf0dc09effb3.indexOf(this.name) !== -1;\n    }\n    /**\n   * Returns a clone of the tag.\n   * @returns {Tag} The cloned tag\n   */ clone() {\n        return new $b3836272a1374d85$var$Tag(this._originalName, this.value);\n    }\n    toString() {\n        return `Tag(name=${this.name}, value=${this.value})`;\n    }\n    set({ value: value  }) {\n        return new $b3836272a1374d85$var$Tag(this._originalName, value);\n    }\n}\nvar $b3836272a1374d85$export$2e2bcd8739ae039 = $b3836272a1374d85$var$Tag;\n\n\n/**\n * Represents a comment. See https://www.chordpro.org/chordpro/chordpro-file-format-specification/#overview\n */ class $df4ad73a744c94b3$var$Comment {\n    constructor(content){\n        this.content = content;\n    }\n    /**\n   * Indicates whether a Comment should be visible in a formatted chord sheet (except for ChordPro sheets)\n   * @returns {boolean}\n   */ isRenderable() {\n        return false;\n    }\n    /**\n   * Returns a deep copy of the Comment, useful when programmatically transforming a song\n   * @returns {Comment}\n   */ clone() {\n        return new $df4ad73a744c94b3$var$Comment(this.content);\n    }\n    toString() {\n        return `Comment(content=${this.content})`;\n    }\n}\nvar $df4ad73a744c94b3$export$2e2bcd8739ae039 = $df4ad73a744c94b3$var$Comment;\n\n\n\nclass $6cf55d420652e2b7$var$Font {\n    /**\n   * The font\n   * @member {string | null}\n   */ font = null;\n    /**\n   * The font size, expressed in either pixels or percentage.\n   * @member {FontSize | null}\n   */ size = null;\n    /**\n   * The font color\n   * @member {string | null}\n   */ colour = null;\n    constructor({ font: font , size: size , colour: colour  } = {\n        font: null,\n        size: null,\n        colour: null\n    }){\n        this.font = font ? font.replace(/\"/g, \"'\") : null;\n        this.size = size || null;\n        this.colour = colour || null;\n    }\n    clone() {\n        return new $6cf55d420652e2b7$var$Font({\n            font: this.font,\n            size: this.size,\n            colour: this.colour\n        });\n    }\n    /**\n   * Converts the font, size and color to a CSS string.\n   * If possible, font and size are combined to the `font` shorthand.\n   * If `font` contains double quotes (`\"`) those will be converted to single quotes (`'`).\n   *\n   * @example\n   * // Returns \"font-family: 'Times New Roman'\"\n   * new Font({ font: '\"Times New Roman\"' }).toCssString()\n   * @example\n   * // Returns \"color: red; font-family: Verdana\"\n   * new Font({ font: 'Verdana', colour: 'red' }).toCssString()\n   * @example\n   * // Returns \"font: 30px Verdana\"\n   * new Font({ font: 'Verdana', size: '30' }).toCssString()\n   * @example\n   * // Returns \"color: blue; font: 30% Verdana\"\n   * new Font({ font: 'Verdana', size: '30%', colour: 'blue' }).toCssString()\n   *\n   * @return {string} The CSS string\n   */ toCssString() {\n        const properties = {};\n        if (this.colour) properties.color = this.colour;\n        if (this.font && this.size) properties.font = `${this.size} ${this.font}`;\n        else if (this.font) properties[\"font-family\"] = this.font;\n        else if (this.size) properties[\"font-size\"] = `${this.size}`;\n        return Object.keys(properties).map((key)=>`${key}: ${properties[key]}`).join(\"; \");\n    }\n}\nvar $6cf55d420652e2b7$export$2e2bcd8739ae039 = $6cf55d420652e2b7$var$Font;\n\n\n/**\n * Represents a line in a chord sheet, consisting of items of type ChordLyricsPair or Tag\n */ class $06eb272065540fc1$var$Line {\n    /**\n   * The items ({@link ChordLyricsPair} or {@link Tag} or {@link Comment}) of which the line consists\n   * @type {Array.<(ChordLyricsPair|Tag|Comment)>}\n   */ items = [];\n    /**\n   * The line type, This is set by the ChordProParser when it read tags like {start_of_chorus} or {start_of_verse}\n   * Values can be {@link VERSE}, {@link CHORUS} or {@link NONE}\n   * @type {string}\n   */ type = (0, $234747a9630b4642$export$c53d0f541b41b88e);\n    currentChordLyricsPair = new (0, $f7a904d05353aafa$export$2e2bcd8739ae039)();\n    key = null;\n    transposeKey = null;\n    /**\n   * The text font that applies to this line. Is derived from the directives:\n   * `textfont`, `textsize` and `textcolour`\n   * See: https://www.chordpro.org/chordpro/directives-props_text_legacy/\n   * @type {Font}\n   */ textFont = new (0, $6cf55d420652e2b7$export$2e2bcd8739ae039)();\n    /**\n   * The chord font that applies to this line. Is derived from the directives:\n   * `chordfont`, `chordsize` and `chordcolour`\n   * See: https://www.chordpro.org/chordpro/directives-props_chord_legacy/\n   * @type {Font}\n   */ chordFont = new (0, $6cf55d420652e2b7$export$2e2bcd8739ae039)();\n    constructor({ type: type , items: items  } = {\n        type: (0, $234747a9630b4642$export$c53d0f541b41b88e),\n        items: []\n    }){\n        this.type = type;\n        this.items = items;\n    }\n    /**\n   * Indicates whether the line contains any items\n   * @returns {boolean}\n   */ isEmpty() {\n        return this.items.length === 0;\n    }\n    /**\n   * Adds an item ({@link ChordLyricsPair} or {@link Tag}) to the line\n   * @param {ChordLyricsPair|Tag} item The item to be added\n   */ addItem(item) {\n        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039)) this.addTag(item);\n        else if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) this.addChordLyricsPair(item);\n        else if (item instanceof (0, $df4ad73a744c94b3$export$2e2bcd8739ae039)) this.addComment(item);\n        else this.items.push(item);\n    }\n    /**\n   * Indicates whether the line contains items that are renderable\n   * @returns {boolean}\n   */ hasRenderableItems() {\n        return this.items.some((item)=>item.isRenderable());\n    }\n    /**\n   * Returns a deep copy of the line and all of its items\n   * @returns {Line}\n   */ clone() {\n        return this.mapItems(null);\n    }\n    mapItems(func) {\n        const clonedLine = new $06eb272065540fc1$var$Line();\n        clonedLine.items = this.items.map((item)=>{\n            const clonedItem = item.clone();\n            return func ? func(clonedItem) : clonedItem;\n        }).filter((item)=>item);\n        clonedLine.type = this.type;\n        return clonedLine;\n    }\n    /**\n   * Indicates whether the line type is {@link VERSE}\n   * @returns {boolean}\n   */ isVerse() {\n        return this.type === (0, $234747a9630b4642$export$4b194284baed1659);\n    }\n    /**\n   * Indicates whether the line type is {@link CHORUS}\n   * @returns {boolean}\n   */ isChorus() {\n        return this.type === (0, $234747a9630b4642$export$8db6c706fc9142b2);\n    }\n    /**\n   * Indicates whether the line contains items that are renderable. Please use {@link hasRenderableItems}\n   * @deprecated\n   * @returns {boolean}\n   */ hasContent() {\n        return this.hasRenderableItems();\n    }\n    addChordLyricsPair(chords = null, lyrics = null) {\n        if (chords instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) this.currentChordLyricsPair = chords;\n        else this.currentChordLyricsPair = new (0, $f7a904d05353aafa$export$2e2bcd8739ae039)(chords || \"\", lyrics || \"\");\n        this.items.push(this.currentChordLyricsPair);\n        return this.currentChordLyricsPair;\n    }\n    ensureChordLyricsPair() {\n        if (!this.currentChordLyricsPair) this.addChordLyricsPair();\n    }\n    chords(chr) {\n        this.ensureChordLyricsPair();\n        this.currentChordLyricsPair.chords += chr;\n    }\n    lyrics(chr) {\n        this.ensureChordLyricsPair();\n        this.currentChordLyricsPair.lyrics += chr;\n    }\n    addTag(nameOrTag, value = null) {\n        const tag = nameOrTag instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) ? nameOrTag : new (0, $b3836272a1374d85$export$2e2bcd8739ae039)(nameOrTag, value);\n        this.items.push(tag);\n        return tag;\n    }\n    addComment(content) {\n        const comment = content instanceof (0, $df4ad73a744c94b3$export$2e2bcd8739ae039) ? content : new (0, $df4ad73a744c94b3$export$2e2bcd8739ae039)(content);\n        this.items.push(comment);\n        return comment;\n    }\n    set(properties) {\n        return new $06eb272065540fc1$var$Line({\n            type: this.type,\n            items: this.items,\n            ...properties\n        });\n    }\n}\nvar $06eb272065540fc1$export$2e2bcd8739ae039 = $06eb272065540fc1$var$Line;\n\n\n\n/**\n * Represents a paragraph of lines in a chord sheet\n */ class $55861b6d10167265$var$Paragraph {\n    /**\n   * The {@link Line} items of which the paragraph consists\n   * @member\n   * @type {Line[]}\n   */ lines = [];\n    addLine(line) {\n        this.lines.push(line);\n    }\n    /**\n   * Tries to determine the common type for all lines. If the types for all lines are equal, it returns that type.\n   * If not, it returns {@link INDETERMINATE}\n   * @returns {string}\n   */ get type() {\n        const types = this.lines.map((line)=>line.type);\n        const uniqueTypes = [\n            ...new Set(types)\n        ];\n        if (uniqueTypes.length === 1) return uniqueTypes[0];\n        return 0, $234747a9630b4642$export$c5a6fe907430212e;\n    }\n    /**\n   * Indicates whether the paragraph contains lines with renderable items.\n   * @see {@link Line.hasRenderableItems}\n   * @returns {boolean}\n   */ hasRenderableItems() {\n        return this.lines.some((line)=>line.hasRenderableItems());\n    }\n}\nvar $55861b6d10167265$export$2e2bcd8739ae039 = $55861b6d10167265$var$Paragraph;\n\n\n\n\n\n\n\nclass $328bfb8696ee6244$var$MetadataAccessors {\n    get key() {\n        return this.getSingleMetadata((0, $b3836272a1374d85$export$7167c830cefcb6b5));\n    }\n    get title() {\n        return this.getSingleMetadata((0, $b3836272a1374d85$export$f1e53f710478ceb4));\n    }\n    get subtitle() {\n        return this.getSingleMetadata((0, $b3836272a1374d85$export$5895c693c74b9cf4));\n    }\n    get capo() {\n        return this.getMetadata((0, $b3836272a1374d85$export$866f445d49bad88e));\n    }\n    get duration() {\n        return this.getSingleMetadata((0, $b3836272a1374d85$export$bacc88974c736870));\n    }\n    get tempo() {\n        return this.getSingleMetadata((0, $b3836272a1374d85$export$bd8d57d0bc5a8478));\n    }\n    get time() {\n        return this.getMetadata((0, $b3836272a1374d85$export$a9905336c0111a3a));\n    }\n    get year() {\n        return this.getSingleMetadata((0, $b3836272a1374d85$export$90b88dc425a06a95));\n    }\n    get album() {\n        return this.getMetadata((0, $b3836272a1374d85$export$10227cb086d1770c));\n    }\n    get copyright() {\n        return this.getSingleMetadata((0, $b3836272a1374d85$export$4ab8c75045d12480));\n    }\n    get lyricist() {\n        return this.getMetadata((0, $b3836272a1374d85$export$a6901bd008617c61));\n    }\n    get artist() {\n        return this.getMetadata((0, $b3836272a1374d85$export$17d8dfb3db842bf));\n    }\n    get composer() {\n        return this.getMetadata((0, $b3836272a1374d85$export$98424633dc8c377f));\n    }\n}\nvar $328bfb8696ee6244$export$2e2bcd8739ae039 = $328bfb8696ee6244$var$MetadataAccessors;\n\n\n\nfunction $fdb42fd3b59812d4$var$appendValue(array, value) {\n    if (!array.includes(value)) array.push(value);\n}\n/**\n * Stores song metadata. Properties can be accessed using the get() method:\n *\n * const metadata = new Metadata({ author: 'John' });\n * metadata.get('author')   // => 'John'\n *\n * See {@link Metadata#get}\n */ class $fdb42fd3b59812d4$var$Metadata extends (0, $328bfb8696ee6244$export$2e2bcd8739ae039) {\n    metadata = {};\n    constructor(metadata = {}){\n        super();\n        if (metadata) this.assign(metadata);\n    }\n    merge(metadata) {\n        const clone = this.clone();\n        clone.assign(metadata);\n        return clone;\n    }\n    contains(key) {\n        return key in this.metadata;\n    }\n    add(key, value) {\n        if ((0, $b3836272a1374d85$export$3ef04055cb4a269a)(key)) return;\n        if (!(key in this.metadata)) {\n            this.metadata[key] = value;\n            return;\n        }\n        const currentValue = this.metadata[key];\n        if (currentValue === value) return;\n        if (currentValue instanceof Array) {\n            $fdb42fd3b59812d4$var$appendValue(currentValue, value);\n            return;\n        }\n        this.metadata[key] = [\n            currentValue,\n            value\n        ];\n    }\n    set(key, value) {\n        if (value) this.metadata[key] = value;\n        else delete this.metadata[key];\n    }\n    getMetadata(name) {\n        return this.get(name);\n    }\n    getSingleMetadata(name) {\n        return this.getSingle(name);\n    }\n    /**\n   * Reads a metadata value by key. This method supports simple value lookup, as well as fetching single array values.\n   *\n   * This method deprecates direct property access, eg: metadata['author']\n   *\n   * Examples:\n   *\n   * const metadata = new Metadata({ lyricist: 'Pete', author: ['John', 'Mary'] });\n   * metadata.get('lyricist') // => 'Pete'\n   * metadata.get('author')   // => ['John', 'Mary']\n   * metadata.get('author.1') // => 'John'\n   * metadata.get('author.2') // => 'Mary'\n   *\n   * Using a negative index will start counting at the end of the list:\n   *\n   * const metadata = new Metadata({ lyricist: 'Pete', author: ['John', 'Mary'] });\n   * metadata.get('author.-1') // => 'Mary'\n   * metadata.get('author.-2') // => 'John'\n   *\n   * @param prop the property name\n   * @returns {Array<String>|String} the metadata value(s). If there is only one value, it will return a String,\n   * else it returns an array of strings.\n   */ get(prop) {\n        if (prop === (0, $b3836272a1374d85$export$430b1920f5feeae)) return this.calculateKeyFromCapo();\n        if (prop in this.metadata) return this.metadata[prop];\n        return this.getArrayItem(prop);\n    }\n    /**\n   * Returns a single metadata value. If the actual value is an array, it returns the first value. Else, it returns\n   * the value.\n   * @ignore\n   * @param {string} prop the property name\n   * @returns {String} The metadata value\n   */ getSingle(prop) {\n        const value = this.get(prop);\n        if (Array.isArray(value)) return value[0];\n        return value;\n    }\n    parseArrayKey(prop) {\n        const match = prop.match(/(.+)\\.(-?\\d+)$/);\n        if (!match) return null;\n        const key = match[1];\n        const index = parseInt(match[2], 10);\n        return [\n            key,\n            index\n        ];\n    }\n    getArrayItem(prop) {\n        const parsedKey = this.parseArrayKey(prop);\n        if (parsedKey === null) return undefined;\n        const [key, index] = parsedKey;\n        const arrayValue = this.metadata[key] || [];\n        let itemIndex = index;\n        if (itemIndex < 0) itemIndex = arrayValue.length + itemIndex;\n        else if (itemIndex > 0) itemIndex -= 1;\n        return arrayValue[itemIndex];\n    }\n    /**\n   * Returns a deep clone of this Metadata object\n   * @returns {Metadata} the cloned Metadata object\n   */ clone() {\n        return new $fdb42fd3b59812d4$var$Metadata(this.metadata);\n    }\n    calculateKeyFromCapo() {\n        const capo = this.getSingle((0, $b3836272a1374d85$export$866f445d49bad88e));\n        const key = this.getSingle((0, $b3836272a1374d85$export$7167c830cefcb6b5));\n        if (capo && key) {\n            const chord = (0, $5e3a0c5a6197f95b$export$2e2bcd8739ae039).parse(key);\n            if (!chord) throw new Error(`Could not parse ${key}`);\n            return chord.transpose(parseInt(capo, 10)).toString();\n        }\n        return undefined;\n    }\n    assign(metadata) {\n        Object.keys(metadata).filter((key)=>!(0, $b3836272a1374d85$export$3ef04055cb4a269a)(key)).forEach((key)=>{\n            const value = metadata[key];\n            if (value instanceof Array) this.metadata[key] = [\n                ...value\n            ];\n            else this.metadata[key] = value;\n        });\n    }\n}\nvar $fdb42fd3b59812d4$export$2e2bcd8739ae039 = $fdb42fd3b59812d4$var$Metadata;\n\n\n/**\n * Represents a parser warning, currently only used by ChordProParser.\n */ class $8a1166616d2a7987$var$ParserWarning {\n    /**\n   * The chord sheet line number on which the warning occurred\n   * @member\n   * @type {number}\n   */ lineNumber = null;\n    /**\n   * The chord sheet column on which the warning occurred\n   * @member\n   * @type {number}\n   */ column = null;\n    /**\n   * @hideconstructor\n   */ constructor(message, lineNumber, column){\n        this.message = message;\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n   * Returns a stringified version of the warning\n   * @returns {string} The string warning\n   */ toString() {\n        return `Warning: ${this.message} on line ${this.lineNumber || \"?\"} column ${this.column || \"?\"}`;\n    }\n}\nvar $8a1166616d2a7987$export$2e2bcd8739ae039 = $8a1166616d2a7987$var$ParserWarning;\n\n\n\n\nclass $b039d61fa8aab1e4$var$FontSize {\n    constructor(fontSize, kind){\n        this.fontSize = fontSize;\n        this.unit = kind;\n    }\n    clone() {\n        return new $b039d61fa8aab1e4$var$FontSize(this.fontSize, this.unit);\n    }\n    multiply(percentage) {\n        return new $b039d61fa8aab1e4$var$FontSize(this.fontSize * percentage / 100, this.unit);\n    }\n    /**\n   * Stringifies the font size by concatenating size and unit\n   *\n   * @example\n   * // Returns \"30px\"\n   * new FontSize(30, 'px').toString()\n   * @example\n   * // Returns \"120%\"\n   * new FontSize(120, '%').toString()\n   *\n   * @return {string} The font size\n   */ toString() {\n        return `${this.fontSize}${this.unit}`;\n    }\n    static parse(fontSize, parent) {\n        const trimmed = fontSize.trim();\n        const parsedFontSize = parseFloat(trimmed);\n        if (Number.isNaN(parsedFontSize)) return this.parseNotANumber(parent);\n        if (trimmed.slice(-1) === \"%\") return this.parsePercentage(parsedFontSize, parent);\n        return new $b039d61fa8aab1e4$var$FontSize(parsedFontSize, \"px\");\n    }\n    static parseNotANumber(parent) {\n        if (parent) return parent.clone();\n        return new $b039d61fa8aab1e4$var$FontSize(100, \"%\");\n    }\n    static parsePercentage(parsedFontSize, parent) {\n        if (parent) return parent.multiply(parsedFontSize);\n        return new $b039d61fa8aab1e4$var$FontSize(parsedFontSize, \"%\");\n    }\n}\nvar $b039d61fa8aab1e4$export$2e2bcd8739ae039 = $b039d61fa8aab1e4$var$FontSize;\n\n\n\nclass $4ddcb30f99cdcc6a$var$FontStack {\n    fontAndColourStacks = {\n        [(0, $b3836272a1374d85$export$f7227d9f34d97bec)]: [],\n        [(0, $b3836272a1374d85$export$2b0cbe6e95114098)]: [],\n        [(0, $b3836272a1374d85$export$d2ed2b49c006eb23)]: [],\n        [(0, $b3836272a1374d85$export$14fe4ba6e94df04d)]: []\n    };\n    sizeStacks = {\n        [(0, $b3836272a1374d85$export$1f62a95bf5703cac)]: [],\n        [(0, $b3836272a1374d85$export$f0dee7f48597f09a)]: []\n    };\n    textFont = new (0, $6cf55d420652e2b7$export$2e2bcd8739ae039)();\n    chordFont = new (0, $6cf55d420652e2b7$export$2e2bcd8739ae039)();\n    applyTag(tag) {\n        switch(tag.name){\n            case 0, $b3836272a1374d85$export$14fe4ba6e94df04d:\n                this.textFont.font = this.pushOrPopTag(tag);\n                break;\n            case 0, $b3836272a1374d85$export$f0dee7f48597f09a:\n                this.textFont.size = this.pushOrPopSizeTag(tag);\n                break;\n            case 0, $b3836272a1374d85$export$d2ed2b49c006eb23:\n                this.textFont.colour = this.pushOrPopTag(tag);\n                break;\n            case 0, $b3836272a1374d85$export$2b0cbe6e95114098:\n                this.chordFont.font = this.pushOrPopTag(tag);\n                break;\n            case 0, $b3836272a1374d85$export$1f62a95bf5703cac:\n                this.chordFont.size = this.pushOrPopSizeTag(tag);\n                break;\n            case 0, $b3836272a1374d85$export$f7227d9f34d97bec:\n                this.chordFont.colour = this.pushOrPopTag(tag);\n                break;\n            default:\n                break;\n        }\n    }\n    pushOrPopTag(tag) {\n        let { value: value  } = tag;\n        if (tag.hasValue()) this.fontAndColourStacks[tag.name].push(value);\n        else {\n            this.fontAndColourStacks[tag.name].pop();\n            value = this.fontAndColourStacks[tag.name].slice(-1)[0] || null;\n        }\n        return value;\n    }\n    pushOrPopSizeTag(tag) {\n        const { value: value  } = tag;\n        if (tag.hasValue()) {\n            const parent = this.sizeStacks[tag.name].slice(-1)[0] || null;\n            const parsedFontSize = (0, $b039d61fa8aab1e4$export$2e2bcd8739ae039).parse(value, parent);\n            this.sizeStacks[tag.name].push(parsedFontSize);\n            return parsedFontSize;\n        }\n        this.sizeStacks[tag.name].pop();\n        return this.sizeStacks[tag.name].slice(-1)[0] || null;\n    }\n}\nvar $4ddcb30f99cdcc6a$export$2e2bcd8739ae039 = $4ddcb30f99cdcc6a$var$FontStack;\n\n\n\n\n/**\n * Represents a song in a chord sheet. Currently a chord sheet can only have one song.\n */ class $7860c26c4d50915f$var$Song extends (0, $328bfb8696ee6244$export$2e2bcd8739ae039) {\n    /**\n   * The {@link Line} items of which the song consists\n   * @member {Line[]}\n   */ lines = [];\n    currentLine = null;\n    warnings = [];\n    sectionType = (0, $234747a9630b4642$export$c53d0f541b41b88e);\n    fontStack = new (0, $4ddcb30f99cdcc6a$export$2e2bcd8739ae039)();\n    currentKey = null;\n    transposeKey = null;\n    _bodyParagraphs = null;\n    _bodyLines = null;\n    /**\n   * Creates a new {Song} instance\n   * @param metadata {Object|Metadata} predefined metadata\n   */ constructor(metadata = {}){\n        super();\n        this.metadata = new (0, $fdb42fd3b59812d4$export$2e2bcd8739ae039)(metadata);\n    }\n    get previousLine() {\n        const count = this.lines.length;\n        if (count >= 2) return this.lines[count - 2];\n        return null;\n    }\n    /**\n   * Returns the song lines, skipping the leading empty lines (empty as in not rendering any content). This is useful\n   * if you want to skip the \"header lines\": the lines that only contain meta data.\n   * @returns {Line[]} The song body lines\n   */ get bodyLines() {\n        if (!this._bodyLines) this._bodyLines = this.selectRenderableItems(this.lines);\n        return this._bodyLines;\n    }\n    /**\n   * Returns the song paragraphs, skipping the paragraphs that only contain empty lines\n   * (empty as in not rendering any content)\n   * @see {@link bodyLines}\n   * @returns {Paragraph[]}\n   */ get bodyParagraphs() {\n        if (!this._bodyParagraphs) this._bodyParagraphs = this.selectRenderableItems(this.paragraphs);\n        return this._bodyParagraphs;\n    }\n    selectRenderableItems(items) {\n        const copy = [\n            ...items\n        ];\n        while(copy.length && !copy[0].hasRenderableItems())copy.shift();\n        return copy;\n    }\n    chords(chr) {\n        if (!this.currentLine) throw new Error(\"Expected this.currentLine to be present\");\n        this.currentLine.chords(chr);\n    }\n    lyrics(chr) {\n        this.ensureLine();\n        if (!this.currentLine) throw new Error(\"Expected this.currentLine to be present\");\n        this.currentLine.lyrics(chr);\n    }\n    addLine(line) {\n        if (line) this.currentLine = line;\n        else {\n            this.currentLine = new (0, $06eb272065540fc1$export$2e2bcd8739ae039)();\n            this.lines.push(this.currentLine);\n        }\n        this.setCurrentProperties(this.sectionType);\n        this.currentLine.transposeKey = this.transposeKey ?? this.currentKey;\n        this.currentLine.key = this.currentKey || this.metadata.getSingle((0, $b3836272a1374d85$export$7167c830cefcb6b5));\n        return this.currentLine;\n    }\n    /**\n   * The {@link Paragraph} items of which the song consists\n   * @member {Paragraph[]}\n   */ get paragraphs() {\n        let currentParagraph = new (0, $55861b6d10167265$export$2e2bcd8739ae039)();\n        const paragraphs = [\n            currentParagraph\n        ];\n        this.lines.forEach((line)=>{\n            if (line.isEmpty()) {\n                currentParagraph = new (0, $55861b6d10167265$export$2e2bcd8739ae039)();\n                paragraphs.push(currentParagraph);\n            } else if (line.hasRenderableItems()) currentParagraph.addLine(line);\n        });\n        return paragraphs;\n    }\n    setCurrentProperties(sectionType) {\n        if (!this.currentLine) throw new Error(\"Expected this.currentLine to be present\");\n        this.currentLine.type = sectionType;\n        this.currentLine.textFont = this.fontStack.textFont.clone();\n        this.currentLine.chordFont = this.fontStack.chordFont.clone();\n    }\n    ensureLine() {\n        if (this.currentLine === null) this.addLine();\n    }\n    addTag(tagContents) {\n        const tag = (0, $b3836272a1374d85$export$2e2bcd8739ae039).parseOrFail(tagContents);\n        this.applyTagOnSong(tag);\n        this.applyTagOnLine(tag);\n        return tag;\n    }\n    applyTagOnLine(tag) {\n        this.ensureLine();\n        if (!this.currentLine) throw new Error(\"Expected this.currentLine to be present\");\n        this.currentLine.addTag(tag);\n    }\n    applyTagOnSong(tag) {\n        if (tag.isMetaTag()) this.setMetadata(tag.name, tag.value || \"\");\n        else if (tag.name === (0, $b3836272a1374d85$export$ae60ab9b4739fc3d)) this.transposeKey = tag.value;\n        else if (tag.name === (0, $b3836272a1374d85$export$b7627374a6424f68)) this.currentKey = tag.value;\n        else if (tag.isSectionDelimiter()) this.setSectionTypeFromTag(tag);\n        else if (tag.isInlineFontTag()) this.fontStack.applyTag(tag);\n    }\n    setSectionTypeFromTag(tag) {\n        switch(tag.name){\n            case 0, $b3836272a1374d85$export$4f5168acae064e01:\n                this.startSection((0, $234747a9630b4642$export$8db6c706fc9142b2), tag);\n                break;\n            case 0, $b3836272a1374d85$export$473c1a4819e5180b:\n                this.endSection((0, $234747a9630b4642$export$8db6c706fc9142b2), tag);\n                break;\n            case 0, $b3836272a1374d85$export$8dd1111100e0e88d:\n                this.startSection((0, $234747a9630b4642$export$f1c9dd0f5207dd5e), tag);\n                break;\n            case 0, $b3836272a1374d85$export$66a0ef3ffeab32b7:\n                this.endSection((0, $234747a9630b4642$export$f1c9dd0f5207dd5e), tag);\n                break;\n            case 0, $b3836272a1374d85$export$deca399f8cd9b7dc:\n                this.startSection((0, $234747a9630b4642$export$4b194284baed1659), tag);\n                break;\n            case 0, $b3836272a1374d85$export$640d294ab83f9040:\n                this.endSection((0, $234747a9630b4642$export$4b194284baed1659), tag);\n                break;\n            default:\n                break;\n        }\n    }\n    startSection(sectionType, tag) {\n        this.checkCurrentSectionType((0, $234747a9630b4642$export$c53d0f541b41b88e), tag);\n        this.sectionType = sectionType;\n        this.setCurrentProperties(sectionType);\n    }\n    endSection(sectionType, tag) {\n        this.checkCurrentSectionType(sectionType, tag);\n        this.sectionType = (0, $234747a9630b4642$export$c53d0f541b41b88e);\n    }\n    checkCurrentSectionType(sectionType, tag) {\n        if (this.sectionType !== sectionType) this.addWarning(`Unexpected tag {${tag.originalName}, current section is: ${this.sectionType}`, tag);\n    }\n    addWarning(message, { line: line , column: column  }) {\n        const warning = new (0, $8a1166616d2a7987$export$2e2bcd8739ae039)(message, line || null, column || null);\n        this.warnings.push(warning);\n    }\n    addItem(item) {\n        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039)) this.addTag(item);\n        else {\n            this.ensureLine();\n            if (!this.currentLine) throw new Error(\"Expected this.currentLine to be present\");\n            this.currentLine.addItem(item);\n        }\n    }\n    /**\n   * Returns a deep clone of the song\n   * @returns {Song} The cloned song\n   */ clone() {\n        return this.mapItems((item)=>item);\n    }\n    setMetadata(name, value) {\n        this.metadata.add(name, value);\n    }\n    /**\n   * The song's metadata. Please use {@link metadata} instead.\n   * @deprecated\n   * @returns {@link Metadata} The metadata\n   */ get metaData() {\n        (0, $974bd1d260bb1d53$export$b680e6b2c82f8c2f)('metaData has been deprecated, please use metadata instead (notice the lowercase \"d\")');\n        return this.metadata;\n    }\n    getMetadata(name) {\n        return this.metadata.getMetadata(name);\n    }\n    getSingleMetadata(name) {\n        return this.metadata.getSingleMetadata(name);\n    }\n    /**\n   * Returns a copy of the song with the key value set to the specified key. It changes:\n   * - the value for `key` in the {@link metadata} set\n   * - any existing `key` directive\n   * @param {number|null} key the key. Passing `null` will:\n   * - remove the current key from {@link metadata}\n   * - remove any `key` directive\n   * @returns {Song} The changed song\n   */ setKey(key) {\n        const strKey = key ? key.toString() : null;\n        return this.changeMetadata((0, $b3836272a1374d85$export$7167c830cefcb6b5), strKey);\n    }\n    /**\n   * Returns a copy of the song with the key value set to the specified capo. It changes:\n   * - the value for `capo` in the {@link metadata} set\n   * - any existing `capo` directive\n   * @param {number|null} capo the capo. Passing `null` will:\n   * - remove the current key from {@link metadata}\n   * - remove any `capo` directive\n   * @returns {Song} The changed song\n   */ setCapo(capo) {\n        const strCapo = capo ? capo.toString() : null;\n        return this.changeMetadata((0, $b3836272a1374d85$export$866f445d49bad88e), strCapo);\n    }\n    setDirective(name, value) {\n        if (value === null) return this.removeItem((item)=>item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.name === name);\n        return this.updateItem((item)=>item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.name === name, (item)=>\"set\" in item ? item.set({\n                value: value\n            }) : item, (song)=>song.insertDirective(name, value));\n    }\n    /**\n   * Transposes the song by the specified delta. It will:\n   * - transpose all chords, see: {@link Chord#transpose}\n   * - transpose the song key in {@link metadata}\n   * - update any existing `key` directive\n   * @param {number} delta The number of semitones (positive or negative) to transpose with\n   * @param {Object} [options={}] options\n   * @param {boolean} [options.normalizeChordSuffix=false] whether to normalize the chord suffixes after transposing\n   * @returns {Song} The transposed song\n   */ transpose(delta, { normalizeChordSuffix: normalizeChordSuffix = false  } = {}) {\n        const wrappedKey = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrap(this.key);\n        let transposedKey = null;\n        let song = this;\n        if (wrappedKey) {\n            transposedKey = wrappedKey.transpose(delta);\n            song = song.setKey(transposedKey.toString());\n        }\n        return song.mapItems((item)=>{\n            if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) return item.transpose(delta, transposedKey, {\n                normalizeChordSuffix: normalizeChordSuffix\n            });\n            return item;\n        });\n    }\n    /**\n   * Transposes the song up by one semitone. It will:\n   * - transpose all chords, see: {@link Chord#transpose}\n   * - transpose the song key in {@link metadata}\n   * - update any existing `key` directive\n   * @param {Object} [options={}] options\n   * @param {boolean} [options.normalizeChordSuffix=false] whether to normalize the chord suffixes after transposing\n   * @returns {Song} The transposed song\n   */ transposeUp({ normalizeChordSuffix: normalizeChordSuffix = false  } = {}) {\n        return this.transpose(1, {\n            normalizeChordSuffix: normalizeChordSuffix\n        });\n    }\n    /**\n   * Transposes the song down by one semitone. It will:\n   * - transpose all chords, see: {@link Chord#transpose}\n   * - transpose the song key in {@link metadata}\n   * - update any existing `key` directive\n   * @param {Object} [options={}] options\n   * @param {boolean} [options.normalizeChordSuffix=false] whether to normalize the chord suffixes after transposing\n   * @returns {Song} The transposed song\n   */ transposeDown({ normalizeChordSuffix: normalizeChordSuffix = false  } = {}) {\n        return this.transpose(-1, {\n            normalizeChordSuffix: normalizeChordSuffix\n        });\n    }\n    /**\n   * Returns a copy of the song with the key set to the specified key. It changes:\n   * - the value for `key` in the {@link metadata} set\n   * - any existing `key` directive\n   * - all chords, those are transposed according to the distance between the current and the new key\n   * @param {string} newKey The new key.\n   * @returns {Song} The changed song\n   */ changeKey(newKey) {\n        const transpose = this.getTransposeDistance(newKey);\n        const updatedSong = this.mapItems((item)=>{\n            if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.name === (0, $b3836272a1374d85$export$7167c830cefcb6b5)) return item.set({\n                value: newKey.toString()\n            });\n            if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) return item.transpose(transpose, newKey);\n            return item;\n        });\n        this.setKey(newKey.toString());\n        return updatedSong;\n    }\n    getTransposeDistance(newKey) {\n        const wrappedKey = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrap(this.key);\n        if (!wrappedKey) throw new Error(`\nCannot change song key, the original key is unknown.\n\nEither ensure a key directive is present in the song (when using chordpro):\n  \\`{key: C}\\`\n\nOr set the song key before changing key:\n  \\`song.setKey('C');\\``.substring(1));\n        return wrappedKey.distanceTo(newKey);\n    }\n    /**\n   * Returns a copy of the song with the directive value set to the specified value.\n   * - when there is a matching directive in the song, it will update the directive\n   * - when there is no matching directive, it will be inserted\n   * If `value` is `null` it will act as a delete, any directive matching `name` will be removed.\n   * @param {string} name The directive name\n   * @param {string | null} value The value to set, or `null` to remove the directive\n   */ changeMetadata(name, value) {\n        const updatedSong = this.setDirective(name, value);\n        updatedSong.metadata.set(name, value);\n        return updatedSong;\n    }\n    insertDirective(name, value, { after: after = null  } = {}) {\n        const insertIndex = this.lines.findIndex((line)=>line.items.some((item)=>!(item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039)) || after && item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.name === after));\n        const newLine = new (0, $06eb272065540fc1$export$2e2bcd8739ae039)();\n        newLine.addTag(name, value);\n        const clonedSong = this.clone();\n        const { lines: lines  } = clonedSong;\n        clonedSong.lines = [\n            ...lines.slice(0, insertIndex),\n            newLine,\n            ...lines.slice(insertIndex)\n        ];\n        return clonedSong;\n    }\n    /**\n   * Change the song contents inline. Return a new {@link Item} to replace it. Return `null` to remove it.\n   * @example\n   * // transpose all chords:\n   * song.mapItems((item) => {\n   *   if (item instanceof ChordLyricsPair) {\n   *     return item.transpose(2, 'D');\n   *   }\n   *\n   *   return item;\n   * });\n   * @param {MapItemsCallback} func the callback function\n   * @returns {Song} the changed song\n   */ mapItems(func) {\n        const clonedSong = new $7860c26c4d50915f$var$Song();\n        this.lines.forEach((line)=>{\n            clonedSong.addLine();\n            line.items.forEach((item)=>{\n                const changedItem = func(item);\n                if (changedItem) clonedSong.addItem(changedItem);\n            });\n        });\n        return clonedSong;\n    }\n    /**\n   * Change the song contents inline. Return a new {@link Line} to replace it. Return `null` to remove it.\n   * @example\n   * // remove lines with only Tags:\n   * song.mapLines((line) => {\n   *   if (line.items.every(item => item instanceof Tag)) {\n   *     return null;\n   *   }\n   *\n   *   return line;\n   * });\n   * @param {MapLinesCallback} func the callback function\n   * @returns {Song} the changed song\n   */ mapLines(func) {\n        const clonedSong = new $7860c26c4d50915f$var$Song();\n        this.lines.forEach((line)=>{\n            const changedLine = func(line);\n            if (changedLine) {\n                clonedSong.addLine();\n                changedLine.items.forEach((item)=>clonedSong.addItem(item));\n            }\n        });\n        return clonedSong;\n    }\n    updateItem(findCallback, updateCallback, notFoundCallback) {\n        let found = false;\n        const updatedSong = this.mapItems((item)=>{\n            if (findCallback(item)) {\n                found = true;\n                return updateCallback(item);\n            }\n            return item;\n        });\n        if (!found) return notFoundCallback(updatedSong);\n        return updatedSong;\n    }\n    removeItem(callback) {\n        return this.mapLines((line)=>{\n            const { items: items  } = line;\n            const index = items.findIndex(callback);\n            if (index === -1) return line;\n            if (items.length === 1) return null;\n            return line.set({\n                items: [\n                    ...items.slice(0, index),\n                    ...items.slice(index + 1)\n                ]\n            });\n        });\n    }\n}\nvar $7860c26c4d50915f$export$2e2bcd8739ae039 = $7860c26c4d50915f$var$Song;\n\n\n\n\n\nclass $3fb187494df71568$var$EvaluationError extends Error {\n    line = null;\n    column = null;\n    offset = null;\n    constructor(message, line = null, column = null, offset = null){\n        super(`${message} on line ${line} column ${column}`);\n        this.name = \"ExpressionError\";\n        this.line = line;\n        this.column = column;\n        this.offset = offset;\n    }\n}\nvar $3fb187494df71568$export$2e2bcd8739ae039 = $3fb187494df71568$var$EvaluationError;\n\n\n\n\nclass $ba84a02c63f26e83$var$Composite extends (0, $b5c6143e2fff9a4c$export$2e2bcd8739ae039) {\n    expressions = [];\n    constructor(expressions, variable = null){\n        super();\n        this.expressions = expressions;\n        this.variable = variable;\n    }\n    evaluate(metadata, metadataSeparator) {\n        return this.expressions.map((expression)=>expression.evaluate(metadata, metadataSeparator, this.variable)).join(\"\");\n    }\n    isRenderable() {\n        return true;\n    }\n    clone() {\n        return new $ba84a02c63f26e83$var$Composite(this.expressions.map((expression)=>expression.clone()), this.variable);\n    }\n}\nvar $ba84a02c63f26e83$export$2e2bcd8739ae039 = $ba84a02c63f26e83$var$Composite;\n\n\n\nclass $d6f43bad3b61b86a$var$Ternary extends (0, $b5c6143e2fff9a4c$export$2e2bcd8739ae039) {\n    trueExpression = [];\n    falseExpression = [];\n    constructor({ variable: variable = null , valueTest: valueTest = null , trueExpression: trueExpression = [] , falseExpression: falseExpression = [] , line: line = null , column: column = null , offset: offset = null  }){\n        super({\n            line: line,\n            column: column,\n            offset: offset\n        });\n        this.variable = variable || null;\n        this.valueTest = valueTest || null;\n        this.trueExpression = trueExpression;\n        this.falseExpression = falseExpression;\n    }\n    /**\n   * Evaluate the meta expression\n   * @param {Metadata} metadata The metadata object to use for evaluating the expression\n   * @param {string} [metadataSeparator=null] The metadata separator to use if necessary\n   * @returns {string} The evaluated expression\n   */ evaluate(metadata, metadataSeparator, upperContext = null) {\n        if (this.variable) return this.evaluateWithVariable(metadata, metadataSeparator);\n        if (!upperContext) throw new (0, $3fb187494df71568$export$2e2bcd8739ae039)(\"Unexpected empty expression\", this.line, this.column, this.offset);\n        return this.evaluateToString(metadata.get(upperContext) || \"\", metadataSeparator);\n    }\n    evaluateToString(value, metadataSeparator) {\n        if (Array.isArray(value)) return value.join(metadataSeparator);\n        return value;\n    }\n    evaluateWithVariable(metadata, metadataSeparator) {\n        if (!this.variable) throw new Error(\"Expected this.variable to be present\");\n        const value = metadata.get(this.variable);\n        if (value && ((0, $974bd1d260bb1d53$export$78d1711480f95c3e)(this.valueTest) || value === this.valueTest)) return this.evaluateForTruthyValue(metadata, metadataSeparator, value);\n        if (this.falseExpression.length) return new (0, $ba84a02c63f26e83$export$2e2bcd8739ae039)(this.falseExpression, this.variable).evaluate(metadata, metadataSeparator);\n        return \"\";\n    }\n    evaluateForTruthyValue(metadata, metadataSeparator, value) {\n        if (this.trueExpression.length) return new (0, $ba84a02c63f26e83$export$2e2bcd8739ae039)(this.trueExpression, this.variable).evaluate(metadata, metadataSeparator);\n        return this.evaluateToString(value, metadataSeparator);\n    }\n    isRenderable() {\n        return true;\n    }\n    clone() {\n        return new $d6f43bad3b61b86a$var$Ternary({\n            variable: this.variable,\n            valueTest: this.valueTest,\n            trueExpression: this.trueExpression.map((part)=>part.clone()),\n            falseExpression: this.falseExpression.map((part)=>part.clone()),\n            line: this.line,\n            column: this.column,\n            offset: this.offset\n        });\n    }\n}\nvar $d6f43bad3b61b86a$export$2e2bcd8739ae039 = $d6f43bad3b61b86a$var$Ternary;\n\n\n\nconst $2a399cf90c614489$var$CHORD_SHEET = \"chordSheet\";\nconst $2a399cf90c614489$var$CHORD_LYRICS_PAIR = \"chordLyricsPair\";\nconst $2a399cf90c614489$var$TAG = \"tag\";\nconst $2a399cf90c614489$var$COMMENT = \"comment\";\nconst $2a399cf90c614489$var$TERNARY = \"ternary\";\nconst $2a399cf90c614489$var$LINE = \"line\";\n/**\n * Serializes a song into een plain object, and deserializes the serialized object back into a {@link Song}\n */ class $2a399cf90c614489$var$ChordSheetSerializer {\n    song = new (0, $7860c26c4d50915f$export$2e2bcd8739ae039)();\n    /**\n   * Serializes the chord sheet to a plain object, which can be converted to any format like JSON, XML etc\n   * Can be deserialized using {@link deserialize}\n   * @returns object A plain JS object containing all chord sheet data\n   */ serialize(song) {\n        return {\n            type: $2a399cf90c614489$var$CHORD_SHEET,\n            lines: song.lines.map((line)=>this.serializeLine(line))\n        };\n    }\n    serializeLine(line) {\n        return {\n            type: $2a399cf90c614489$var$LINE,\n            items: line.items.map((item)=>this.serializeItem(item))\n        };\n    }\n    serializeItem(item) {\n        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039)) return this.serializeTag(item);\n        if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) return this.serializeChordLyricsPair(item);\n        if (item instanceof (0, $d6f43bad3b61b86a$export$2e2bcd8739ae039)) return this.serializeTernary(item);\n        if (item instanceof (0, $758385c5b662d76d$export$2e2bcd8739ae039)) return this.serializeLiteral(item);\n        throw new Error(`Don't know how to serialize ${item.constructor.name}`);\n    }\n    serializeTag(tag) {\n        return {\n            type: $2a399cf90c614489$var$TAG,\n            name: tag.originalName,\n            value: tag.value\n        };\n    }\n    serializeChordLyricsPair(chordLyricsPair) {\n        return {\n            type: $2a399cf90c614489$var$CHORD_LYRICS_PAIR,\n            chords: chordLyricsPair.chords,\n            chord: null,\n            lyrics: chordLyricsPair.lyrics\n        };\n    }\n    serializeTernary(ternary) {\n        return {\n            type: $2a399cf90c614489$var$TERNARY,\n            variable: ternary.variable,\n            valueTest: ternary.valueTest,\n            trueExpression: this.serializeExpression(ternary.trueExpression),\n            falseExpression: this.serializeExpression(ternary.falseExpression)\n        };\n    }\n    serializeLiteral(literal) {\n        return literal.string;\n    }\n    serializeExpression(expression) {\n        return expression.map((part)=>this.serializeItem(part));\n    }\n    /**\n   * Deserializes a song that has been serialized using {@link serialize}\n   * @param {object} serializedSong The serialized song\n   * @returns {Song} The deserialized song\n   */ deserialize(serializedSong) {\n        this.parseAstComponent(serializedSong);\n        return this.song;\n    }\n    parseAstComponent(astComponent) {\n        if (!astComponent) return null;\n        if (typeof astComponent === \"string\") return new (0, $758385c5b662d76d$export$2e2bcd8739ae039)(astComponent);\n        const { type: type  } = astComponent;\n        switch(type){\n            case $2a399cf90c614489$var$CHORD_SHEET:\n                this.parseChordSheet(astComponent);\n                break;\n            case $2a399cf90c614489$var$CHORD_LYRICS_PAIR:\n                return this.parseChordLyricsPair(astComponent);\n            case $2a399cf90c614489$var$TAG:\n                return this.parseTag(astComponent);\n            case $2a399cf90c614489$var$COMMENT:\n                return this.parseComment(astComponent);\n            case $2a399cf90c614489$var$TERNARY:\n                return this.parseTernary(astComponent);\n            default:\n                console.warn(`Unhandled AST component \"${type}\"`, astComponent);\n        }\n        return null;\n    }\n    parseChordSheet(astComponent) {\n        const { lines: lines  } = astComponent;\n        this.song = new (0, $7860c26c4d50915f$export$2e2bcd8739ae039)();\n        lines.forEach((line)=>this.parseLine(line));\n    }\n    parseLine(astComponent) {\n        const { items: items  } = astComponent;\n        this.song.addLine();\n        items.forEach((item)=>{\n            const parsedItem = this.parseAstComponent(item);\n            this.song.addItem(parsedItem);\n        });\n    }\n    parseChordLyricsPair(astComponent) {\n        const { chord: chord , chords: chords , lyrics: lyrics  } = astComponent;\n        return new (0, $f7a904d05353aafa$export$2e2bcd8739ae039)(chord ? new (0, $5e3a0c5a6197f95b$export$2e2bcd8739ae039)(chord).toString() : chords, lyrics);\n    }\n    parseTag(astComponent) {\n        const { name: name , value: value , location: { offset: offset = null , line: line = null , column: column = null  } = {}  } = astComponent;\n        return new (0, $b3836272a1374d85$export$2e2bcd8739ae039)(name, value, {\n            line: line,\n            column: column,\n            offset: offset\n        });\n    }\n    parseComment(astComponent) {\n        const { comment: comment  } = astComponent;\n        return new (0, $df4ad73a744c94b3$export$2e2bcd8739ae039)(comment);\n    }\n    parseTernary(astComponent) {\n        const { variable: variable , valueTest: valueTest , trueExpression: trueExpression , falseExpression: falseExpression , location: { offset: offset = null , line: line = null , column: column = null  } = {}  } = astComponent;\n        return new (0, $d6f43bad3b61b86a$export$2e2bcd8739ae039)({\n            variable: variable,\n            valueTest: valueTest,\n            trueExpression: this.parseExpression(trueExpression),\n            falseExpression: this.parseExpression(falseExpression),\n            offset: offset,\n            line: line,\n            column: column\n        });\n    }\n    parseExpression(expression) {\n        return (expression || []).map((part)=>this.parseAstComponent(part)).filter((part)=>part !== null);\n    }\n}\nvar $2a399cf90c614489$export$2e2bcd8739ae039 = $2a399cf90c614489$var$ChordSheetSerializer;\n\n\n\n/**\n * Parses a chords over words sheet\n */ class $3e6b6f33997c81b2$var$PegBasedParser {\n    song = new (0, $7860c26c4d50915f$export$2e2bcd8739ae039)();\n    /**\n   * All warnings raised during parsing the chord sheet\n   * @member\n   * @type {ParserWarning[]}\n   */ get warnings() {\n        return this.song.warnings;\n    }\n    parseWithParser(chordSheet, parser) {\n        const ast = parser((0, $974bd1d260bb1d53$export$ba13e0e2f19e61a1)(chordSheet));\n        this.song = new (0, $2a399cf90c614489$export$2e2bcd8739ae039)().deserialize(ast);\n        return this.song;\n    }\n}\nvar $3e6b6f33997c81b2$export$2e2bcd8739ae039 = $3e6b6f33997c81b2$var$PegBasedParser;\n\n\n// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 2.1.0 )\n//\n// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs\n\"use strict\";\nfunction $182dbf639c88db75$var$peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) return str;\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n}\nclass $182dbf639c88db75$export$f21cea08b0dd60e8 extends Error {\n    static buildMessage(expected, found) {\n        function hex(ch) {\n            return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n        function literalEscape(s) {\n            return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, (ch)=>\"\\\\x0\" + hex(ch)).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch)=>\"\\\\x\" + hex(ch));\n        }\n        function classEscape(s) {\n            return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, (ch)=>\"\\\\x0\" + hex(ch)).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch)=>\"\\\\x\" + hex(ch));\n        }\n        function describeExpectation(expectation) {\n            switch(expectation.type){\n                case \"literal\":\n                    return '\"' + literalEscape(expectation.text) + '\"';\n                case \"class\":\n                    const escapedParts = expectation.parts.map((part)=>{\n                        return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n                    });\n                    return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n                case \"any\":\n                    return \"any character\";\n                case \"end\":\n                    return \"end of input\";\n                case \"other\":\n                    return expectation.description;\n            }\n        }\n        function describeExpected(expected1) {\n            const descriptions = expected1.map(describeExpectation);\n            let i;\n            let j;\n            descriptions.sort();\n            if (descriptions.length > 0) {\n                for(i = 1, j = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {\n                    descriptions[j] = descriptions[i];\n                    j++;\n                }\n                descriptions.length = j;\n            }\n            switch(descriptions.length){\n                case 1:\n                    return descriptions[0];\n                case 2:\n                    return descriptions[0] + \" or \" + descriptions[1];\n                default:\n                    return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n            }\n        }\n        function describeFound(found1) {\n            return found1 ? '\"' + literalEscape(found1) + '\"' : \"end of input\";\n        }\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    }\n    constructor(message, expected, found, location){\n        super();\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n        if (typeof Object.setPrototypeOf === \"function\") Object.setPrototypeOf(this, $182dbf639c88db75$export$f21cea08b0dd60e8.prototype);\n        else this.__proto__ = $182dbf639c88db75$export$f21cea08b0dd60e8.prototype;\n        if (typeof Error.captureStackTrace === \"function\") Error.captureStackTrace(this, $182dbf639c88db75$export$f21cea08b0dd60e8);\n    }\n    format(sources) {\n        let str = \"Error: \" + this.message;\n        if (this.location) {\n            let src = null;\n            let k;\n            for(k = 0; k < sources.length; k++)if (sources[k].source === this.location.source) {\n                src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n                break;\n            }\n            let s = this.location.start;\n            let loc = this.location.source + \":\" + s.line + \":\" + s.column;\n            if (src) {\n                let e = this.location.end;\n                let filler = $182dbf639c88db75$var$peg$padEnd(\"\", s.line.toString().length, \" \");\n                let line = src[s.line - 1];\n                let last = s.line === e.line ? e.column : line.length + 1;\n                str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + $182dbf639c88db75$var$peg$padEnd(\"\", s.column - 1, \" \") + $182dbf639c88db75$var$peg$padEnd(\"\", last - s.column, \"^\");\n            } else str += \"\\n at \" + loc;\n        }\n        return str;\n    }\n}\nfunction $182dbf639c88db75$var$peg$parse(input, options) {\n    options = options !== undefined ? options : {};\n    const peg$FAILED = {};\n    const peg$source = options.grammarSource;\n    const peg$startRuleFunctions = {\n        ChordSheet: peg$parseChordSheet\n    };\n    let peg$startRuleFunction = peg$parseChordSheet;\n    const peg$c0 = function(lines, line) {\n        return {\n            type: \"chordSheet\",\n            lines: [\n                ...lines,\n                line\n            ]\n        };\n    };\n    const peg$c1 = function(line) {\n        return line;\n    };\n    const peg$c2 = function(lyrics, tokens, chords, comment) {\n        return {\n            type: \"line\",\n            items: [\n                lyrics ? {\n                    type: \"chordLyricsPair\",\n                    chords: \"\",\n                    lyrics: lyrics\n                } : null,\n                ...tokens,\n                chords ? {\n                    type: \"chordLyricsPair\",\n                    chords: chords,\n                    lyrics: \"\"\n                } : null,\n                comment ? {\n                    type: \"comment\",\n                    comment: comment\n                } : null\n            ].filter((x)=>x)\n        };\n    };\n    const peg$c3 = function(lyrics) {\n        return {\n            type: \"chordLyricsPair\",\n            chords: \"\",\n            lyrics: lyrics\n        };\n    };\n    const peg$c4 = \"#\";\n    const peg$c5 = peg$literalExpectation(\"#\", false);\n    const peg$c6 = /^[^\\r\\n]/;\n    const peg$c7 = peg$classExpectation([\n        \"\\r\",\n        \"\\n\"\n    ], true, false);\n    const peg$c8 = function(comment) {\n        return comment;\n    };\n    const peg$c9 = function(chords, lyrics, space) {\n        return {\n            type: \"chordLyricsPair\",\n            chords: chords || \"\",\n            lyrics: lyrics + (space || \"\")\n        };\n    };\n    const peg$c10 = function(lyrics) {\n        return lyrics.map((c)=>c.char || c).join(\"\");\n    };\n    const peg$c11 = \"[\";\n    const peg$c12 = peg$literalExpectation(\"[\", false);\n    const peg$c13 = \"]\";\n    const peg$c14 = peg$literalExpectation(\"]\", false);\n    const peg$c15 = function(chords) {\n        return chords.map((c)=>c.char || c).join(\"\");\n    };\n    const peg$c16 = /^[^\\]\\r\\n]/;\n    const peg$c17 = peg$classExpectation([\n        \"]\",\n        \"\\r\",\n        \"\\n\"\n    ], true, false);\n    const peg$c18 = \"\\\\\";\n    const peg$c19 = peg$literalExpectation(\"\\\\\", false);\n    const peg$c20 = function() {\n        return {\n            type: \"char\",\n            char: \"\\\\\"\n        };\n    };\n    const peg$c21 = function() {\n        return {\n            type: \"char\",\n            char: \"]\"\n        };\n    };\n    const peg$c22 = function(sequence) {\n        return sequence;\n    };\n    const peg$c23 = \"%{\";\n    const peg$c24 = peg$literalExpectation(\"%{\", false);\n    const peg$c25 = \"}\";\n    const peg$c26 = peg$literalExpectation(\"}\", false);\n    const peg$c27 = function(variableName, valueTest, expressions) {\n        return {\n            type: \"ternary\",\n            variable: variableName.length > 0 ? variableName : null,\n            valueTest: valueTest,\n            ...expressions,\n            location: location().start\n        };\n    };\n    const peg$c28 = \"=\";\n    const peg$c29 = peg$literalExpectation(\"=\", false);\n    const peg$c30 = function(testValue) {\n        return testValue;\n    };\n    const peg$c31 = \"|\";\n    const peg$c32 = peg$literalExpectation(\"|\", false);\n    const peg$c33 = function(trueExpression, falseExpression) {\n        return {\n            type: \"ternary\",\n            trueExpression: trueExpression,\n            falseExpression: falseExpression,\n            location: location().start\n        };\n    };\n    const peg$c34 = function(falseExpression) {\n        return falseExpression;\n    };\n    const peg$c35 = /^[a-zA-Z0-9\\-_]/;\n    const peg$c36 = peg$classExpectation([\n        [\n            \"a\",\n            \"z\"\n        ],\n        [\n            \"A\",\n            \"Z\"\n        ],\n        [\n            \"0\",\n            \"9\"\n        ],\n        \"-\",\n        \"_\"\n    ], false, false);\n    const peg$c37 = function() {\n        return {\n            type: \"char\",\n            char: \"]\"\n        };\n    };\n    const peg$c38 = function() {\n        return {\n            type: \"char\",\n            char: \"|\"\n        };\n    };\n    const peg$c39 = function() {\n        return {\n            type: \"char\",\n            char: \"}\"\n        };\n    };\n    const peg$c40 = /^[^|[\\]\\\\{}%#\\r\\n\\t ]/;\n    const peg$c41 = peg$classExpectation([\n        \"|\",\n        \"[\",\n        \"]\",\n        \"\\\\\",\n        \"{\",\n        \"}\",\n        \"%\",\n        \"#\",\n        \"\\r\",\n        \"\\n\",\n        \"\t\",\n        \" \"\n    ], true, false);\n    const peg$c42 = function() {\n        return {\n            type: \"char\",\n            char: \"\\\\\"\n        };\n    };\n    const peg$c43 = function() {\n        return {\n            type: \"char\",\n            char: \"[\"\n        };\n    };\n    const peg$c44 = \"{\";\n    const peg$c45 = peg$literalExpectation(\"{\", false);\n    const peg$c46 = function() {\n        return {\n            type: \"char\",\n            char: \"{\"\n        };\n    };\n    const peg$c47 = \"%\";\n    const peg$c48 = peg$literalExpectation(\"%\", false);\n    const peg$c49 = function() {\n        return {\n            type: \"char\",\n            char: \"%\"\n        };\n    };\n    const peg$c50 = function() {\n        return {\n            type: \"char\",\n            char: \"#\"\n        };\n    };\n    const peg$c51 = function(tagName, tagColonWithValue) {\n        return {\n            type: \"tag\",\n            name: tagName,\n            value: tagColonWithValue,\n            location: location().start\n        };\n    };\n    const peg$c52 = \":\";\n    const peg$c53 = peg$literalExpectation(\":\", false);\n    const peg$c54 = function(tagValue) {\n        return tagValue.map((c)=>c.char || c).join(\"\");\n    };\n    const peg$c55 = /^[a-zA-Z\\-_]/;\n    const peg$c56 = peg$classExpectation([\n        [\n            \"a\",\n            \"z\"\n        ],\n        [\n            \"A\",\n            \"Z\"\n        ],\n        \"-\",\n        \"_\"\n    ], false, false);\n    const peg$c57 = /^[^}\\\\\\r\\n]/;\n    const peg$c58 = peg$classExpectation([\n        \"}\",\n        \"\\\\\",\n        \"\\r\",\n        \"\\n\"\n    ], true, false);\n    const peg$c59 = peg$otherExpectation(\"whitespace\");\n    const peg$c60 = /^[ \\t\\n\\r]/;\n    const peg$c61 = peg$classExpectation([\n        \" \",\n        \"\t\",\n        \"\\n\",\n        \"\\r\"\n    ], false, false);\n    const peg$c62 = peg$otherExpectation(\"space\");\n    const peg$c63 = /^[ \\t]/;\n    const peg$c64 = peg$classExpectation([\n        \" \",\n        \"\t\"\n    ], false, false);\n    const peg$c65 = \"\\n\";\n    const peg$c66 = peg$literalExpectation(\"\\n\", false);\n    const peg$c67 = \"\\r\";\n    const peg$c68 = peg$literalExpectation(\"\\r\", false);\n    let peg$currPos = 0;\n    let peg$savedPos = 0;\n    const peg$posDetailsCache = [\n        {\n            line: 1,\n            column: 1\n        }\n    ];\n    let peg$maxFailPos = 0;\n    let peg$maxFailExpected = [];\n    let peg$silentFails = 0;\n    let peg$result;\n    if (options.startRule !== undefined) {\n        if (!(options.startRule in peg$startRuleFunctions)) throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + '\".');\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n    }\n    function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location1) {\n        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError([\n            peg$otherExpectation(description)\n        ], input.substring(peg$savedPos, peg$currPos), location1);\n    }\n    function error(message, location1) {\n        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location1);\n    }\n    function peg$literalExpectation(text1, ignoreCase) {\n        return {\n            type: \"literal\",\n            text: text1,\n            ignoreCase: ignoreCase\n        };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n        return {\n            type: \"class\",\n            parts: parts,\n            inverted: inverted,\n            ignoreCase: ignoreCase\n        };\n    }\n    function peg$anyExpectation() {\n        return {\n            type: \"any\"\n        };\n    }\n    function peg$endExpectation() {\n        return {\n            type: \"end\"\n        };\n    }\n    function peg$otherExpectation(description) {\n        return {\n            type: \"other\",\n            description: description\n        };\n    }\n    function peg$computePosDetails(pos) {\n        let details = peg$posDetailsCache[pos];\n        let p;\n        if (details) return details;\n        else {\n            p = pos - 1;\n            while(!peg$posDetailsCache[p])p--;\n            details = peg$posDetailsCache[p];\n            details = {\n                line: details.line,\n                column: details.column\n            };\n            while(p < pos){\n                if (input.charCodeAt(p) === 10) {\n                    details.line++;\n                    details.column = 1;\n                } else details.column++;\n                p++;\n            }\n            peg$posDetailsCache[pos] = details;\n            return details;\n        }\n    }\n    function peg$computeLocation(startPos, endPos) {\n        const startPosDetails = peg$computePosDetails(startPos);\n        const endPosDetails = peg$computePosDetails(endPos);\n        return {\n            source: peg$source,\n            start: {\n                offset: startPos,\n                line: startPosDetails.line,\n                column: startPosDetails.column\n            },\n            end: {\n                offset: endPos,\n                line: endPosDetails.line,\n                column: endPosDetails.column\n            }\n        };\n    }\n    function peg$fail(expected1) {\n        if (peg$currPos < peg$maxFailPos) return;\n        if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected1);\n    }\n    function peg$buildSimpleError(message, location1) {\n        return new $182dbf639c88db75$export$f21cea08b0dd60e8(message, [], \"\", location1);\n    }\n    function peg$buildStructuredError(expected1, found, location1) {\n        return new $182dbf639c88db75$export$f21cea08b0dd60e8($182dbf639c88db75$export$f21cea08b0dd60e8.buildMessage(expected1, found), expected1, found, location1);\n    }\n    function peg$parseChordSheet() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseLineWithNewline();\n        while(s2 !== peg$FAILED){\n            s1.push(s2);\n            s2 = peg$parseLineWithNewline();\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseLine();\n            if (s2 === peg$FAILED) s2 = null;\n            if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c0(s1, s2);\n                s0 = s1;\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseLineWithNewline() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseLine();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseNewLine();\n            if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c1(s1);\n                s0 = s1;\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseLine() {\n        let s0, s1, s2, s3, s4, s5, s6;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$parseLyrics();\n        if (s2 === peg$FAILED) s2 = null;\n        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);\n        else s1 = s2;\n        if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parseToken();\n            while(s3 !== peg$FAILED){\n                s2.push(s3);\n                s3 = peg$parseToken();\n            }\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseChord();\n                if (s3 === peg$FAILED) s3 = null;\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parseComment();\n                    if (s4 === peg$FAILED) s4 = null;\n                    if (s4 !== peg$FAILED) {\n                        s5 = [];\n                        s6 = peg$parseSpace();\n                        while(s6 !== peg$FAILED){\n                            s5.push(s6);\n                            s6 = peg$parseSpace();\n                        }\n                        if (s5 !== peg$FAILED) {\n                            peg$savedPos = s0;\n                            s1 = peg$c2(s1, s2, s3, s4);\n                            s0 = s1;\n                        } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseToken() {\n        let s0, s1;\n        s0 = peg$parseTag();\n        if (s0 === peg$FAILED) {\n            s0 = peg$parseChordLyricsPair();\n            if (s0 === peg$FAILED) {\n                s0 = peg$parseMetaTernary();\n                if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    s1 = peg$parseLyrics();\n                    if (s1 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c3(s1);\n                    }\n                    s0 = s1;\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parseComment() {\n        let s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = peg$parseSpace();\n        if (s1 === peg$FAILED) s1 = null;\n        if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 35) {\n                s2 = peg$c4;\n                peg$currPos++;\n            } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c5);\n            }\n            if (s2 !== peg$FAILED) {\n                s3 = peg$currPos;\n                s4 = [];\n                if (peg$c6.test(input.charAt(peg$currPos))) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) peg$fail(peg$c7);\n                }\n                while(s5 !== peg$FAILED){\n                    s4.push(s5);\n                    if (peg$c6.test(input.charAt(peg$currPos))) {\n                        s5 = input.charAt(peg$currPos);\n                        peg$currPos++;\n                    } else {\n                        s5 = peg$FAILED;\n                        if (peg$silentFails === 0) peg$fail(peg$c7);\n                    }\n                }\n                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);\n                else s3 = s4;\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c8(s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseChordLyricsPair() {\n        let s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        s1 = peg$parseChord();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = [];\n            s4 = peg$parseLyricsChar();\n            while(s4 !== peg$FAILED){\n                s3.push(s4);\n                s4 = peg$parseLyricsChar();\n            }\n            if (s3 !== peg$FAILED) s2 = input.substring(s2, peg$currPos);\n            else s2 = s3;\n            if (s2 !== peg$FAILED) {\n                s3 = peg$currPos;\n                s4 = [];\n                s5 = peg$parseSpace();\n                while(s5 !== peg$FAILED){\n                    s4.push(s5);\n                    s5 = peg$parseSpace();\n                }\n                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);\n                else s3 = s4;\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c9(s1, s2, s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseLyrics() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseLyricsCharOrSpace();\n        if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){\n            s1.push(s2);\n            s2 = peg$parseLyricsCharOrSpace();\n        }\n        else s1 = peg$FAILED;\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c10(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parseLyricsCharOrSpace() {\n        let s0;\n        s0 = peg$parseLyricsChar();\n        if (s0 === peg$FAILED) s0 = peg$parseSpace();\n        return s0;\n    }\n    function peg$parseChord() {\n        let s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        peg$silentFails++;\n        s2 = peg$parseEscape();\n        peg$silentFails--;\n        if (s2 === peg$FAILED) s1 = undefined;\n        else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n        }\n        if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 91) {\n                s2 = peg$c11;\n                peg$currPos++;\n            } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c12);\n            }\n            if (s2 !== peg$FAILED) {\n                s3 = [];\n                s4 = peg$parseChordChar();\n                while(s4 !== peg$FAILED){\n                    s3.push(s4);\n                    s4 = peg$parseChordChar();\n                }\n                if (s3 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                        s4 = peg$c13;\n                        peg$currPos++;\n                    } else {\n                        s4 = peg$FAILED;\n                        if (peg$silentFails === 0) peg$fail(peg$c14);\n                    }\n                    if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c15(s3);\n                        s0 = s1;\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseChordChar() {\n        let s0, s1, s2, s3;\n        if (peg$c16.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c17);\n        }\n        if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseEscape();\n            if (s1 !== peg$FAILED) {\n                s2 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 92) {\n                    s3 = peg$c18;\n                    peg$currPos++;\n                } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) peg$fail(peg$c19);\n                }\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s2;\n                    s3 = peg$c20();\n                }\n                s2 = s3;\n                if (s2 === peg$FAILED) {\n                    s2 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                        s3 = peg$c13;\n                        peg$currPos++;\n                    } else {\n                        s3 = peg$FAILED;\n                        if (peg$silentFails === 0) peg$fail(peg$c14);\n                    }\n                    if (s3 !== peg$FAILED) {\n                        peg$savedPos = s2;\n                        s3 = peg$c21();\n                    }\n                    s2 = s3;\n                }\n                if (s2 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c22(s2);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        return s0;\n    }\n    function peg$parseMetaTernary() {\n        let s0, s1, s2, s3, s4, s5, s6, s7, s8;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 2) === peg$c23) {\n            s1 = peg$c23;\n            peg$currPos += 2;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c24);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$currPos;\n                s4 = peg$parseMetaVariableName();\n                if (s4 === peg$FAILED) s4 = null;\n                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);\n                else s3 = s4;\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parseMetaValueTest();\n                    if (s4 === peg$FAILED) s4 = null;\n                    if (s4 !== peg$FAILED) {\n                        s5 = peg$parse_();\n                        if (s5 !== peg$FAILED) {\n                            s6 = peg$parseMetaTernaryTrueFalseExpressions();\n                            if (s6 === peg$FAILED) s6 = null;\n                            if (s6 !== peg$FAILED) {\n                                s7 = peg$parse_();\n                                if (s7 !== peg$FAILED) {\n                                    if (input.charCodeAt(peg$currPos) === 125) {\n                                        s8 = peg$c25;\n                                        peg$currPos++;\n                                    } else {\n                                        s8 = peg$FAILED;\n                                        if (peg$silentFails === 0) peg$fail(peg$c26);\n                                    }\n                                    if (s8 !== peg$FAILED) {\n                                        peg$savedPos = s0;\n                                        s1 = peg$c27(s3, s4, s6);\n                                        s0 = s1;\n                                    } else {\n                                        peg$currPos = s0;\n                                        s0 = peg$FAILED;\n                                    }\n                                } else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseMetaValueTest() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 61) {\n            s1 = peg$c28;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c29);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseMetaTestValue();\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c30(s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseMetaTestValue() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseChar();\n        if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){\n            s1.push(s2);\n            s2 = peg$parseChar();\n        }\n        else s1 = peg$FAILED;\n        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);\n        else s0 = s1;\n        return s0;\n    }\n    function peg$parseMetaTernaryTrueFalseExpressions() {\n        let s0, s1, s2, s3, s4, s5, s6;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 124) {\n            s1 = peg$c31;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c32);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseMetaExpression();\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                        s5 = peg$parseMetaTernaryFalseExpression();\n                        if (s5 === peg$FAILED) s5 = null;\n                        if (s5 !== peg$FAILED) {\n                            s6 = peg$parse_();\n                            if (s6 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s1 = peg$c33(s3, s5);\n                                s0 = s1;\n                            } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseMetaTernaryFalseExpression() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 124) {\n            s1 = peg$c31;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c32);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseMetaExpression();\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c34(s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseMetaVariableName() {\n        let s0, s1;\n        s0 = [];\n        if (peg$c35.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c36);\n        }\n        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){\n            s0.push(s1);\n            if (peg$c35.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c36);\n            }\n        }\n        else s0 = peg$FAILED;\n        return s0;\n    }\n    function peg$parseMetaExpression() {\n        let s0, s1, s2, s3;\n        s0 = [];\n        s1 = peg$currPos;\n        s2 = [];\n        s3 = peg$parseChar();\n        if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){\n            s2.push(s3);\n            s3 = peg$parseChar();\n        }\n        else s2 = peg$FAILED;\n        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);\n        else s1 = s2;\n        if (s1 === peg$FAILED) s1 = peg$parseMetaTernary();\n        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){\n            s0.push(s1);\n            s1 = peg$currPos;\n            s2 = [];\n            s3 = peg$parseChar();\n            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){\n                s2.push(s3);\n                s3 = peg$parseChar();\n            }\n            else s2 = peg$FAILED;\n            if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);\n            else s1 = s2;\n            if (s1 === peg$FAILED) s1 = peg$parseMetaTernary();\n        }\n        else s0 = peg$FAILED;\n        return s0;\n    }\n    function peg$parseLyricsChar() {\n        let s0, s1;\n        s0 = peg$parseWordChar();\n        if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 93) {\n                s1 = peg$c13;\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c14);\n            }\n            if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c37();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 124) {\n                    s1 = peg$c31;\n                    peg$currPos++;\n                } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) peg$fail(peg$c32);\n                }\n                if (s1 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c38();\n                }\n                s0 = s1;\n                if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 125) {\n                        s1 = peg$c25;\n                        peg$currPos++;\n                    } else {\n                        s1 = peg$FAILED;\n                        if (peg$silentFails === 0) peg$fail(peg$c26);\n                    }\n                    if (s1 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c39();\n                    }\n                    s0 = s1;\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parseChar() {\n        let s0;\n        s0 = peg$parseWordChar();\n        if (s0 === peg$FAILED) s0 = peg$parseSpace();\n        return s0;\n    }\n    function peg$parseWordChar() {\n        let s0, s1, s2, s3;\n        if (peg$c40.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c41);\n        }\n        if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseEscape();\n            if (s1 !== peg$FAILED) {\n                s2 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 92) {\n                    s3 = peg$c18;\n                    peg$currPos++;\n                } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) peg$fail(peg$c19);\n                }\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s2;\n                    s3 = peg$c42();\n                }\n                s2 = s3;\n                if (s2 === peg$FAILED) {\n                    s2 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 124) {\n                        s3 = peg$c31;\n                        peg$currPos++;\n                    } else {\n                        s3 = peg$FAILED;\n                        if (peg$silentFails === 0) peg$fail(peg$c32);\n                    }\n                    if (s3 !== peg$FAILED) {\n                        peg$savedPos = s2;\n                        s3 = peg$c38();\n                    }\n                    s2 = s3;\n                    if (s2 === peg$FAILED) {\n                        s2 = peg$currPos;\n                        if (input.charCodeAt(peg$currPos) === 91) {\n                            s3 = peg$c11;\n                            peg$currPos++;\n                        } else {\n                            s3 = peg$FAILED;\n                            if (peg$silentFails === 0) peg$fail(peg$c12);\n                        }\n                        if (s3 !== peg$FAILED) {\n                            peg$savedPos = s2;\n                            s3 = peg$c43();\n                        }\n                        s2 = s3;\n                        if (s2 === peg$FAILED) {\n                            s2 = peg$currPos;\n                            if (input.charCodeAt(peg$currPos) === 93) {\n                                s3 = peg$c13;\n                                peg$currPos++;\n                            } else {\n                                s3 = peg$FAILED;\n                                if (peg$silentFails === 0) peg$fail(peg$c14);\n                            }\n                            if (s3 !== peg$FAILED) {\n                                peg$savedPos = s2;\n                                s3 = peg$c37();\n                            }\n                            s2 = s3;\n                            if (s2 === peg$FAILED) {\n                                s2 = peg$currPos;\n                                if (input.charCodeAt(peg$currPos) === 123) {\n                                    s3 = peg$c44;\n                                    peg$currPos++;\n                                } else {\n                                    s3 = peg$FAILED;\n                                    if (peg$silentFails === 0) peg$fail(peg$c45);\n                                }\n                                if (s3 !== peg$FAILED) {\n                                    peg$savedPos = s2;\n                                    s3 = peg$c46();\n                                }\n                                s2 = s3;\n                                if (s2 === peg$FAILED) {\n                                    s2 = peg$currPos;\n                                    if (input.charCodeAt(peg$currPos) === 125) {\n                                        s3 = peg$c25;\n                                        peg$currPos++;\n                                    } else {\n                                        s3 = peg$FAILED;\n                                        if (peg$silentFails === 0) peg$fail(peg$c26);\n                                    }\n                                    if (s3 !== peg$FAILED) {\n                                        peg$savedPos = s2;\n                                        s3 = peg$c39();\n                                    }\n                                    s2 = s3;\n                                    if (s2 === peg$FAILED) {\n                                        s2 = peg$currPos;\n                                        if (input.charCodeAt(peg$currPos) === 37) {\n                                            s3 = peg$c47;\n                                            peg$currPos++;\n                                        } else {\n                                            s3 = peg$FAILED;\n                                            if (peg$silentFails === 0) peg$fail(peg$c48);\n                                        }\n                                        if (s3 !== peg$FAILED) {\n                                            peg$savedPos = s2;\n                                            s3 = peg$c49();\n                                        }\n                                        s2 = s3;\n                                        if (s2 === peg$FAILED) {\n                                            s2 = peg$currPos;\n                                            if (input.charCodeAt(peg$currPos) === 35) {\n                                                s3 = peg$c4;\n                                                peg$currPos++;\n                                            } else {\n                                                s3 = peg$FAILED;\n                                                if (peg$silentFails === 0) peg$fail(peg$c5);\n                                            }\n                                            if (s3 !== peg$FAILED) {\n                                                peg$savedPos = s2;\n                                                s3 = peg$c50();\n                                            }\n                                            s2 = s3;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (s2 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c22(s2);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        return s0;\n    }\n    function peg$parseTag() {\n        let s0, s1, s2, s3, s4, s5, s6, s7;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 123) {\n            s1 = peg$c44;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c45);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$currPos;\n                s4 = peg$parseTagName();\n                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);\n                else s3 = s4;\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                        s5 = peg$parseTagColonWithValue();\n                        if (s5 === peg$FAILED) s5 = null;\n                        if (s5 !== peg$FAILED) {\n                            s6 = peg$parse_();\n                            if (s6 !== peg$FAILED) {\n                                if (input.charCodeAt(peg$currPos) === 125) {\n                                    s7 = peg$c25;\n                                    peg$currPos++;\n                                } else {\n                                    s7 = peg$FAILED;\n                                    if (peg$silentFails === 0) peg$fail(peg$c26);\n                                }\n                                if (s7 !== peg$FAILED) {\n                                    peg$savedPos = s0;\n                                    s1 = peg$c51(s3, s5);\n                                    s0 = s1;\n                                } else {\n                                    peg$currPos = s0;\n                                    s0 = peg$FAILED;\n                                }\n                            } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                            }\n                        } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseTagColonWithValue() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 58) {\n            s1 = peg$c52;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c53);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseTagValue();\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c54(s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseTagName() {\n        let s0, s1;\n        s0 = [];\n        if (peg$c55.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c56);\n        }\n        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){\n            s0.push(s1);\n            if (peg$c55.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c56);\n            }\n        }\n        else s0 = peg$FAILED;\n        return s0;\n    }\n    function peg$parseTagValue() {\n        let s0, s1;\n        s0 = [];\n        s1 = peg$parseTagValueChar();\n        while(s1 !== peg$FAILED){\n            s0.push(s1);\n            s1 = peg$parseTagValueChar();\n        }\n        return s0;\n    }\n    function peg$parseTagValueChar() {\n        let s0, s1, s2, s3;\n        if (peg$c57.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c58);\n        }\n        if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseEscape();\n            if (s1 !== peg$FAILED) {\n                s2 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 92) {\n                    s3 = peg$c18;\n                    peg$currPos++;\n                } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) peg$fail(peg$c19);\n                }\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s2;\n                    s3 = peg$c42();\n                }\n                s2 = s3;\n                if (s2 === peg$FAILED) {\n                    s2 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 125) {\n                        s3 = peg$c25;\n                        peg$currPos++;\n                    } else {\n                        s3 = peg$FAILED;\n                        if (peg$silentFails === 0) peg$fail(peg$c26);\n                    }\n                    if (s3 !== peg$FAILED) {\n                        peg$savedPos = s2;\n                        s3 = peg$c39();\n                    }\n                    s2 = s3;\n                    if (s2 === peg$FAILED) {\n                        s2 = peg$currPos;\n                        if (input.charCodeAt(peg$currPos) === 123) {\n                            s3 = peg$c44;\n                            peg$currPos++;\n                        } else {\n                            s3 = peg$FAILED;\n                            if (peg$silentFails === 0) peg$fail(peg$c45);\n                        }\n                        if (s3 !== peg$FAILED) {\n                            peg$savedPos = s2;\n                            s3 = peg$c46();\n                        }\n                        s2 = s3;\n                    }\n                }\n                if (s2 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c22(s2);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        }\n        return s0;\n    }\n    function peg$parse_() {\n        let s0, s1;\n        peg$silentFails++;\n        s0 = [];\n        if (peg$c60.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c61);\n        }\n        while(s1 !== peg$FAILED){\n            s0.push(s1);\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c61);\n            }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c59);\n        }\n        return s0;\n    }\n    function peg$parseSpace() {\n        let s0, s1;\n        peg$silentFails++;\n        s0 = [];\n        if (peg$c63.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c64);\n        }\n        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){\n            s0.push(s1);\n            if (peg$c63.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c64);\n            }\n        }\n        else s0 = peg$FAILED;\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c62);\n        }\n        return s0;\n    }\n    function peg$parseNewLine() {\n        let s0;\n        s0 = peg$parseCarriageReturn();\n        if (s0 === peg$FAILED) {\n            s0 = peg$parseLineFeed();\n            if (s0 === peg$FAILED) s0 = peg$parseCarriageReturnLineFeed();\n        }\n        return s0;\n    }\n    function peg$parseCarriageReturnLineFeed() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseCarriageReturn();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseLineFeed();\n            if (s2 !== peg$FAILED) {\n                s1 = [\n                    s1,\n                    s2\n                ];\n                s0 = s1;\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseLineFeed() {\n        let s0;\n        if (input.charCodeAt(peg$currPos) === 10) {\n            s0 = peg$c65;\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c66);\n        }\n        return s0;\n    }\n    function peg$parseCarriageReturn() {\n        let s0;\n        if (input.charCodeAt(peg$currPos) === 13) {\n            s0 = peg$c67;\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c68);\n        }\n        return s0;\n    }\n    function peg$parseEscape() {\n        let s0;\n        if (input.charCodeAt(peg$currPos) === 92) {\n            s0 = peg$c18;\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c19);\n        }\n        return s0;\n    }\n    function peg$parsePound() {\n        let s0;\n        if (input.charCodeAt(peg$currPos) === 35) {\n            s0 = peg$c4;\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c5);\n        }\n        return s0;\n    }\n    function peg$parsePercent() {\n        let s0;\n        if (input.charCodeAt(peg$currPos) === 37) {\n            s0 = peg$c47;\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c48);\n        }\n        return s0;\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;\n    else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());\n        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n}\nconst $182dbf639c88db75$export$98e6a39c04603d36 = $182dbf639c88db75$var$peg$parse;\n\n\n/**\n * Parses a ChordPro chord sheet\n */ class $8e2b91641771a21c$var$ChordProParser extends (0, $3e6b6f33997c81b2$export$2e2bcd8739ae039) {\n    /**\n   * Parses a ChordPro chord sheet into a song\n   * @param {string} chordProChordSheet the ChordPro chord sheet\n   * @returns {Song} The parsed song\n   */ parse(chordProChordSheet) {\n        return this.parseWithParser(chordProChordSheet, (0, $182dbf639c88db75$export$98e6a39c04603d36));\n    }\n}\nvar $8e2b91641771a21c$export$2e2bcd8739ae039 = $8e2b91641771a21c$var$ChordProParser;\n\n\n\n\nconst $9c17b505581d81bb$var$WHITE_SPACE = /\\s/;\nconst $9c17b505581d81bb$var$CHORD_LINE_REGEX = /^\\s*((([A-G])(#|b)?([^/\\s]*)(\\/([A-G])(#|b)?)?)(\\s|$)+)+(\\s|$)+/;\n/**\n * Parses a normal chord sheet\n *\n * ChordSheetParser is deprecated, please use ChordsOverWordsParser.\n *\n * ChordsOverWordsParser aims to support any kind of chord, whereas ChordSheetParser lacks\n * support for many variations. Besides that, some chordpro feature have been ported back\n * to ChordsOverWordsParser, which adds some interesting functionality.\n */ class $9c17b505581d81bb$var$ChordSheetParser {\n    processingText = true;\n    preserveWhitespace = true;\n    song = new (0, $7860c26c4d50915f$export$2e2bcd8739ae039)();\n    songLine = null;\n    chordLyricsPair = null;\n    lines = [];\n    currentLine = 0;\n    lineCount = 0;\n    /**\n   * Instantiate a chord sheet parser\n   * ChordSheetParser is deprecated, please use ChordsOverWordsParser.\n   * @param {Object} [options={}] options\n   * @param {boolean} [options.preserveWhitespace=true] whether to preserve trailing whitespace for chords\n   * @deprecated\n   */ constructor({ preserveWhitespace: preserveWhitespace = true  } = {}){\n        (0, $974bd1d260bb1d53$export$b680e6b2c82f8c2f)(`ChordSheetParser is deprecated, please use ChordsOverWordsParser. \n\nChordsOverWordsParser aims to support any kind of chord, whereas ChordSheetParser lacks \nsupport for many variations. Besides that, some chordpro feature have been ported back \nto ChordsOverWordsParser, which adds some interesting functionality.`);\n        this.preserveWhitespace = preserveWhitespace;\n    }\n    /**\n   * Parses a chord sheet into a song\n   * @param {string} chordSheet The ChordPro chord sheet\n   * @param {Object} [options={}] Optional parser options\n   * @param {Song} [options.song=null] The {@link Song} to store the song data in\n   * @returns {Song} The parsed song\n   */ parse(chordSheet, { song: song  } = {}) {\n        this.initialize(chordSheet, song);\n        while(this.hasNextLine()){\n            const line = this.readLine();\n            this.parseLine(line);\n        }\n        this.endOfSong();\n        return this.song;\n    }\n    endOfSong() {}\n    parseLine(line) {\n        this.songLine = this.song.addLine();\n        if (line.trim().length === 0) this.chordLyricsPair = null;\n        else this.parseNonEmptyLine(line);\n    }\n    parseNonEmptyLine(line) {\n        if (!this.songLine) throw new Error(\"Expected this.songLine to be present\");\n        this.chordLyricsPair = this.songLine.addChordLyricsPair();\n        if ($9c17b505581d81bb$var$CHORD_LINE_REGEX.test(line) && this.hasNextLine()) {\n            const nextLine = this.readLine();\n            this.parseLyricsWithChords(line, nextLine);\n        } else this.chordLyricsPair.lyrics = `${line}`;\n    }\n    initialize(document, song = null) {\n        if (song) this.song = song;\n        this.lines = (0, $974bd1d260bb1d53$export$ba13e0e2f19e61a1)(document).split(\"\\n\");\n        this.currentLine = 0;\n        this.lineCount = this.lines.length;\n        this.processingText = true;\n    }\n    readLine() {\n        const line = this.lines[this.currentLine];\n        this.currentLine += 1;\n        return line;\n    }\n    hasNextLine() {\n        return this.currentLine < this.lineCount;\n    }\n    parseLyricsWithChords(chordsLine, lyricsLine) {\n        this.processCharacters(chordsLine, lyricsLine);\n        if (!this.chordLyricsPair) throw new Error(\"Expected this.chordLyricsPair to be present\");\n        this.chordLyricsPair.lyrics += lyricsLine.substring(chordsLine.length);\n        this.chordLyricsPair.chords = this.chordLyricsPair.chords.trim();\n        if (this.chordLyricsPair.lyrics) this.chordLyricsPair.lyrics = this.chordLyricsPair.lyrics.trim();\n        if (!lyricsLine.trim().length) this.songLine = this.song.addLine();\n    }\n    processCharacters(chordsLine, lyricsLine) {\n        for(let c = 0, charCount = chordsLine.length; c < charCount; c += 1){\n            const chr = chordsLine[c];\n            const nextChar = chordsLine[c + 1];\n            const isWhiteSpace = $9c17b505581d81bb$var$WHITE_SPACE.test(chr);\n            this.addCharacter(chr, nextChar);\n            if (!this.chordLyricsPair) throw new Error(\"Expected this.chordLyricsPair to be present\");\n            this.chordLyricsPair.lyrics += lyricsLine[c] || \"\";\n            this.processingText = !isWhiteSpace;\n        }\n    }\n    addCharacter(chr, nextChar) {\n        const isWhiteSpace = $9c17b505581d81bb$var$WHITE_SPACE.test(chr);\n        if (!isWhiteSpace) this.ensureChordLyricsPairInitialized();\n        if (!isWhiteSpace || this.shouldAddCharacterToChords(nextChar)) {\n            if (!this.chordLyricsPair) throw new Error(\"Expected this.chordLyricsPair to be present\");\n            this.chordLyricsPair.chords += chr;\n        }\n    }\n    shouldAddCharacterToChords(nextChar) {\n        return nextChar && $9c17b505581d81bb$var$WHITE_SPACE.test(nextChar) && this.preserveWhitespace;\n    }\n    ensureChordLyricsPairInitialized() {\n        if (!this.processingText) {\n            if (!this.songLine) throw new Error(\"Expected this.songLine to be present\");\n            this.chordLyricsPair = this.songLine.addChordLyricsPair();\n            this.processingText = true;\n        }\n    }\n}\nvar $9c17b505581d81bb$export$2e2bcd8739ae039 = $9c17b505581d81bb$var$ChordSheetParser;\n\n\n\n// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 2.1.0 )\n//\n// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs\n\"use strict\";\nfunction $524984546aa7a02b$var$peg$padEnd(str, targetLength, padString) {\n    padString = padString || \" \";\n    if (str.length > targetLength) return str;\n    targetLength -= str.length;\n    padString += padString.repeat(targetLength);\n    return str + padString.slice(0, targetLength);\n}\nclass $524984546aa7a02b$export$f21cea08b0dd60e8 extends Error {\n    static buildMessage(expected, found) {\n        function hex(ch) {\n            return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n        function literalEscape(s) {\n            return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, (ch)=>\"\\\\x0\" + hex(ch)).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch)=>\"\\\\x\" + hex(ch));\n        }\n        function classEscape(s) {\n            return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, (ch)=>\"\\\\x0\" + hex(ch)).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch)=>\"\\\\x\" + hex(ch));\n        }\n        function describeExpectation(expectation) {\n            switch(expectation.type){\n                case \"literal\":\n                    return '\"' + literalEscape(expectation.text) + '\"';\n                case \"class\":\n                    const escapedParts = expectation.parts.map((part)=>{\n                        return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n                    });\n                    return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n                case \"any\":\n                    return \"any character\";\n                case \"end\":\n                    return \"end of input\";\n                case \"other\":\n                    return expectation.description;\n            }\n        }\n        function describeExpected(expected1) {\n            const descriptions = expected1.map(describeExpectation);\n            let i;\n            let j;\n            descriptions.sort();\n            if (descriptions.length > 0) {\n                for(i = 1, j = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {\n                    descriptions[j] = descriptions[i];\n                    j++;\n                }\n                descriptions.length = j;\n            }\n            switch(descriptions.length){\n                case 1:\n                    return descriptions[0];\n                case 2:\n                    return descriptions[0] + \" or \" + descriptions[1];\n                default:\n                    return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n            }\n        }\n        function describeFound(found1) {\n            return found1 ? '\"' + literalEscape(found1) + '\"' : \"end of input\";\n        }\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n    }\n    constructor(message, expected, found, location){\n        super();\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n        if (typeof Object.setPrototypeOf === \"function\") Object.setPrototypeOf(this, $524984546aa7a02b$export$f21cea08b0dd60e8.prototype);\n        else this.__proto__ = $524984546aa7a02b$export$f21cea08b0dd60e8.prototype;\n        if (typeof Error.captureStackTrace === \"function\") Error.captureStackTrace(this, $524984546aa7a02b$export$f21cea08b0dd60e8);\n    }\n    format(sources) {\n        let str = \"Error: \" + this.message;\n        if (this.location) {\n            let src = null;\n            let k;\n            for(k = 0; k < sources.length; k++)if (sources[k].source === this.location.source) {\n                src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n                break;\n            }\n            let s = this.location.start;\n            let loc = this.location.source + \":\" + s.line + \":\" + s.column;\n            if (src) {\n                let e = this.location.end;\n                let filler = $524984546aa7a02b$var$peg$padEnd(\"\", s.line.toString().length, \" \");\n                let line = src[s.line - 1];\n                let last = s.line === e.line ? e.column : line.length + 1;\n                str += \"\\n --> \" + loc + \"\\n\" + filler + \" |\\n\" + s.line + \" | \" + line + \"\\n\" + filler + \" | \" + $524984546aa7a02b$var$peg$padEnd(\"\", s.column - 1, \" \") + $524984546aa7a02b$var$peg$padEnd(\"\", last - s.column, \"^\");\n            } else str += \"\\n at \" + loc;\n        }\n        return str;\n    }\n}\nfunction $524984546aa7a02b$var$peg$parse(input, options) {\n    options = options !== undefined ? options : {};\n    const peg$FAILED = {};\n    const peg$source = options.grammarSource;\n    const peg$startRuleFunctions = {\n        ChordSheet: peg$parseChordSheet\n    };\n    let peg$startRuleFunction = peg$parseChordSheet;\n    const peg$c0 = function(metadataLines, lines) {\n        return {\n            type: \"chordSheet\",\n            lines: [\n                ...metadataLines,\n                ...lines\n            ]\n        };\n    };\n    const peg$c1 = function(newLine, items, trailingItem) {\n        const hasEmptyLine = newLine?.length > 0;\n        const emptyLines = hasEmptyLine ? [\n            {\n                type: \"line\",\n                items: []\n            }\n        ] : [];\n        return [\n            ...emptyLines,\n            ...items,\n            trailingItem\n        ];\n    };\n    const peg$c2 = function(item) {\n        return item;\n    };\n    const peg$c3 = function(item) {\n        if (item.type === \"chordsLine\") return {\n            type: \"line\",\n            items: item.items.map((item)=>{\n                const chordLyricsPair = {\n                    type: \"chordLyricsPair\"\n                };\n                if (item.type === \"chord\") return {\n                    ...chordLyricsPair,\n                    chord: item\n                };\n                return {\n                    ...chordLyricsPair,\n                    chords: item.value\n                };\n            })\n        };\n        return item;\n    };\n    const peg$c4 = function(chordsLine, lyrics) {\n        const chords = chordsLine.items;\n        const chordLyricsPairs = chords.map((chord, i)=>{\n            const nextChord = chords[i + 1];\n            const start = chord.column - 1;\n            const end = nextChord ? nextChord.column - 1 : lyrics.length;\n            const pairLyrics = lyrics.substring(start, end);\n            const secondWordPosition = pairLyrics.search(/(?<=\\s+)\\S/);\n            const chordData = chord.type === \"chord\" ? {\n                chord: chord\n            } : {\n                chords: chord.value\n            };\n            if (secondWordPosition !== -1 && secondWordPosition < end) return [\n                {\n                    type: \"chordLyricsPair\",\n                    ...chordData,\n                    lyrics: pairLyrics.substring(0, secondWordPosition)\n                },\n                {\n                    type: \"chordLyricsPair\",\n                    chords: \"\",\n                    lyrics: pairLyrics.substring(secondWordPosition)\n                }\n            ];\n            return {\n                type: \"chordLyricsPair\",\n                ...chordData,\n                lyrics: pairLyrics\n            };\n        }).flat();\n        const firstChord = chords[0];\n        if (firstChord && firstChord.column > 1) {\n            const firstChordPosition = firstChord.column;\n            if (firstChordPosition > 0) chordLyricsPairs.unshift({\n                type: \"chordLyricsPair\",\n                chords: \"\",\n                lyrics: lyrics.substring(0, firstChordPosition - 1)\n            });\n        }\n        return {\n            type: \"line\",\n            items: chordLyricsPairs\n        };\n    };\n    const peg$c5 = function(items) {\n        return {\n            type: \"chordsLine\",\n            items: items\n        };\n    };\n    const peg$c6 = function(symbol) {\n        return symbol;\n    };\n    const peg$c7 = \"/\";\n    const peg$c8 = peg$literalExpectation(\"/\", false);\n    const peg$c9 = \"|\";\n    const peg$c10 = peg$literalExpectation(\"|\", false);\n    const peg$c11 = \"-\";\n    const peg$c12 = peg$literalExpectation(\"-\", false);\n    const peg$c13 = function(symbol) {\n        return {\n            type: \"symbol\",\n            value: symbol,\n            column: location().start.column\n        };\n    };\n    const peg$c14 = function(lyrics) {\n        if (lyrics.length === 0) return {\n            type: \"line\",\n            items: []\n        };\n        return {\n            type: \"line\",\n            items: [\n                {\n                    type: \"chordLyricsPair\",\n                    chords: \"\",\n                    lyrics: lyrics\n                }\n            ]\n        };\n    };\n    const peg$c15 = function(chord) {\n        return chord;\n    };\n    const peg$c16 = function(line) {\n        return {\n            type: \"line\",\n            items: [\n                {\n                    type: \"tag\",\n                    name: \"comment\",\n                    value: line\n                }\n            ]\n        };\n    };\n    const peg$c17 = \"verse\";\n    const peg$c18 = peg$literalExpectation(\"verse\", true);\n    const peg$c19 = \"chorus\";\n    const peg$c20 = peg$literalExpectation(\"chorus\", true);\n    const peg$c21 = \"bridge\";\n    const peg$c22 = peg$literalExpectation(\"bridge\", true);\n    const peg$c23 = \"tag\";\n    const peg$c24 = peg$literalExpectation(\"tag\", true);\n    const peg$c25 = \"interlude\";\n    const peg$c26 = peg$literalExpectation(\"interlude\", true);\n    const peg$c27 = \"instrumental\";\n    const peg$c28 = peg$literalExpectation(\"instrumental\", true);\n    const peg$c29 = \"intro\";\n    const peg$c30 = peg$literalExpectation(\"intro\", true);\n    const peg$c31 = /^[^\\n\\r]/;\n    const peg$c32 = peg$classExpectation([\n        \"\\n\",\n        \"\\r\"\n    ], true, false);\n    const peg$c33 = function(pairs, trailingPair) {\n        return [\n            ...pairs,\n            trailingPair\n        ].filter((x)=>x).map(([key, value])=>({\n                type: \"line\",\n                items: [\n                    {\n                        type: \"tag\",\n                        name: key,\n                        value: value\n                    }\n                ]\n            }));\n    };\n    const peg$c34 = function(key, value) {\n        return {\n            type: \"line\",\n            items: [\n                {\n                    type: \"tag\",\n                    name: key,\n                    value: value\n                }\n            ]\n        };\n    };\n    const peg$c35 = function(pair) {\n        return pair;\n    };\n    const peg$c36 = \"{\";\n    const peg$c37 = peg$literalExpectation(\"{\", false);\n    const peg$c38 = \"}\";\n    const peg$c39 = peg$literalExpectation(\"}\", false);\n    const peg$c40 = function(pair) {\n        return pair;\n    };\n    const peg$c41 = function(key, value) {\n        return [\n            key,\n            value\n        ];\n    };\n    const peg$c42 = \":\";\n    const peg$c43 = peg$literalExpectation(\":\", false);\n    const peg$c44 = /^[a-zA-Z0-9\\-_]/;\n    const peg$c45 = peg$classExpectation([\n        [\n            \"a\",\n            \"z\"\n        ],\n        [\n            \"A\",\n            \"Z\"\n        ],\n        [\n            \"0\",\n            \"9\"\n        ],\n        \"-\",\n        \"_\"\n    ], false, false);\n    const peg$c46 = /^[^\\n\\r}]/;\n    const peg$c47 = peg$classExpectation([\n        \"\\n\",\n        \"\\r\",\n        \"}\"\n    ], true, false);\n    const peg$c48 = \"---\";\n    const peg$c49 = peg$literalExpectation(\"---\", false);\n    const peg$c50 = peg$otherExpectation(\"whitespace\");\n    const peg$c51 = /^[ \\t]/;\n    const peg$c52 = peg$classExpectation([\n        \" \",\n        \"\t\"\n    ], false, false);\n    const peg$c53 = \"\\n\";\n    const peg$c54 = peg$literalExpectation(\"\\n\", false);\n    const peg$c55 = \"\\r\";\n    const peg$c56 = peg$literalExpectation(\"\\r\", false);\n    const peg$c57 = function(chord) {\n        return {\n            type: \"chord\",\n            ...chord,\n            column: location().start.column\n        };\n    };\n    const peg$c58 = \"#\";\n    const peg$c59 = peg$literalExpectation(\"#\", false);\n    const peg$c60 = \"b\";\n    const peg$c61 = peg$literalExpectation(\"b\", false);\n    const peg$c62 = /^[a-zA-Z0-9()#+]/;\n    const peg$c63 = peg$classExpectation([\n        [\n            \"a\",\n            \"z\"\n        ],\n        [\n            \"A\",\n            \"Z\"\n        ],\n        [\n            \"0\",\n            \"9\"\n        ],\n        \"(\",\n        \")\",\n        \"#\",\n        \"+\"\n    ], false, false);\n    const peg$c64 = function(root, modifier, suffix, bass) {\n        return {\n            base: root,\n            modifier: modifier,\n            suffix: suffix,\n            ...bass,\n            chordType: \"symbol\"\n        };\n    };\n    const peg$c65 = /^[A-Ga-g]/;\n    const peg$c66 = peg$classExpectation([\n        [\n            \"A\",\n            \"G\"\n        ],\n        [\n            \"a\",\n            \"g\"\n        ]\n    ], false, false);\n    const peg$c67 = function(root, modifier) {\n        return {\n            bassBase: root,\n            bassModifier: modifier\n        };\n    };\n    const peg$c68 = function(modifier, root, suffix, bass) {\n        return {\n            base: root,\n            modifier: modifier,\n            suffix: suffix,\n            ...bass,\n            chordType: \"numeral\"\n        };\n    };\n    const peg$c69 = \"III\";\n    const peg$c70 = peg$literalExpectation(\"III\", false);\n    const peg$c71 = \"iii\";\n    const peg$c72 = peg$literalExpectation(\"iii\", false);\n    const peg$c73 = \"VII\";\n    const peg$c74 = peg$literalExpectation(\"VII\", false);\n    const peg$c75 = \"vii\";\n    const peg$c76 = peg$literalExpectation(\"vii\", false);\n    const peg$c77 = \"II\";\n    const peg$c78 = peg$literalExpectation(\"II\", false);\n    const peg$c79 = \"ii\";\n    const peg$c80 = peg$literalExpectation(\"ii\", false);\n    const peg$c81 = \"IV\";\n    const peg$c82 = peg$literalExpectation(\"IV\", false);\n    const peg$c83 = \"iv\";\n    const peg$c84 = peg$literalExpectation(\"iv\", false);\n    const peg$c85 = \"VI\";\n    const peg$c86 = peg$literalExpectation(\"VI\", false);\n    const peg$c87 = \"vi\";\n    const peg$c88 = peg$literalExpectation(\"vi\", false);\n    const peg$c89 = \"I\";\n    const peg$c90 = peg$literalExpectation(\"I\", false);\n    const peg$c91 = \"i\";\n    const peg$c92 = peg$literalExpectation(\"i\", false);\n    const peg$c93 = \"V\";\n    const peg$c94 = peg$literalExpectation(\"V\", false);\n    const peg$c95 = \"v\";\n    const peg$c96 = peg$literalExpectation(\"v\", false);\n    const peg$c97 = function(modifier, root) {\n        return {\n            bassBase: root,\n            bassModifier: modifier\n        };\n    };\n    const peg$c98 = function(modifier, root, suffix, bass) {\n        return {\n            base: root,\n            modifier: modifier,\n            suffix: suffix,\n            ...bass,\n            chordType: \"numeric\"\n        };\n    };\n    const peg$c99 = /^[1-7]/;\n    const peg$c100 = peg$classExpectation([\n        [\n            \"1\",\n            \"7\"\n        ]\n    ], false, false);\n    let peg$currPos = 0;\n    let peg$savedPos = 0;\n    const peg$posDetailsCache = [\n        {\n            line: 1,\n            column: 1\n        }\n    ];\n    let peg$maxFailPos = 0;\n    let peg$maxFailExpected = [];\n    let peg$silentFails = 0;\n    let peg$result;\n    if (options.startRule !== undefined) {\n        if (!(options.startRule in peg$startRuleFunctions)) throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + '\".');\n        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n        return input.substring(peg$savedPos, peg$currPos);\n    }\n    function location() {\n        return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location1) {\n        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildStructuredError([\n            peg$otherExpectation(description)\n        ], input.substring(peg$savedPos, peg$currPos), location1);\n    }\n    function error(message, location1) {\n        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);\n        throw peg$buildSimpleError(message, location1);\n    }\n    function peg$literalExpectation(text1, ignoreCase) {\n        return {\n            type: \"literal\",\n            text: text1,\n            ignoreCase: ignoreCase\n        };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n        return {\n            type: \"class\",\n            parts: parts,\n            inverted: inverted,\n            ignoreCase: ignoreCase\n        };\n    }\n    function peg$anyExpectation() {\n        return {\n            type: \"any\"\n        };\n    }\n    function peg$endExpectation() {\n        return {\n            type: \"end\"\n        };\n    }\n    function peg$otherExpectation(description) {\n        return {\n            type: \"other\",\n            description: description\n        };\n    }\n    function peg$computePosDetails(pos) {\n        let details = peg$posDetailsCache[pos];\n        let p;\n        if (details) return details;\n        else {\n            p = pos - 1;\n            while(!peg$posDetailsCache[p])p--;\n            details = peg$posDetailsCache[p];\n            details = {\n                line: details.line,\n                column: details.column\n            };\n            while(p < pos){\n                if (input.charCodeAt(p) === 10) {\n                    details.line++;\n                    details.column = 1;\n                } else details.column++;\n                p++;\n            }\n            peg$posDetailsCache[pos] = details;\n            return details;\n        }\n    }\n    function peg$computeLocation(startPos, endPos) {\n        const startPosDetails = peg$computePosDetails(startPos);\n        const endPosDetails = peg$computePosDetails(endPos);\n        return {\n            source: peg$source,\n            start: {\n                offset: startPos,\n                line: startPosDetails.line,\n                column: startPosDetails.column\n            },\n            end: {\n                offset: endPos,\n                line: endPosDetails.line,\n                column: endPosDetails.column\n            }\n        };\n    }\n    function peg$fail(expected1) {\n        if (peg$currPos < peg$maxFailPos) return;\n        if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n        }\n        peg$maxFailExpected.push(expected1);\n    }\n    function peg$buildSimpleError(message, location1) {\n        return new $524984546aa7a02b$export$f21cea08b0dd60e8(message, [], \"\", location1);\n    }\n    function peg$buildStructuredError(expected1, found, location1) {\n        return new $524984546aa7a02b$export$f21cea08b0dd60e8($524984546aa7a02b$export$f21cea08b0dd60e8.buildMessage(expected1, found), expected1, found, location1);\n    }\n    function peg$parseChordSheet() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseMetadata();\n        if (s1 === peg$FAILED) s1 = null;\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseChordSheetContents();\n            if (s2 === peg$FAILED) s2 = null;\n            if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c0(s1, s2);\n                s0 = s1;\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseChordSheetContents() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parseNewLine();\n        if (s1 === peg$FAILED) s1 = null;\n        if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parseChordSheetItemWithNewLine();\n            while(s3 !== peg$FAILED){\n                s2.push(s3);\n                s3 = peg$parseChordSheetItemWithNewLine();\n            }\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseChordSheetItem();\n                if (s3 === peg$FAILED) s3 = null;\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c1(s1, s2, s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseChordSheetItemWithNewLine() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseChordSheetItem();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseNewLine();\n            if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c2(s1);\n                s0 = s1;\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseChordSheetItem() {\n        let s0, s1;\n        s0 = peg$currPos;\n        s1 = peg$parseDirectionLine();\n        if (s1 === peg$FAILED) {\n            s1 = peg$parseInlineMetadata();\n            if (s1 === peg$FAILED) {\n                s1 = peg$parseChordLyricsLines();\n                if (s1 === peg$FAILED) {\n                    s1 = peg$parseChordsLine();\n                    if (s1 === peg$FAILED) s1 = peg$parseLyricsLine();\n                }\n            }\n        }\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parseChordLyricsLines() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parseChordsLine();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseNewLine();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseNonEmptyLyrics();\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c4(s1, s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseChordsLine() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseRhythmSymbolWithSpacing();\n        if (s2 === peg$FAILED) s2 = peg$parseChordWithSpacing();\n        if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){\n            s1.push(s2);\n            s2 = peg$parseRhythmSymbolWithSpacing();\n            if (s2 === peg$FAILED) s2 = peg$parseChordWithSpacing();\n        }\n        else s1 = peg$FAILED;\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c5(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parseRhythmSymbolWithSpacing() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseRhythmSymbol();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c6(s2);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseRhythmSymbol() {\n        let s0, s1;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c7;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c8);\n        }\n        if (s1 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 124) {\n                s1 = peg$c9;\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c10);\n            }\n            if (s1 === peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 45) {\n                    s1 = peg$c11;\n                    peg$currPos++;\n                } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) peg$fail(peg$c12);\n                }\n            }\n        }\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parseLyricsLine() {\n        let s0, s1;\n        s0 = peg$currPos;\n        s1 = peg$parseLyrics();\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c14(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parseLyrics() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseWordChar();\n        while(s2 !== peg$FAILED){\n            s1.push(s2);\n            s2 = peg$parseWordChar();\n        }\n        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);\n        else s0 = s1;\n        return s0;\n    }\n    function peg$parseNonEmptyLyrics() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseWordChar();\n        if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){\n            s1.push(s2);\n            s2 = peg$parseWordChar();\n        }\n        else s1 = peg$FAILED;\n        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);\n        else s0 = s1;\n        return s0;\n    }\n    function peg$parseChordWithSpacing() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = peg$parse_();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseChord();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c15(s2);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseDirectionLine() {\n        let s0, s1, s2, s3, s4, s5, s6, s7;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$currPos;\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n            s4 = peg$parseKeyword();\n            if (s4 !== peg$FAILED) {\n                s5 = peg$parse_();\n                if (s5 !== peg$FAILED) {\n                    s6 = [];\n                    s7 = peg$parseWordChar();\n                    while(s7 !== peg$FAILED){\n                        s6.push(s7);\n                        s7 = peg$parseWordChar();\n                    }\n                    if (s6 !== peg$FAILED) {\n                        s7 = peg$parse_();\n                        if (s7 !== peg$FAILED) {\n                            s3 = [\n                                s3,\n                                s4,\n                                s5,\n                                s6,\n                                s7\n                            ];\n                            s2 = s3;\n                        } else {\n                            peg$currPos = s2;\n                            s2 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s2;\n                        s2 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s2;\n                    s2 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);\n        else s1 = s2;\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c16(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parseKeyword() {\n        let s0;\n        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c17) {\n            s0 = input.substr(peg$currPos, 5);\n            peg$currPos += 5;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c18);\n        }\n        if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c19) {\n                s0 = input.substr(peg$currPos, 6);\n                peg$currPos += 6;\n            } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c20);\n            }\n            if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 6).toLowerCase() === peg$c21) {\n                    s0 = input.substr(peg$currPos, 6);\n                    peg$currPos += 6;\n                } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) peg$fail(peg$c22);\n                }\n                if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c23) {\n                        s0 = input.substr(peg$currPos, 3);\n                        peg$currPos += 3;\n                    } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) peg$fail(peg$c24);\n                    }\n                    if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c25) {\n                            s0 = input.substr(peg$currPos, 9);\n                            peg$currPos += 9;\n                        } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) peg$fail(peg$c26);\n                        }\n                        if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 12).toLowerCase() === peg$c27) {\n                                s0 = input.substr(peg$currPos, 12);\n                                peg$currPos += 12;\n                            } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) peg$fail(peg$c28);\n                            }\n                            if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c29) {\n                                    s0 = input.substr(peg$currPos, 5);\n                                    peg$currPos += 5;\n                                } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) peg$fail(peg$c30);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parseWordChar() {\n        let s0;\n        if (peg$c31.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c32);\n        }\n        return s0;\n    }\n    function peg$parseMetadata() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parseMetadataPairWithNewLine();\n        while(s2 !== peg$FAILED){\n            s1.push(s2);\n            s2 = peg$parseMetadataPairWithNewLine();\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseMetadataPair();\n            if (s2 === peg$FAILED) s2 = null;\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseMetadataSeparator();\n                if (s3 === peg$FAILED) s3 = null;\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c33(s1, s2);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseInlineMetadata() {\n        let s0, s1, s2, s3, s4, s5, s6;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$parseMetadataKey();\n        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);\n        else s1 = s2;\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseColon();\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                        s5 = peg$currPos;\n                        s6 = peg$parseMetadataValue();\n                        if (s6 !== peg$FAILED) s5 = input.substring(s5, peg$currPos);\n                        else s5 = s6;\n                        if (s5 !== peg$FAILED) {\n                            peg$savedPos = s0;\n                            s1 = peg$c34(s1, s5);\n                            s0 = s1;\n                        } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseMetadataPairWithNewLine() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseMetadataPair();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseNewLine();\n            if (s2 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c35(s1);\n                s0 = s1;\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseMetadataPair() {\n        let s0;\n        s0 = peg$parseMetadataPairWithBrackets();\n        if (s0 === peg$FAILED) s0 = peg$parseMetadataPairWithoutBrackets();\n        return s0;\n    }\n    function peg$parseMetadataPairWithBrackets() {\n        let s0, s1, s2, s3, s4, s5;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 123) {\n            s1 = peg$c36;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c37);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseMetadataPairWithoutBrackets();\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 125) {\n                            s5 = peg$c38;\n                            peg$currPos++;\n                        } else {\n                            s5 = peg$FAILED;\n                            if (peg$silentFails === 0) peg$fail(peg$c39);\n                        }\n                        if (s5 !== peg$FAILED) {\n                            peg$savedPos = s0;\n                            s1 = peg$c40(s3);\n                            s0 = s1;\n                        } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseMetadataPairWithoutBrackets() {\n        let s0, s1, s2, s3, s4, s5, s6;\n        s0 = peg$currPos;\n        s1 = peg$currPos;\n        s2 = peg$parseMetadataKey();\n        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);\n        else s1 = s2;\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseColon();\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parse_();\n                    if (s4 !== peg$FAILED) {\n                        s5 = peg$currPos;\n                        s6 = peg$parseMetadataValue();\n                        if (s6 !== peg$FAILED) s5 = input.substring(s5, peg$currPos);\n                        else s5 = s6;\n                        if (s5 !== peg$FAILED) {\n                            peg$savedPos = s0;\n                            s1 = peg$c41(s1, s5);\n                            s0 = s1;\n                        } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                        }\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseColon() {\n        let s0;\n        if (input.charCodeAt(peg$currPos) === 58) {\n            s0 = peg$c42;\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c43);\n        }\n        return s0;\n    }\n    function peg$parseMetadataKey() {\n        let s0, s1;\n        s0 = [];\n        if (peg$c44.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c45);\n        }\n        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){\n            s0.push(s1);\n            if (peg$c44.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c45);\n            }\n        }\n        else s0 = peg$FAILED;\n        return s0;\n    }\n    function peg$parseMetadataValue() {\n        let s0, s1;\n        s0 = [];\n        if (peg$c46.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c47);\n        }\n        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){\n            s0.push(s1);\n            if (peg$c46.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c47);\n            }\n        }\n        else s0 = peg$FAILED;\n        return s0;\n    }\n    function peg$parseMetadataSeparator() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        if (input.substr(peg$currPos, 3) === peg$c48) {\n            s1 = peg$c48;\n            peg$currPos += 3;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c49);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseNewLine();\n            if (s2 !== peg$FAILED) {\n                s1 = [\n                    s1,\n                    s2\n                ];\n                s0 = s1;\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parse_() {\n        let s0, s1;\n        peg$silentFails++;\n        s0 = [];\n        if (peg$c51.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c52);\n        }\n        while(s1 !== peg$FAILED){\n            s0.push(s1);\n            if (peg$c51.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c52);\n            }\n        }\n        peg$silentFails--;\n        if (s0 === peg$FAILED) {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c50);\n        }\n        return s0;\n    }\n    function peg$parseNewLine() {\n        let s0;\n        s0 = peg$parseCarriageReturn();\n        if (s0 === peg$FAILED) {\n            s0 = peg$parseLineFeed();\n            if (s0 === peg$FAILED) s0 = peg$parseCarriageReturnLineFeed();\n        }\n        return s0;\n    }\n    function peg$parseCarriageReturnLineFeed() {\n        let s0, s1, s2;\n        s0 = peg$currPos;\n        s1 = peg$parseCarriageReturn();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseLineFeed();\n            if (s2 !== peg$FAILED) {\n                s1 = [\n                    s1,\n                    s2\n                ];\n                s0 = s1;\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseLineFeed() {\n        let s0;\n        if (input.charCodeAt(peg$currPos) === 10) {\n            s0 = peg$c53;\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c54);\n        }\n        return s0;\n    }\n    function peg$parseCarriageReturn() {\n        let s0;\n        if (input.charCodeAt(peg$currPos) === 13) {\n            s0 = peg$c55;\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c56);\n        }\n        return s0;\n    }\n    function peg$parseChord() {\n        let s0, s1;\n        s0 = peg$currPos;\n        s1 = peg$parseNumeral();\n        if (s1 === peg$FAILED) {\n            s1 = peg$parseNumeric();\n            if (s1 === peg$FAILED) s1 = peg$parseChordSymbol();\n        }\n        if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c57(s1);\n        }\n        s0 = s1;\n        return s0;\n    }\n    function peg$parseChordModifier() {\n        let s0;\n        if (input.charCodeAt(peg$currPos) === 35) {\n            s0 = peg$c58;\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c59);\n        }\n        if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 98) {\n                s0 = peg$c60;\n                peg$currPos++;\n            } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c61);\n            }\n        }\n        return s0;\n    }\n    function peg$parseChordSuffix() {\n        let s0, s1;\n        s0 = [];\n        if (peg$c62.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c63);\n        }\n        while(s1 !== peg$FAILED){\n            s0.push(s1);\n            if (peg$c62.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n            } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c63);\n            }\n        }\n        return s0;\n    }\n    function peg$parseChordSymbol() {\n        let s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$parseChordSymbolRoot();\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseChordModifier();\n            if (s2 === peg$FAILED) s2 = null;\n            if (s2 !== peg$FAILED) {\n                s3 = peg$currPos;\n                s4 = peg$parseChordSuffix();\n                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);\n                else s3 = s4;\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parseChordSymbolBass();\n                    if (s4 === peg$FAILED) s4 = null;\n                    if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c64(s1, s2, s3, s4);\n                        s0 = s1;\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseChordSymbolRoot() {\n        let s0;\n        if (peg$c65.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c66);\n        }\n        return s0;\n    }\n    function peg$parseChordSymbolBass() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c7;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c8);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseChordSymbolRoot();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseChordModifier();\n                if (s3 === peg$FAILED) s3 = null;\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c67(s2, s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseNumeral() {\n        let s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$parseChordModifier();\n        if (s1 === peg$FAILED) s1 = null;\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseNumeralRoot();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$currPos;\n                s4 = peg$parseChordSuffix();\n                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);\n                else s3 = s4;\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parseNumeralBass();\n                    if (s4 === peg$FAILED) s4 = null;\n                    if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c68(s1, s2, s3, s4);\n                        s0 = s1;\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseNumeralRoot() {\n        let s0;\n        if (input.substr(peg$currPos, 3) === peg$c69) {\n            s0 = peg$c69;\n            peg$currPos += 3;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c70);\n        }\n        if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3) === peg$c71) {\n                s0 = peg$c71;\n                peg$currPos += 3;\n            } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) peg$fail(peg$c72);\n            }\n            if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 3) === peg$c73) {\n                    s0 = peg$c73;\n                    peg$currPos += 3;\n                } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) peg$fail(peg$c74);\n                }\n                if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 3) === peg$c75) {\n                        s0 = peg$c75;\n                        peg$currPos += 3;\n                    } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) peg$fail(peg$c76);\n                    }\n                    if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 2) === peg$c77) {\n                            s0 = peg$c77;\n                            peg$currPos += 2;\n                        } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) peg$fail(peg$c78);\n                        }\n                        if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 2) === peg$c79) {\n                                s0 = peg$c79;\n                                peg$currPos += 2;\n                            } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) peg$fail(peg$c80);\n                            }\n                            if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 2) === peg$c81) {\n                                    s0 = peg$c81;\n                                    peg$currPos += 2;\n                                } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) peg$fail(peg$c82);\n                                }\n                                if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 2) === peg$c83) {\n                                        s0 = peg$c83;\n                                        peg$currPos += 2;\n                                    } else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) peg$fail(peg$c84);\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 2) === peg$c85) {\n                                            s0 = peg$c85;\n                                            peg$currPos += 2;\n                                        } else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) peg$fail(peg$c86);\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                            if (input.substr(peg$currPos, 2) === peg$c87) {\n                                                s0 = peg$c87;\n                                                peg$currPos += 2;\n                                            } else {\n                                                s0 = peg$FAILED;\n                                                if (peg$silentFails === 0) peg$fail(peg$c88);\n                                            }\n                                            if (s0 === peg$FAILED) {\n                                                if (input.charCodeAt(peg$currPos) === 73) {\n                                                    s0 = peg$c89;\n                                                    peg$currPos++;\n                                                } else {\n                                                    s0 = peg$FAILED;\n                                                    if (peg$silentFails === 0) peg$fail(peg$c90);\n                                                }\n                                                if (s0 === peg$FAILED) {\n                                                    if (input.charCodeAt(peg$currPos) === 105) {\n                                                        s0 = peg$c91;\n                                                        peg$currPos++;\n                                                    } else {\n                                                        s0 = peg$FAILED;\n                                                        if (peg$silentFails === 0) peg$fail(peg$c92);\n                                                    }\n                                                    if (s0 === peg$FAILED) {\n                                                        if (input.charCodeAt(peg$currPos) === 86) {\n                                                            s0 = peg$c93;\n                                                            peg$currPos++;\n                                                        } else {\n                                                            s0 = peg$FAILED;\n                                                            if (peg$silentFails === 0) peg$fail(peg$c94);\n                                                        }\n                                                        if (s0 === peg$FAILED) {\n                                                            if (input.charCodeAt(peg$currPos) === 118) {\n                                                                s0 = peg$c95;\n                                                                peg$currPos++;\n                                                            } else {\n                                                                s0 = peg$FAILED;\n                                                                if (peg$silentFails === 0) peg$fail(peg$c96);\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return s0;\n    }\n    function peg$parseNumeralBass() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c7;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c8);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseChordModifier();\n            if (s2 === peg$FAILED) s2 = null;\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseNumeralRoot();\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c97(s2, s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseNumeric() {\n        let s0, s1, s2, s3, s4;\n        s0 = peg$currPos;\n        s1 = peg$parseChordModifier();\n        if (s1 === peg$FAILED) s1 = null;\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseNumericRoot();\n            if (s2 !== peg$FAILED) {\n                s3 = peg$currPos;\n                s4 = peg$parseChordSuffix();\n                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);\n                else s3 = s4;\n                if (s3 !== peg$FAILED) {\n                    s4 = peg$parseNumericBass();\n                    if (s4 === peg$FAILED) s4 = null;\n                    if (s4 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c98(s1, s2, s3, s4);\n                        s0 = s1;\n                    } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                    }\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    function peg$parseNumericRoot() {\n        let s0;\n        if (peg$c99.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n        } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c100);\n        }\n        return s0;\n    }\n    function peg$parseNumericBass() {\n        let s0, s1, s2, s3;\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c7;\n            peg$currPos++;\n        } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) peg$fail(peg$c8);\n        }\n        if (s1 !== peg$FAILED) {\n            s2 = peg$parseChordModifier();\n            if (s2 === peg$FAILED) s2 = null;\n            if (s2 !== peg$FAILED) {\n                s3 = peg$parseNumericRoot();\n                if (s3 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c97(s2, s3);\n                    s0 = s1;\n                } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                }\n            } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n            }\n        } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n        }\n        return s0;\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;\n    else {\n        if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());\n        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n}\nconst $524984546aa7a02b$export$98e6a39c04603d36 = $524984546aa7a02b$var$peg$parse;\n\n\n/**\n * Parses a chords over words sheet into a song\n *\n * It support \"regular\" chord sheets:\n *\n *            Am         C/G        F          C\n *     Let it be, let it be, let it be, let it be\n *     C                G              F  C/E Dm C\n *     Whisper words of wisdom, let it be\n *\n * Additionally, some chordpro features have been \"ported back\". For example, you can use chordpro directives:\n *\n *     {title: Let it be}\n *     {key: C}\n *     Chorus 1:\n *            Am\n *     Let it be\n *\n * For convenience, you can leave out the brackets:\n *\n *     title: Let it be\n *     Chorus 1:\n *            Am\n *     Let it be\n *\n * You can even use a markdown style frontmatter separator to separate the header from the song:\n *\n *     title: Let it be\n *     key: C\n *     ---\n *     Chorus 1:\n *            Am         C/G        F          C\n *     Let it be, let it be, let it be, let it be\n *     C                G              F  C/E Dm C\n *     Whisper words of wisdom, let it be\n *\n * `ChordsOverWordsParser` is the better version of `ChordSheetParser`, which is deprecated.\n */ class $b72f5288e28a9b64$var$ChordsOverWordsParser extends (0, $3e6b6f33997c81b2$export$2e2bcd8739ae039) {\n    /**\n   * Parses a chords over words sheet into a song\n   * @param {string} chordsOverWordsSheet the chords over words sheet\n   * @returns {Song} The parsed song\n   */ parse(chordsOverWordsSheet) {\n        return this.parseWithParser(chordsOverWordsSheet, (0, $524984546aa7a02b$export$98e6a39c04603d36));\n    }\n}\nvar $b72f5288e28a9b64$export$2e2bcd8739ae039 = $b72f5288e28a9b64$var$ChordsOverWordsParser;\n\n\n\n\n\nconst $7c59209366f6488e$var$VERSE_LINE_REGEX = /^\\[Verse.*]/;\nconst $7c59209366f6488e$var$CHORUS_LINE_REGEX = /^\\[Chorus]/;\nconst $7c59209366f6488e$var$OTHER_METADATA_LINE_REGEX = /^\\[([^\\]]+)]/;\nconst $7c59209366f6488e$var$startSectionTags = {\n    [(0, $234747a9630b4642$export$4b194284baed1659)]: (0, $b3836272a1374d85$export$deca399f8cd9b7dc),\n    [(0, $234747a9630b4642$export$8db6c706fc9142b2)]: (0, $b3836272a1374d85$export$4f5168acae064e01)\n};\nconst $7c59209366f6488e$var$endSectionTags = {\n    [(0, $234747a9630b4642$export$4b194284baed1659)]: (0, $b3836272a1374d85$export$640d294ab83f9040),\n    [(0, $234747a9630b4642$export$8db6c706fc9142b2)]: (0, $b3836272a1374d85$export$473c1a4819e5180b)\n};\n/**\n * Parses an Ultimate Guitar chord sheet with metadata\n * Inherits from {@link ChordSheetParser}\n */ class $7c59209366f6488e$var$UltimateGuitarParser extends (0, $9c17b505581d81bb$export$2e2bcd8739ae039) {\n    currentSectionType = null;\n    parseLine(line) {\n        if (this.isSectionEnd()) this.endSection();\n        if ($7c59209366f6488e$var$VERSE_LINE_REGEX.test(line)) {\n            this.startNewLine();\n            this.startSection((0, $234747a9630b4642$export$4b194284baed1659));\n        } else if ($7c59209366f6488e$var$CHORUS_LINE_REGEX.test(line)) {\n            this.startNewLine();\n            this.startSection((0, $234747a9630b4642$export$8db6c706fc9142b2));\n        } else if ($7c59209366f6488e$var$OTHER_METADATA_LINE_REGEX.test(line)) this.parseMetadataLine(line);\n        else super.parseLine(line);\n    }\n    parseMetadataLine(line) {\n        this.startNewLine();\n        this.endSection();\n        const comment = line.match($7c59209366f6488e$var$OTHER_METADATA_LINE_REGEX)[1];\n        if (!this.songLine) throw new Error(\"Expected this.songLine to be present\");\n        this.songLine.addTag(new (0, $b3836272a1374d85$export$2e2bcd8739ae039)((0, $b3836272a1374d85$export$a29989082612d0d9), comment));\n    }\n    isSectionEnd() {\n        return this.songLine !== null && this.songLine.isEmpty() && this.song.previousLine !== null && !this.song.previousLine.isEmpty();\n    }\n    endOfSong() {\n        super.endOfSong();\n        if (this.currentSectionType !== null && this.currentSectionType in $7c59209366f6488e$var$endSectionTags) this.startNewLine();\n        this.endSection({\n            addNewLine: false\n        });\n    }\n    startSection(sectionType) {\n        if (this.currentSectionType) this.endSection();\n        this.currentSectionType = sectionType;\n        this.song.setCurrentProperties(sectionType);\n        if (sectionType in $7c59209366f6488e$var$startSectionTags) this.song.addTag(new (0, $b3836272a1374d85$export$2e2bcd8739ae039)($7c59209366f6488e$var$startSectionTags[sectionType]));\n    }\n    endSection({ addNewLine: addNewLine = true  } = {}) {\n        if (this.currentSectionType !== null && this.currentSectionType in $7c59209366f6488e$var$endSectionTags) {\n            this.song.addTag(new (0, $b3836272a1374d85$export$2e2bcd8739ae039)($7c59209366f6488e$var$endSectionTags[this.currentSectionType]));\n            if (addNewLine) this.startNewLine();\n        }\n        this.song.setCurrentProperties((0, $234747a9630b4642$export$c53d0f541b41b88e));\n        this.currentSectionType = null;\n    }\n    startNewLine() {\n        this.songLine = this.song.addLine();\n    }\n}\nvar $7c59209366f6488e$export$2e2bcd8739ae039 = $7c59209366f6488e$var$UltimateGuitarParser;\n\n\n\nconst $b40d86206d859ced$export$a014e67b549cbef4 = {\n    separator: \",\"\n};\nclass $b40d86206d859ced$var$MetadataConfiguration {\n    constructor(metadataConfiguration = $b40d86206d859ced$export$a014e67b549cbef4){\n        this.separator = metadataConfiguration.separator;\n    }\n}\nvar $b40d86206d859ced$export$2e2bcd8739ae039 = $b40d86206d859ced$var$MetadataConfiguration;\n\n\n\nconst $b83980a5d9482be8$export$78c0028a34264234 = {\n    evaluate: false,\n    metadata: {\n        separator: \",\"\n    },\n    key: null\n};\nclass $b83980a5d9482be8$var$Configuration {\n    constructor(configuration = $b83980a5d9482be8$export$78c0028a34264234){\n        if (\"evaluate\" in configuration) this.evaluate = !!configuration.evaluate;\n        else this.evaluate = !!$b83980a5d9482be8$export$78c0028a34264234.evaluate;\n        this.metadata = new (0, $b40d86206d859ced$export$2e2bcd8739ae039)(configuration.metadata);\n        this.key = configuration.key ? (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrap(configuration.key) : null;\n        this.configuration = configuration;\n    }\n    get(key) {\n        return (0, (lodash_get__WEBPACK_IMPORTED_MODULE_0___default()))(this, key);\n    }\n}\nvar $b83980a5d9482be8$export$2e2bcd8739ae039 = $b83980a5d9482be8$var$Configuration;\n\n\n/**\n * Base class for all formatters, taking care of receiving a configuration wrapping that inside a Configuration object\n */ class $2dfa852662754780$var$Formatter {\n    /**\n     * Instantiate\n     * @param {Object} [configuration={}] options\n     * @param {boolean} [configuration.evaluate=false] Whether or not to evaluate meta expressions. For more info about\n     * meta expressions, see: https://bit.ly/2SC9c2u\n     * @param {object} [configuration.metadata={}]\n     * @param {string} [configuration.metadata.separator=\", \"] The separator to be used when rendering a metadata value\n     * that has multiple values. See: https://bit.ly/2SC9c2u\n     * @param {Key|string} [configuration.key=null] The key to use for rendering. The chord sheet will be transposed\n     * from the song's original key (as indicated by the `{key}` directive) to the specified key.\n     * Note that transposing will only work\n     * if the original song key is set.\n     */ constructor(configuration = null){\n        this.configuration = new (0, $b83980a5d9482be8$export$2e2bcd8739ae039)(configuration || {});\n    }\n}\nvar $2dfa852662754780$export$2e2bcd8739ae039 = $2dfa852662754780$var$Formatter;\n\n\n\n\n\n\nconst $a181433de674b2b2$export$1e6f8e38ccd793b = [\n    \"A\",\n    \"Bb\",\n    \"B\",\n    \"C\",\n    \"C#\",\n    \"Db\",\n    \"D\",\n    \"Eb\",\n    \"E\",\n    \"F\",\n    \"F#\",\n    \"Gb\",\n    \"G\",\n    \"G#\",\n    \"Ab\"\n];\nconst $a181433de674b2b2$export$24a0bd6af7756225 = [\n    \"F#m\",\n    \"Gm\",\n    \"G#m\",\n    \"Am\",\n    \"Bbm\",\n    \"Bm\",\n    \"Cm\",\n    \"C#m\",\n    \"Dm\",\n    \"D#m\",\n    \"Ebm\",\n    \"Em\",\n    \"Fm\"\n];\nconst $a181433de674b2b2$export$1ba61c6fa2f892a9 = {\n    Bb: {\n        1: \"A\",\n        3: \"G\",\n        6: \"E\",\n        8: \"D\",\n        10: \"C\"\n    },\n    D: {\n        2: \"C\",\n        5: \"A\",\n        7: \"G\",\n        10: \"E\"\n    },\n    Eb: {\n        1: \"D\",\n        3: \"C\",\n        6: \"A\",\n        8: \"G\"\n    },\n    Db: {\n        1: \"C\",\n        4: \"A\",\n        6: \"G\",\n        9: \"E\"\n    },\n    \"C#\": {\n        1: \"C\",\n        4: \"A\",\n        6: \"G\",\n        9: \"E\"\n    },\n    E: {\n        2: \"D\",\n        4: \"C\",\n        7: \"A\",\n        9: \"G\"\n    },\n    F: {\n        1: \"E\",\n        3: \"D\",\n        5: \"C\",\n        6: \"B\",\n        8: \"A\",\n        10: \"G\"\n    },\n    \"F#\": {\n        2: \"E\",\n        4: \"D\",\n        6: \"C\",\n        7: \"B\",\n        9: \"A\"\n    },\n    Gb: {\n        2: \"E\",\n        4: \"D\",\n        6: \"C\",\n        7: \"B\",\n        9: \"A\"\n    },\n    G: {\n        3: \"E\",\n        5: \"D\",\n        7: \"C\",\n        8: \"B\",\n        10: \"A\"\n    },\n    \"G#\": {\n        1: \"G\",\n        4: \"E\",\n        6: \"D\",\n        8: \"C\"\n    },\n    Ab: {\n        1: \"G\",\n        4: \"E\",\n        6: \"D\",\n        8: \"C\"\n    },\n    A: {\n        2: \"G\",\n        5: \"E\",\n        7: \"D\",\n        9: \"C\"\n    },\n    B: {\n        2: \"A\",\n        4: \"G\",\n        7: \"E\",\n        9: \"D\"\n    },\n    C: {\n        3: \"A\",\n        5: \"G\",\n        8: \"E\",\n        10: \"D\"\n    },\n    Am: {\n        3: \"F#m\",\n        5: \"Em\",\n        7: \"Dm\"\n    },\n    Bbm: {\n        1: \"Am\",\n        4: \"F#m\",\n        6: \"Em\",\n        8: \"Dm\"\n    },\n    Bm: {\n        2: \"Am\",\n        5: \"F#m\",\n        7: \"Em\"\n    },\n    Cm: {\n        1: \"Bm\",\n        3: \"Am\",\n        6: \"F#m\",\n        8: \"Em\"\n    },\n    \"C#m\": {\n        2: \"Bm\",\n        4: \"Am\",\n        7: \"F#m\",\n        9: \"Em\"\n    },\n    Dm: {\n        3: \"Bm\",\n        5: \"Am\",\n        8: \"F#m\"\n    },\n    Ebm: {\n        1: \"Dm\",\n        4: \"Bm\",\n        6: \"Am\"\n    },\n    \"D#m\": {\n        1: \"Dm\",\n        4: \"Bm\",\n        6: \"Am\"\n    }\n};\n\n\n\nfunction $e2e1ea6dd3b7d2e1$export$fd31a53e6281557e(transposeKey, songKey) {\n    if (/^\\d+$/.test(transposeKey)) return parseInt(transposeKey, 10);\n    return (0, $918eb2016ac61e41$export$2e2bcd8739ae039).distance(songKey, transposeKey);\n}\nfunction $e2e1ea6dd3b7d2e1$var$chordTransposeDistance(capo, transposeKey, songKey, renderKey) {\n    let transpose = -1 * (capo || 0);\n    if (songKey) {\n        if (transposeKey) transpose += $e2e1ea6dd3b7d2e1$export$fd31a53e6281557e(transposeKey, songKey);\n        if (renderKey) transpose += (0, $918eb2016ac61e41$export$2e2bcd8739ae039).distance(songKey, renderKey);\n    }\n    return transpose;\n}\nfunction $e2e1ea6dd3b7d2e1$export$596ec52955da9472(chordString, line, song, renderKey = null) {\n    const chord = (0, $5e3a0c5a6197f95b$export$2e2bcd8739ae039).parse(chordString);\n    const songKey = song.key;\n    const capo = parseInt(song.metadata.getSingle((0, $b3836272a1374d85$export$866f445d49bad88e)), 10);\n    if (!chord) return chordString;\n    const effectiveTransposeDistance = $e2e1ea6dd3b7d2e1$var$chordTransposeDistance(capo, line.transposeKey, songKey, renderKey);\n    const effectiveKey = renderKey || (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrap(line.key || song.key)?.transpose(effectiveTransposeDistance) || null;\n    return chord.transpose(effectiveTransposeDistance).normalize(effectiveKey).toString();\n}\nfunction $e2e1ea6dd3b7d2e1$export$b07b16221c14aaa(key) {\n    return (0, $a181433de674b2b2$export$1ba61c6fa2f892a9)[(0, $918eb2016ac61e41$export$2e2bcd8739ae039).toString(key)];\n}\nfunction $e2e1ea6dd3b7d2e1$export$74743eda5dda3ccf(key) {\n    const keyObj = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrapOrFail(key);\n    return keyObj.isMinor() ? (0, $a181433de674b2b2$export$24a0bd6af7756225) : (0, $a181433de674b2b2$export$1e6f8e38ccd793b);\n}\n\n\n\n\n\n\n\nconst $a2a605be2775ff64$export$17c9e635b932873b = (item)=>item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039);\nconst $a2a605be2775ff64$export$3db5961874282581 = (line)=>line.items.some((item)=>item.isRenderable());\nconst $a2a605be2775ff64$export$3bf645f08efe3292 = (item)=>item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039);\nconst $a2a605be2775ff64$export$3ab01370f5e64ac8 = (item)=>item.name === \"comment\";\nfunction $a2a605be2775ff64$export$6ea1b0eb82ead3f(string) {\n    return string.trim().replace(/(<\\/[a-z]+>)\\s+(<)/g, \"$1$2\").replace(/(\\n)\\s+/g, \"\");\n}\nfunction $a2a605be2775ff64$export$79b2f7037acddd43(collection, callback) {\n    return collection.map(callback).join(\"\");\n}\nfunction $a2a605be2775ff64$export$a55877ca9db47377(condition, callback) {\n    return condition ? callback() : \"\";\n}\nfunction $a2a605be2775ff64$export$fae3166c418e0471(variables, callback) {\n    return callback.call(null, variables);\n}\nconst $a2a605be2775ff64$export$b8d631d9200974fa = (line)=>line.items.some((item)=>item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039) && !(0, $974bd1d260bb1d53$export$78d1711480f95c3e)(item.lyrics) || item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.isRenderable() || (0, $974bd1d260bb1d53$export$e3f63561d52b936d)(item));\nconst $a2a605be2775ff64$export$8a559c16cc3576 = (line)=>{\n    const classes = [\n        \"row\"\n    ];\n    if (!$a2a605be2775ff64$export$3db5961874282581(line)) classes.push(\"empty-line\");\n    return classes.join(\" \");\n};\nconst $a2a605be2775ff64$export$dcd1550c9709312c = (paragraph)=>{\n    const classes = [\n        \"paragraph\"\n    ];\n    if (paragraph.type !== (0, $234747a9630b4642$export$c5a6fe907430212e) && paragraph.type !== (0, $234747a9630b4642$export$c53d0f541b41b88e)) classes.push(paragraph.type);\n    return classes.join(\" \");\n};\nconst $a2a605be2775ff64$export$fef61f332f2c0afc = (item, metadata, configuration)=>{\n    if (!metadata) throw new Error(\"cannot evaluate, metadata is null\");\n    return item.evaluate(metadata, configuration.get(\"metadata.separator\"));\n};\nfunction $a2a605be2775ff64$export$ca030c9435779e4b(font) {\n    const cssString = font.toCssString();\n    if (cssString) return ` style=\"${cssString}\"`;\n    return \"\";\n}\n\n\n\n\n/**\n * Formats a song into a plain text chord sheet\n */ class $06a0261003eb9ba9$var$TextFormatter extends (0, $2dfa852662754780$export$2e2bcd8739ae039) {\n    song = new (0, $7860c26c4d50915f$export$2e2bcd8739ae039)();\n    /**\n   * Formats a song into a plain text chord sheet\n   * @param {Song} song The song to be formatted\n   * @returns {string} the chord sheet\n   */ format(song) {\n        this.song = song;\n        return [\n            this.formatHeader(),\n            this.formatParagraphs()\n        ].join(\"\");\n    }\n    formatHeader() {\n        const { title: title , subtitle: subtitle  } = this.song;\n        const separator = title || subtitle ? \"\\n\" : \"\";\n        return [\n            this.formatTitle(title),\n            this.formatSubTitle(subtitle),\n            separator\n        ].join(\"\");\n    }\n    formatParagraphs() {\n        const { bodyParagraphs: bodyParagraphs , metadata: metadata  } = this.song;\n        return bodyParagraphs.map((paragraph)=>this.formatParagraph(paragraph, metadata)).join(\"\\n\\n\");\n    }\n    formatParagraph(paragraph, metadata) {\n        return paragraph.lines.filter((line)=>line.hasRenderableItems()).map((line)=>this.formatLine(line, metadata)).join(\"\\n\");\n    }\n    formatLine(line, metadata) {\n        const parts = [\n            this.formatLineTop(line, metadata),\n            this.formatLineBottom(line, metadata)\n        ];\n        return parts.filter((p)=>!(0, $974bd1d260bb1d53$export$78d1711480f95c3e)(p)).map((part)=>(part || \"\").trimRight()).join(\"\\n\");\n    }\n    formatTitle(title) {\n        if (title) return `${title.toUpperCase()}\\n`;\n        return \"\";\n    }\n    formatSubTitle(subtitle) {\n        if (subtitle) return `${subtitle}\\n`;\n        return \"\";\n    }\n    formatLineTop(line, metadata) {\n        if ((0, $974bd1d260bb1d53$export$d332d76d125f0cbe)(line)) return this.formatLineWithFormatter(line, this.formatItemTop, metadata);\n        return null;\n    }\n    chordLyricsPairLength(chordLyricsPair, line) {\n        const chords = (0, $e2e1ea6dd3b7d2e1$export$596ec52955da9472)(chordLyricsPair.chords, line, this.song, this.configuration.key);\n        const { lyrics: lyrics  } = chordLyricsPair;\n        const chordsLength = (chords || \"\").length;\n        const lyricsLength = (lyrics || \"\").length;\n        if (chordsLength >= lyricsLength) return chordsLength + 1;\n        return Math.max(chordsLength, lyricsLength);\n    }\n    formatItemTop(item, _metadata, line) {\n        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.isRenderable()) return item.value || \"\";\n        if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) {\n            const chords = (0, $e2e1ea6dd3b7d2e1$export$596ec52955da9472)(item.chords, line, this.song, this.configuration.key);\n            return (0, $974bd1d260bb1d53$export$bc3bea8325045070)(chords, this.chordLyricsPairLength(item, line));\n        }\n        return \"\";\n    }\n    formatLineBottom(line, metadata) {\n        if ((0, $a2a605be2775ff64$export$b8d631d9200974fa)(line)) return this.formatLineWithFormatter(line, this.formatItemBottom, metadata);\n        return \"\";\n    }\n    formatLineWithFormatter(line, formatter, metadata) {\n        return line.items.map((item)=>formatter.call(this, item, metadata, line)).join(\"\");\n    }\n    formatItemBottom(item, metadata, line) {\n        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.isRenderable()) return item.value || \"\";\n        if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) return (0, $974bd1d260bb1d53$export$bc3bea8325045070)(item.lyrics || \"\", this.chordLyricsPairLength(item, line));\n        if (\"evaluate\" in item) return item.evaluate(metadata, this.configuration.get(\"metadata.separator\"));\n        return \"\";\n    }\n}\nvar $06a0261003eb9ba9$export$2e2bcd8739ae039 = $06a0261003eb9ba9$var$TextFormatter;\n\n\n\n\n/**\n * Acts as a base class for HTML formatters\n */ class $9ba0fb9ec815efc8$var$HtmlFormatter extends (0, $2dfa852662754780$export$2e2bcd8739ae039) {\n    /**\n   * Formats a song into HTML.\n   * @param {Song} song The song to be formatted\n   * @returns {string} The HTML string\n   */ format(song) {\n        return this.template({\n            song: song,\n            configuration: this.configuration\n        });\n    }\n    /**\n   * Generates basic CSS, optionally scoped within the provided selector, to use with the HTML output\n   * @deprecated\n   */ static cssString(_scope = \"\") {\n        (0, $974bd1d260bb1d53$export$c73e2a74b163f89e)(\"The class method cssString() was removed in favor of the instance PROPERTY. Please use `new <Formatter>().cssString` instead.\");\n    }\n    /**\n   * Generates basic CSS, optionally scoped within the provided selector, to use with the HTML output\n   *\n   * For example, execute cssString('.chordSheetViewer') will result in CSS like:\n   *\n   *     .chordSheetViewer .paragraph {\n   *       margin-bottom: 1em;\n   *     }\n   *\n   * @param scope the CSS scope to use, for example `.chordSheetViewer`\n   * @returns {string} the CSS string\n   */ cssString(scope = \"\") {\n        return (0, $974bd1d260bb1d53$export$59d377d2a2e0150a)(this.defaultCss, scope);\n    }\n    /**\n   * Basic CSS, in object style à la useStyles, to use with the HTML output\n   * @deprecated\n   */ static cssObject() {\n        (0, $974bd1d260bb1d53$export$c73e2a74b163f89e)(\"The class method cssObject() was removed in favor of the instance PROPERTY. Please use `new <Formatter>().cssObject` instead.\");\n    }\n    /**\n   * Basic CSS, in object style à la useStyles, to use with the HTML output\n   * For a CSS string see {@link cssString}\n   *\n   * Example:\n   *\n   *     '.paragraph': {\n   *       marginBottom: '1em'\n   *     }\n   *\n   * @return {Object.<string, Object.<string, string>>} the CSS object\n   */ get cssObject() {\n        return this.defaultCss;\n    }\n}\nvar $9ba0fb9ec815efc8$export$2e2bcd8739ae039 = $9ba0fb9ec815efc8$var$HtmlFormatter;\n\n\n\n\n\nvar $9940e2d1d4d0b0b9$export$2e2bcd8739ae039 = ({ configuration: configuration , configuration: { key: key  } , song: song , renderBlankLines: renderBlankLines = false , song: { title: title , subtitle: subtitle , bodyParagraphs: bodyParagraphs , bodyLines: bodyLines , metadata: metadata  }  })=>(0, $a2a605be2775ff64$export$6ea1b0eb82ead3f)(`\n  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(title, ()=>`<h1>${title}</h1>`)}\n  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(subtitle, ()=>`<h2>${subtitle}</h2>`)}\n\n  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(bodyLines.length > 0, ()=>`\n    <div class=\"chord-sheet\">\n      ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(bodyParagraphs, (paragraph)=>`\n        <div class=\"${(0, $a2a605be2775ff64$export$dcd1550c9709312c)(paragraph)}\">\n          ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(paragraph.lines, (line)=>`\n            ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(renderBlankLines || (0, $a2a605be2775ff64$export$3db5961874282581)(line), ()=>`\n              <table class=\"${(0, $a2a605be2775ff64$export$8a559c16cc3576)(line)}\">\n                ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $974bd1d260bb1d53$export$d332d76d125f0cbe)(line), ()=>`\n                  <tr>\n                    ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(line.items, (item)=>`\n                      ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$17c9e635b932873b)(item), ()=>`\n                        <td class=\"chord\">${(0, $e2e1ea6dd3b7d2e1$export$596ec52955da9472)(item.chords, line, song, key)}</td>\n                      `)}\n                    `)}\n                  </tr>\n                `)}\n                \n                ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$b8d631d9200974fa)(line), ()=>`\n                  <tr>\n                    ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(line.items, (item)=>`\n                      ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$17c9e635b932873b)(item), ()=>`\n                        <td class=\"lyrics\">${item.lyrics}</td>\n                      `)}\n                      \n                      ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$3bf645f08efe3292)(item), ()=>`\n                        ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$3ab01370f5e64ac8)(item), ()=>`\n                          <td class=\"comment\">${item.value}</td>\n                        `)}\n                        \n                        ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(item.hasRenderableLabel(), ()=>`\n                          <td><h3 class=\"label\">${item.value}</h3></td>\n                        `)}\n                      `)}\n                      \n                      ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $974bd1d260bb1d53$export$e3f63561d52b936d)(item), ()=>`\n                        <td class=\"lyrics\">${(0, $a2a605be2775ff64$export$fef61f332f2c0afc)(item, metadata, configuration)}</td>\n                      `)}\n                    `)}\n                  </tr>\n                `)}\n              </table>\n            `)}\n          `)}\n        </div>\n      `)}\n    </div>\n  `)}\n`);\n\n\n\nconst $fdcc84db82790d90$export$200cf2de69532aa8 = {\n    h1: {\n        fontSize: \"1.5em\"\n    },\n    h2: {\n        fontSize: \"1.1em\"\n    },\n    table: {\n        borderSpacing: \"0\",\n        color: \"inherit\"\n    },\n    td: {\n        padding: \"3px 0\"\n    },\n    \".chord:not(:last-child)\": {\n        paddingRight: \"10px\"\n    },\n    \".paragraph\": {\n        marginBottom: \"1em\"\n    }\n};\nfunction $fdcc84db82790d90$export$aa5b6043dd05348b(scope) {\n    return (0, $974bd1d260bb1d53$export$59d377d2a2e0150a)($fdcc84db82790d90$export$200cf2de69532aa8, scope);\n}\n/**\n * Formats a song into HTML. It uses TABLEs to align lyrics with chords, which makes the HTML for things like\n * PDF conversion.\n */ class $fdcc84db82790d90$var$HtmlTableFormatter extends (0, $9ba0fb9ec815efc8$export$2e2bcd8739ae039) {\n    get template() {\n        return 0, $9940e2d1d4d0b0b9$export$2e2bcd8739ae039;\n    }\n    get defaultCss() {\n        return $fdcc84db82790d90$export$200cf2de69532aa8;\n    }\n}\nvar $fdcc84db82790d90$export$2e2bcd8739ae039 = $fdcc84db82790d90$var$HtmlTableFormatter;\n\n\n\n\n\nvar $d6c38f6287712fb1$export$2e2bcd8739ae039 = ({ configuration: configuration , configuration: { key: key  } , song: song , renderBlankLines: renderBlankLines = false , song: { title: title , subtitle: subtitle , bodyParagraphs: bodyParagraphs , metadata: metadata  }  })=>(0, $a2a605be2775ff64$export$6ea1b0eb82ead3f)(`\n  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(title, ()=>`<h1>${title}</h1>`)}\n  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(subtitle, ()=>`<h2>${subtitle}</h2>`)}\n  \n  <div class=\"chord-sheet\">\n    ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(bodyParagraphs, (paragraph)=>`\n      <div class=\"${(0, $a2a605be2775ff64$export$dcd1550c9709312c)(paragraph)}\">\n        ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(paragraph.lines, (line)=>`\n          ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(renderBlankLines || (0, $a2a605be2775ff64$export$3db5961874282581)(line), ()=>`\n            <div class=\"${(0, $a2a605be2775ff64$export$8a559c16cc3576)(line)}\">\n              ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(line.items, (item)=>`\n                ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$17c9e635b932873b)(item), ()=>`\n                  <div class=\"column\">\n                    ${(0, $a2a605be2775ff64$export$fae3166c418e0471)([\n                            (0, $e2e1ea6dd3b7d2e1$export$596ec52955da9472)(item.chords, line, song, key)\n                        ], ([renderedChord])=>`\n                      <div class=\"chord\"${renderedChord ? (0, $a2a605be2775ff64$export$ca030c9435779e4b)(line.chordFont) : \"\"}>${renderedChord}</div>\n                    `)}\n                    <div class=\"lyrics\"${item.lyrics ? (0, $a2a605be2775ff64$export$ca030c9435779e4b)(line.textFont) : \"\"}>${item.lyrics}</div>\n                  </div>\n                `)}\n                \n                ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$3bf645f08efe3292)(item), ()=>`\n                  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$3ab01370f5e64ac8)(item), ()=>`\n                    <div class=\"comment\">${item.value}</div>\n                  `)}\n                  \n                  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(item.hasRenderableLabel(), ()=>`\n                    <h3 class=\"label\">${item.value}</h3>\n                  `)}\n                `)}\n                \n                ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $974bd1d260bb1d53$export$e3f63561d52b936d)(item), ()=>`\n                  <div class=\"column\">\n                    <div class=\"chord\"></div>\n                    \n                    ${(0, $a2a605be2775ff64$export$fae3166c418e0471)([\n                            (0, $a2a605be2775ff64$export$fef61f332f2c0afc)(item, metadata, configuration)\n                        ], ([evaluated])=>`\n                      <div class=\"lyrics\"${evaluated ? (0, $a2a605be2775ff64$export$ca030c9435779e4b)(line.textFont) : \"\"}>${evaluated}</div>\n                    `)}\n                  </div>\n                `)}\n              `)}\n            </div>\n          `)}\n        `)}\n      </div>\n    `)}\n  </div>\n`);\n\n\n\nconst $de6608cf7e39dfee$export$200cf2de69532aa8 = {\n    \".chord:not(:last-child)\": {\n        paddingRight: \"10px\"\n    },\n    \".paragraph\": {\n        marginBottom: \"1em\"\n    },\n    \".row\": {\n        display: \"flex\"\n    },\n    \".chord:after\": {\n        content: \"'\\\\200b'\"\n    },\n    \".lyrics:after\": {\n        content: \"'\\\\200b'\"\n    }\n};\nfunction $de6608cf7e39dfee$export$aa5b6043dd05348b(scope) {\n    return (0, $974bd1d260bb1d53$export$59d377d2a2e0150a)($de6608cf7e39dfee$export$200cf2de69532aa8, scope);\n}\n/**\n * Formats a song into HTML. It uses DIVs to align lyrics with chords, which makes it useful for responsive web pages.\n */ class $de6608cf7e39dfee$var$HtmlDivFormatter extends (0, $9ba0fb9ec815efc8$export$2e2bcd8739ae039) {\n    get template() {\n        return 0, $d6c38f6287712fb1$export$2e2bcd8739ae039;\n    }\n    get defaultCss() {\n        return $de6608cf7e39dfee$export$200cf2de69532aa8;\n    }\n}\nvar $de6608cf7e39dfee$export$2e2bcd8739ae039 = $de6608cf7e39dfee$var$HtmlDivFormatter;\n\n\n\n\n\n\n\nconst $feb758e68dd351a4$var$NEW_LINE = \"\\n\";\n/**\n * Formats a song into a ChordPro chord sheet\n */ class $feb758e68dd351a4$var$ChordProFormatter extends (0, $2dfa852662754780$export$2e2bcd8739ae039) {\n    /**\n   * Formats a song into a ChordPro chord sheet.\n   * @param {Song} song The song to be formatted\n   * @returns {string} The ChordPro string\n   */ format(song) {\n        const { lines: lines , metadata: metadata  } = song;\n        return lines.map((line)=>this.formatLine(line, metadata)).join($feb758e68dd351a4$var$NEW_LINE);\n    }\n    formatLine(line, metadata) {\n        return line.items.map((item)=>this.formatItem(item, metadata)).join(\"\");\n    }\n    formatItem(item, metadata) {\n        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039)) return this.formatTag(item);\n        if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) return this.formatChordLyricsPair(item);\n        if (\"evaluate\" in item) return this.formatOrEvaluateItem(item, metadata);\n        throw new Error(`Don't know how to format a ${item.constructor.name}`);\n    }\n    formatOrEvaluateItem(item, metadata) {\n        if (this.configuration.evaluate) return item.evaluate(metadata, this.configuration.get(\"metadata.separator\"));\n        if (item instanceof (0, $d6f43bad3b61b86a$export$2e2bcd8739ae039)) return this.formatTernary(item);\n        if (item instanceof (0, $758385c5b662d76d$export$2e2bcd8739ae039)) return item.evaluate();\n        throw new Error(`Don't know how to format a ${item.constructor.name}`);\n    }\n    formatTernary(ternary) {\n        const { variable: variable , valueTest: valueTest , trueExpression: trueExpression , falseExpression: falseExpression  } = ternary;\n        return [\n            \"%{\",\n            variable || \"\",\n            this.formatValueTest(valueTest),\n            this.formatExpressionRange(trueExpression),\n            this.formatExpressionRange(falseExpression),\n            \"}\"\n        ].join(\"\");\n    }\n    formatValueTest(valueTest) {\n        if (!valueTest) return \"\";\n        return `=${valueTest}`;\n    }\n    formatExpressionRange(expressionRange) {\n        if (!expressionRange.length) return \"\";\n        return `|${expressionRange.map((expression)=>this.formatExpression(expression)).join(\"\")}`;\n    }\n    formatExpression(expression) {\n        if (expression instanceof (0, $d6f43bad3b61b86a$export$2e2bcd8739ae039)) return this.formatTernary(expression);\n        if (expression instanceof (0, $758385c5b662d76d$export$2e2bcd8739ae039)) return expression.string;\n        return \"\";\n    }\n    formatTag(tag) {\n        if (tag.hasValue()) return `{${tag.originalName}: ${tag.value}}`;\n        return `{${tag.originalName}}`;\n    }\n    formatChordLyricsPair(chordLyricsPair) {\n        return [\n            this.formatChordLyricsPairChords(chordLyricsPair),\n            this.formatChordLyricsPairLyrics(chordLyricsPair)\n        ].join(\"\");\n    }\n    formatChordLyricsPairChords(chordLyricsPair) {\n        if (chordLyricsPair.chords) return `[${chordLyricsPair.chords}]`;\n        return \"\";\n    }\n    formatChordLyricsPairLyrics(chordLyricsPair) {\n        return chordLyricsPair.lyrics || \"\";\n    }\n}\nvar $feb758e68dd351a4$export$2e2bcd8739ae039 = $feb758e68dd351a4$var$ChordProFormatter;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar $149c1bd638913645$export$2e2bcd8739ae039 = {\n    ChordProParser: $8e2b91641771a21c$export$2e2bcd8739ae039,\n    ChordSheetParser: $9c17b505581d81bb$export$2e2bcd8739ae039,\n    ChordsOverWordsParser: $b72f5288e28a9b64$export$2e2bcd8739ae039,\n    UltimateGuitarParser: $7c59209366f6488e$export$2e2bcd8739ae039,\n    TextFormatter: $06a0261003eb9ba9$export$2e2bcd8739ae039,\n    HtmlTableFormatter: $fdcc84db82790d90$export$2e2bcd8739ae039,\n    HtmlDivFormatter: $de6608cf7e39dfee$export$2e2bcd8739ae039,\n    ChordProFormatter: $feb758e68dd351a4$export$2e2bcd8739ae039,\n    ChordLyricsPair: $f7a904d05353aafa$export$2e2bcd8739ae039,\n    Line: $06eb272065540fc1$export$2e2bcd8739ae039,\n    Song: $7860c26c4d50915f$export$2e2bcd8739ae039,\n    Tag: $b3836272a1374d85$export$2e2bcd8739ae039,\n    Comment: $df4ad73a744c94b3$export$2e2bcd8739ae039,\n    Metadata: $fdb42fd3b59812d4$export$2e2bcd8739ae039,\n    Paragraph: $55861b6d10167265$export$2e2bcd8739ae039,\n    Ternary: $d6f43bad3b61b86a$export$2e2bcd8739ae039,\n    Composite: $ba84a02c63f26e83$export$2e2bcd8739ae039,\n    Literal: $758385c5b662d76d$export$2e2bcd8739ae039,\n    ChordSheetSerializer: $2a399cf90c614489$export$2e2bcd8739ae039,\n    CHORUS: $234747a9630b4642$export$8db6c706fc9142b2,\n    INDETERMINATE: $234747a9630b4642$export$c5a6fe907430212e,\n    TAB: $234747a9630b4642$export$f1c9dd0f5207dd5e,\n    VERSE: $234747a9630b4642$export$4b194284baed1659,\n    NONE: $234747a9630b4642$export$c53d0f541b41b88e\n};\n\n\n\n//# sourceMappingURL=module.js.map\n\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/chordsheetjs/lib/module.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/main.sass":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/main.sass ***!
  \*********************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"@charset \\\"UTF-8\\\";\\n* {\\n  box-sizing: border-box;\\n}\\n\\nhtml {\\n  height: 100%;\\n}\\n\\nbody {\\n  background-color: #2F3131;\\n  color: #f8f8f8;\\n  display: flex;\\n  font-family: -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, Oxygen, Ubuntu, Cantarell, \\\"Fira Sans\\\", \\\"Droid Sans\\\", \\\"Helvetica Neue\\\", Arial, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\";\\n  font-size: 1em;\\n  margin: 0;\\n  max-height: 100%;\\n  min-height: 100%;\\n  padding: 20px;\\n}\\n\\n#root {\\n  display: flex;\\n  flex: 1 1 auto;\\n}\\n\\na {\\n  color: #A3ABB0;\\n  text-decoration: underline;\\n}\\na:hover {\\n  text-decoration: none;\\n}\\n\\nbutton, .button {\\n  -webkit-appearance: none;\\n  -moz-appearance: none;\\n  background-color: #3c82a9;\\n  border: 0;\\n  color: #f8f8f8;\\n  cursor: pointer;\\n  display: inline-block;\\n  font-family: inherit;\\n  font-size: inherit;\\n  margin: 0 10px 10px 0;\\n  padding: 5px 10px;\\n  text-decoration: none;\\n}\\nbutton.large, .button.large {\\n  padding: 10px 20px;\\n}\\nbutton:focus, .button:focus {\\n  box-shadow: 0 0 3px 3px rgba(60, 130, 169, 0.5);\\n}\\nbutton:hover, .button:hover {\\n  text-decoration: none;\\n}\\n\\n.App {\\n  display: flex;\\n  flex: 0 1 auto;\\n  flex-direction: column;\\n  max-height: 100%;\\n  overflow: hidden;\\n  width: 100%;\\n}\\n.App__container {\\n  display: flex;\\n  flex: 0 1 auto;\\n  flex-direction: column;\\n  height: 100%;\\n  overflow: hidden;\\n}\\n.App__columns {\\n  display: grid;\\n  flex: 0 1 auto;\\n  gap: 10px;\\n  grid-template-columns: repeat(2, 1fr);\\n  height: 100%;\\n}\\n.App__column {\\n  display: flex;\\n  flex-direction: column;\\n  max-height: 100%;\\n  overflow: hidden;\\n}\\n\\n.ChordSheetEditor {\\n  background-color: #f8f8f8;\\n  border: none;\\n  color: #2F3131;\\n  flex: 1 1 auto;\\n  font-family: Inconsolata, Monaco, \\\"Andale Mono\\\", \\\"Lucida Console\\\", \\\"Bitstream Vera Sans Mono\\\", \\\"Courier New\\\", Courier, monospace;\\n  font-size: 14px;\\n  outline: none;\\n  padding: 10px;\\n  transition: background-color 100ms ease-out;\\n}\\n.ChordSheetEditor:focus {\\n  background-color: #f8f8f8;\\n  box-shadow: 0 0 3px 3px rgba(248, 248, 248, 0.5);\\n}\\n\\n.ChordSheetViewer {\\n  background-color: #f8f8f8;\\n  color: #2F3131;\\n  flex: 1 0 auto;\\n  overflow: auto;\\n  padding: 10px;\\n  white-space: pre;\\n  width: 100%;\\n}\\n.ChordSheetViewer[data-mode=text] {\\n  font-family: Inconsolata, Monaco, \\\"Andale Mono\\\", \\\"Lucida Console\\\", \\\"Bitstream Vera Sans Mono\\\", \\\"Courier New\\\", Courier, monospace;\\n  font-size: 14px;\\n  outline-color: rgba(248, 248, 248, 0.5);\\n  transition: background-color 100ms ease-out;\\n}\\n.ChordSheetViewer[data-mode=html] h2 {\\n  font-size: 1.1em;\\n}\\n.ChordSheetViewer[data-mode=html] .chord {\\n  font-weight: 600;\\n}\\n.ChordSheetViewer[data-mode=html] .chord:not(:last-child) {\\n  padding-right: 10px;\\n}\\n.ChordSheetViewer[data-mode=html] .empty-line {\\n  height: 1em;\\n}\\n.ChordSheetViewer[data-mode=html] .paragraph {\\n  margin-bottom: 1em;\\n}\\n.ChordSheetViewer[data-mode=html] .chord:not(:last-child) {\\n  padding-right: 10px;\\n}\\n.ChordSheetViewer[data-mode=html] .chord:after,\\n.ChordSheetViewer[data-mode=html] .lyrics:after {\\n  content: \\\"​\\\";\\n}\\n.ChordSheetViewer[data-mode=html] .row {\\n  display: flex;\\n  line-height: 150%;\\n}\\n\\n.EditorContainer {\\n  display: flex;\\n  flex-direction: row;\\n  flex: 1 1 auto;\\n  max-height: 100%;\\n  overflow: hidden;\\n}\\n.EditorContainer__editor {\\n  border-left: 1px #2F3131 solid;\\n  flex: 1 0 auto;\\n}\\n.EditorContainer__lineNumbers {\\n  flex: 0 0 85px;\\n  margin-right: -20px;\\n  padding-right: 48px;\\n}\\n.EditorContainer__errorMessage {\\n  background: red;\\n  margin-top: 10px;\\n  padding: 10px;\\n}\\n.EditorContainer__errorMessage:empty {\\n  display: none;\\n}\\n\\n.Header {\\n  color: #f8f8f8;\\n  flex: 0 0 50px;\\n}\\n.Header__wrapper {\\n  display: flex;\\n  padding: 10px 5px;\\n}\\n.Header__site-name {\\n  display: inline-block;\\n  flex: 1 0 auto;\\n  font-family: Inconsolata, Monaco, \\\"Andale Mono\\\", \\\"Lucida Console\\\", \\\"Bitstream Vera Sans Mono\\\", \\\"Courier New\\\", Courier, monospace;\\n  margin: 0;\\n}\\n.Header__site-name a,\\n.Header__site-name a:hover {\\n  color: #ffae00;\\n  text-decoration: none;\\n}\\n.Header__navigation {\\n  display: inline-block;\\n  flex: 0 0 auto;\\n  list-style: none;\\n}\\n.Header__navigation li {\\n  display: inline-block;\\n}\\n.Header__navigation li + * {\\n  border-left: 1px #f8f8f8 solid;\\n  margin-left: 20px;\\n  padding-left: 20px;\\n}\\n\\n.ImportDialog {\\n  background: #f8f8f8;\\n  border: 1px #3c82a9 solid;\\n  box-shadow: 0 0 5px #3c82a9;\\n  bottom: 0;\\n  color: #2F3131;\\n  display: none;\\n  left: 0;\\n  margin: auto;\\n  max-height: 90vh;\\n  max-width: 90vw;\\n  padding: 30px 50px;\\n  position: absolute;\\n  right: 0;\\n  top: 0;\\n}\\n.ImportDialog--visible {\\n  display: flex;\\n}\\n.ImportDialog__close-button {\\n  background: transparent;\\n  color: #A3ABB0;\\n  font-size: 38.4px;\\n  font-weight: 700;\\n  line-height: 16px;\\n  position: absolute;\\n  right: 2.5vw;\\n  text-decoration: none;\\n  top: 2.5vw;\\n}\\n.ImportDialog__contents {\\n  display: flex;\\n  flex: 1 0 auto;\\n  flex-direction: column;\\n  max-height: 100%;\\n  overflow: auto;\\n}\\n.ImportDialog__buttons {\\n  padding-top: 10px;\\n}\\n.ImportDialog__editor {\\n  border: 1px #3c82a9 solid;\\n}\\n\\n.LineNumbers {\\n  overflow: auto;\\n  text-align: right;\\n}\\n.LineNumbers__error {\\n  color: red;\\n  display: inline-block;\\n  position: relative;\\n}\\n.LineNumbers__error:after {\\n  content: \\\"⚠️\\\";\\n  font-size: 22px;\\n  margin-top: -1px;\\n  position: absolute;\\n  right: -26px;\\n  top: 50%;\\n  transform: translate(0, -50%);\\n}\\n\\n.RadioGroup {\\n  list-style: none;\\n  margin: 0;\\n  padding: 10px 0;\\n}\\n.RadioGroup__option {\\n  display: inline-block;\\n}\\n.RadioGroup__option + .RadioGroup__option {\\n  margin-left: 20px;\\n}\\n.RadioGroup__radio {\\n  opacity: 0;\\n  width: 0;\\n}\\n.RadioGroup__label {\\n  cursor: pointer;\\n  line-height: 31px;\\n  padding-left: 21px;\\n  position: relative;\\n}\\n.RadioGroup__label:before, .RadioGroup__label:after {\\n  border-radius: 50%;\\n  position: absolute;\\n  transform: translate(0, -50%);\\n  top: 50%;\\n}\\n.RadioGroup__label:before {\\n  background-color: #f8f8f8;\\n  content: \\\"\\\";\\n  height: 14px;\\n  left: 0;\\n  width: 14px;\\n}\\n.RadioGroup__radio:focus ~ .RadioGroup__label:before {\\n  border-color: #3c82a9;\\n  box-shadow: 0 0 3px 3px #3c82a9;\\n}\\n.RadioGroup__radio:checked ~ .RadioGroup__label:after {\\n  background-color: #3c82a9;\\n  content: \\\"\\\";\\n  height: 8px;\\n  left: 3px;\\n  width: 8px;\\n}\\n\\n.Toolbar {\\n  display: flex;\\n  flex-wrap: wrap;\\n  list-style: none;\\n  margin: 0;\\n  padding: 10px 0 0 0;\\n}\\n.Toolbar button, .Toolbar .button {\\n  height: 31px;\\n}\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://ChordFiddle/./src/sass/main.sass?./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/decode-uri-component/index.js":
/*!****************************************************!*\
  !*** ./node_modules/decode-uri-component/index.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn [decodeURIComponent(components.join(''))];\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher) || [];\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher) || [];\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/decode-uri-component/index.js?");

/***/ }),

/***/ "./node_modules/filter-obj/index.js":
/*!******************************************!*\
  !*** ./node_modules/filter-obj/index.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (obj, predicate) {\n\tvar ret = {};\n\tvar keys = Object.keys(obj);\n\tvar isArr = Array.isArray(predicate);\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar val = obj[key];\n\n\t\tif (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {\n\t\t\tret[key] = val;\n\t\t}\n\t}\n\n\treturn ret;\n};\n\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/filter-obj/index.js?");

/***/ }),

/***/ "./node_modules/lodash.get/index.js":
/*!******************************************!*\
  !*** ./node_modules/lodash.get/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/lodash.get/index.js?");

/***/ }),

/***/ "./node_modules/lz-string/libs/lz-string.js":
/*!**************************************************!*\
  !*** ./node_modules/lz-string/libs/lz-string.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>\n// This work is free. You can redistribute it and/or modify it\n// under the terms of the WTFPL, Version 2\n// For more information see LICENSE.txt or http://www.wtfpl.net/\n//\n// For more information, the home page:\n// http://pieroxy.net/blog/pages/lz-string/testing.html\n//\n// LZ-based compression algorithm, version 1.4.4\nvar LZString = (function() {\n\n// private property\nvar f = String.fromCharCode;\nvar keyStrBase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nvar keyStrUriSafe = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$\";\nvar baseReverseDic = {};\n\nfunction getBaseValue(alphabet, character) {\n  if (!baseReverseDic[alphabet]) {\n    baseReverseDic[alphabet] = {};\n    for (var i=0 ; i<alphabet.length ; i++) {\n      baseReverseDic[alphabet][alphabet.charAt(i)] = i;\n    }\n  }\n  return baseReverseDic[alphabet][character];\n}\n\nvar LZString = {\n  compressToBase64 : function (input) {\n    if (input == null) return \"\";\n    var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});\n    switch (res.length % 4) { // To produce valid Base64\n    default: // When could this happen ?\n    case 0 : return res;\n    case 1 : return res+\"===\";\n    case 2 : return res+\"==\";\n    case 3 : return res+\"=\";\n    }\n  },\n\n  decompressFromBase64 : function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });\n  },\n\n  compressToUTF16 : function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 15, function(a){return f(a+32);}) + \" \";\n  },\n\n  decompressFromUTF16: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });\n  },\n\n  //compress into uint8array (UCS-2 big endian format)\n  compressToUint8Array: function (uncompressed) {\n    var compressed = LZString.compress(uncompressed);\n    var buf=new Uint8Array(compressed.length*2); // 2 bytes per character\n\n    for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {\n      var current_value = compressed.charCodeAt(i);\n      buf[i*2] = current_value >>> 8;\n      buf[i*2+1] = current_value % 256;\n    }\n    return buf;\n  },\n\n  //decompress from uint8array (UCS-2 big endian format)\n  decompressFromUint8Array:function (compressed) {\n    if (compressed===null || compressed===undefined){\n        return LZString.decompress(compressed);\n    } else {\n        var buf=new Array(compressed.length/2); // 2 bytes per character\n        for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {\n          buf[i]=compressed[i*2]*256+compressed[i*2+1];\n        }\n\n        var result = [];\n        buf.forEach(function (c) {\n          result.push(f(c));\n        });\n        return LZString.decompress(result.join(''));\n\n    }\n\n  },\n\n\n  //compress into a string that is already URI encoded\n  compressToEncodedURIComponent: function (input) {\n    if (input == null) return \"\";\n    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});\n  },\n\n  //decompress from an output of compressToEncodedURIComponent\n  decompressFromEncodedURIComponent:function (input) {\n    if (input == null) return \"\";\n    if (input == \"\") return null;\n    input = input.replace(/ /g, \"+\");\n    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });\n  },\n\n  compress: function (uncompressed) {\n    return LZString._compress(uncompressed, 16, function(a){return f(a);});\n  },\n  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {\n    if (uncompressed == null) return \"\";\n    var i, value,\n        context_dictionary= {},\n        context_dictionaryToCreate= {},\n        context_c=\"\",\n        context_wc=\"\",\n        context_w=\"\",\n        context_enlargeIn= 2, // Compensate for the first entry which should not count\n        context_dictSize= 3,\n        context_numBits= 2,\n        context_data=[],\n        context_data_val=0,\n        context_data_position=0,\n        ii;\n\n    for (ii = 0; ii < uncompressed.length; ii += 1) {\n      context_c = uncompressed.charAt(ii);\n      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {\n        context_dictionary[context_c] = context_dictSize++;\n        context_dictionaryToCreate[context_c] = true;\n      }\n\n      context_wc = context_w + context_c;\n      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {\n        context_w = context_wc;\n      } else {\n        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n          if (context_w.charCodeAt(0)<256) {\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<8 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          } else {\n            value = 1;\n            for (i=0 ; i<context_numBits ; i++) {\n              context_data_val = (context_data_val << 1) | value;\n              if (context_data_position ==bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = 0;\n            }\n            value = context_w.charCodeAt(0);\n            for (i=0 ; i<16 ; i++) {\n              context_data_val = (context_data_val << 1) | (value&1);\n              if (context_data_position == bitsPerChar-1) {\n                context_data_position = 0;\n                context_data.push(getCharFromInt(context_data_val));\n                context_data_val = 0;\n              } else {\n                context_data_position++;\n              }\n              value = value >> 1;\n            }\n          }\n          context_enlargeIn--;\n          if (context_enlargeIn == 0) {\n            context_enlargeIn = Math.pow(2, context_numBits);\n            context_numBits++;\n          }\n          delete context_dictionaryToCreate[context_w];\n        } else {\n          value = context_dictionary[context_w];\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n\n\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        // Add wc to the dictionary.\n        context_dictionary[context_wc] = context_dictSize++;\n        context_w = String(context_c);\n      }\n    }\n\n    // Output the code for w.\n    if (context_w !== \"\") {\n      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {\n        if (context_w.charCodeAt(0)<256) {\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<8 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        } else {\n          value = 1;\n          for (i=0 ; i<context_numBits ; i++) {\n            context_data_val = (context_data_val << 1) | value;\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = 0;\n          }\n          value = context_w.charCodeAt(0);\n          for (i=0 ; i<16 ; i++) {\n            context_data_val = (context_data_val << 1) | (value&1);\n            if (context_data_position == bitsPerChar-1) {\n              context_data_position = 0;\n              context_data.push(getCharFromInt(context_data_val));\n              context_data_val = 0;\n            } else {\n              context_data_position++;\n            }\n            value = value >> 1;\n          }\n        }\n        context_enlargeIn--;\n        if (context_enlargeIn == 0) {\n          context_enlargeIn = Math.pow(2, context_numBits);\n          context_numBits++;\n        }\n        delete context_dictionaryToCreate[context_w];\n      } else {\n        value = context_dictionary[context_w];\n        for (i=0 ; i<context_numBits ; i++) {\n          context_data_val = (context_data_val << 1) | (value&1);\n          if (context_data_position == bitsPerChar-1) {\n            context_data_position = 0;\n            context_data.push(getCharFromInt(context_data_val));\n            context_data_val = 0;\n          } else {\n            context_data_position++;\n          }\n          value = value >> 1;\n        }\n\n\n      }\n      context_enlargeIn--;\n      if (context_enlargeIn == 0) {\n        context_enlargeIn = Math.pow(2, context_numBits);\n        context_numBits++;\n      }\n    }\n\n    // Mark the end of the stream\n    value = 2;\n    for (i=0 ; i<context_numBits ; i++) {\n      context_data_val = (context_data_val << 1) | (value&1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data_position = 0;\n        context_data.push(getCharFromInt(context_data_val));\n        context_data_val = 0;\n      } else {\n        context_data_position++;\n      }\n      value = value >> 1;\n    }\n\n    // Flush the last char\n    while (true) {\n      context_data_val = (context_data_val << 1);\n      if (context_data_position == bitsPerChar-1) {\n        context_data.push(getCharFromInt(context_data_val));\n        break;\n      }\n      else context_data_position++;\n    }\n    return context_data.join('');\n  },\n\n  decompress: function (compressed) {\n    if (compressed == null) return \"\";\n    if (compressed == \"\") return null;\n    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });\n  },\n\n  _decompress: function (length, resetValue, getNextValue) {\n    var dictionary = [],\n        next,\n        enlargeIn = 4,\n        dictSize = 4,\n        numBits = 3,\n        entry = \"\",\n        result = [],\n        i,\n        w,\n        bits, resb, maxpower, power,\n        c,\n        data = {val:getNextValue(0), position:resetValue, index:1};\n\n    for (i = 0; i < 3; i += 1) {\n      dictionary[i] = i;\n    }\n\n    bits = 0;\n    maxpower = Math.pow(2,2);\n    power=1;\n    while (power!=maxpower) {\n      resb = data.val & data.position;\n      data.position >>= 1;\n      if (data.position == 0) {\n        data.position = resetValue;\n        data.val = getNextValue(data.index++);\n      }\n      bits |= (resb>0 ? 1 : 0) * power;\n      power <<= 1;\n    }\n\n    switch (next = bits) {\n      case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n        c = f(bits);\n        break;\n      case 2:\n        return \"\";\n    }\n    dictionary[3] = c;\n    w = c;\n    result.push(c);\n    while (true) {\n      if (data.index > length) {\n        return \"\";\n      }\n\n      bits = 0;\n      maxpower = Math.pow(2,numBits);\n      power=1;\n      while (power!=maxpower) {\n        resb = data.val & data.position;\n        data.position >>= 1;\n        if (data.position == 0) {\n          data.position = resetValue;\n          data.val = getNextValue(data.index++);\n        }\n        bits |= (resb>0 ? 1 : 0) * power;\n        power <<= 1;\n      }\n\n      switch (c = bits) {\n        case 0:\n          bits = 0;\n          maxpower = Math.pow(2,8);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 1:\n          bits = 0;\n          maxpower = Math.pow(2,16);\n          power=1;\n          while (power!=maxpower) {\n            resb = data.val & data.position;\n            data.position >>= 1;\n            if (data.position == 0) {\n              data.position = resetValue;\n              data.val = getNextValue(data.index++);\n            }\n            bits |= (resb>0 ? 1 : 0) * power;\n            power <<= 1;\n          }\n          dictionary[dictSize++] = f(bits);\n          c = dictSize-1;\n          enlargeIn--;\n          break;\n        case 2:\n          return result.join('');\n      }\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n      if (dictionary[c]) {\n        entry = dictionary[c];\n      } else {\n        if (c === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n      result.push(entry);\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n      enlargeIn--;\n\n      w = entry;\n\n      if (enlargeIn == 0) {\n        enlargeIn = Math.pow(2, numBits);\n        numBits++;\n      }\n\n    }\n  }\n};\n  return LZString;\n})();\n\nif (true) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return LZString; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/lz-string/libs/lz-string.js?");

/***/ }),

/***/ "./node_modules/query-string/index.js":
/*!********************************************!*\
  !*** ./node_modules/query-string/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst strictUriEncode = __webpack_require__(/*! strict-uri-encode */ \"./node_modules/strict-uri-encode/index.js\");\nconst decodeComponent = __webpack_require__(/*! decode-uri-component */ \"./node_modules/decode-uri-component/index.js\");\nconst splitOnFirst = __webpack_require__(/*! split-on-first */ \"./node_modules/split-on-first/index.js\");\nconst filterObject = __webpack_require__(/*! filter-obj */ \"./node_modules/filter-obj/index.js\");\n\nconst isNullOrUndefined = value => value === null || value === undefined;\n\nconst encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[', index, ']'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')\n\t\t\t\t];\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[]'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'colon-list-separator':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), ':list='].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), ':list=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\tcase 'bracket-separator': {\n\t\t\tconst keyValueSep = options.arrayFormat === 'bracket-separator' ?\n\t\t\t\t'[]=' :\n\t\t\t\t'=';\n\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// Translate null to an empty string so that it doesn't serialize as 'null'\n\t\t\t\tvalue = value === null ? '' : value;\n\n\t\t\t\tif (result.length === 0) {\n\t\t\t\t\treturn [[encode(key, options), keyValueSep, encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(options.arrayFormatSeparator)];\n\t\t\t};\n\t\t}\n\n\t\tdefault:\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, encode(key, options)];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'colon-list-separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(:list)$/.exec(key);\n\t\t\t\tkey = key.replace(/:list$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);\n\t\t\t\tconst isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));\n\t\t\t\tvalue = isEncodedArray ? decode(value, options) : value;\n\t\t\t\tconst newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\n\t\tcase 'bracket-separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = /(\\[\\])$/.test(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!isArray) {\n\t\t\t\t\taccumulator[key] = value ? decode(value, options) : value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst arrayValue = value === null ?\n\t\t\t\t\t[] :\n\t\t\t\t\tvalue.split(options.arrayFormatSeparator).map(item => decode(item, options));\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = arrayValue;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], arrayValue);\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction validateArrayFormatSeparator(value) {\n\tif (typeof value !== 'string' || value.length !== 1) {\n\t\tthrow new TypeError('arrayFormatSeparator must be single character string');\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction getHash(url) {\n\tlet hash = '';\n\tconst hashStart = url.indexOf('#');\n\tif (hashStart !== -1) {\n\t\thash = url.slice(hashStart);\n\t}\n\n\treturn hash;\n}\n\nfunction extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nfunction parseValue(value, options) {\n\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\tvalue = Number(value);\n\t} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\tvalue = value.toLowerCase() === 'true';\n\t}\n\n\treturn value;\n}\n\nfunction parse(query, options) {\n\toptions = Object.assign({\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ',',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst ret = Object.create(null);\n\n\tif (typeof query !== 'string') {\n\t\treturn ret;\n\t}\n\n\tquery = query.trim().replace(/^[?#&]/, '');\n\n\tif (!query) {\n\t\treturn ret;\n\t}\n\n\tfor (const param of query.split('&')) {\n\t\tif (param === '') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet [key, value] = splitOnFirst(options.decode ? param.replace(/\\+/g, ' ') : param, '=');\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);\n\t\tformatter(decode(key, options), value, ret);\n\t}\n\n\tfor (const key of Object.keys(ret)) {\n\t\tconst value = ret[key];\n\t\tif (typeof value === 'object' && value !== null) {\n\t\t\tfor (const k of Object.keys(value)) {\n\t\t\t\tvalue[k] = parseValue(value[k], options);\n\t\t\t}\n\t\t} else {\n\t\t\tret[key] = parseValue(value, options);\n\t\t}\n\t}\n\n\tif (options.sort === false) {\n\t\treturn ret;\n\t}\n\n\treturn (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = ret[key];\n\t\tif (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(value);\n\t\t} else {\n\t\t\tresult[key] = value;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = (object, options) => {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ','\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst shouldFilter = key => (\n\t\t(options.skipNull && isNullOrUndefined(object[key])) ||\n\t\t(options.skipEmptyString && object[key] === '')\n\t);\n\n\tconst formatter = encoderForArrayFormat(options);\n\n\tconst objectCopy = {};\n\n\tfor (const key of Object.keys(object)) {\n\t\tif (!shouldFilter(key)) {\n\t\t\tobjectCopy[key] = object[key];\n\t\t}\n\t}\n\n\tconst keys = Object.keys(objectCopy);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\tif (value.length === 0 && options.arrayFormat === 'bracket-separator') {\n\t\t\t\treturn encode(key, options) + '[]';\n\t\t\t}\n\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n};\n\nexports.parseUrl = (url, options) => {\n\toptions = Object.assign({\n\t\tdecode: true\n\t}, options);\n\n\tconst [url_, hash] = splitOnFirst(url, '#');\n\n\treturn Object.assign(\n\t\t{\n\t\t\turl: url_.split('?')[0] || '',\n\t\t\tquery: parse(extract(url), options)\n\t\t},\n\t\toptions && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}\n\t);\n};\n\nexports.stringifyUrl = (object, options) => {\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\t[encodeFragmentIdentifier]: true\n\t}, options);\n\n\tconst url = removeHash(object.url).split('?')[0] || '';\n\tconst queryFromUrl = exports.extract(object.url);\n\tconst parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});\n\n\tconst query = Object.assign(parsedQueryFromUrl, object.query);\n\tlet queryString = exports.stringify(query, options);\n\tif (queryString) {\n\t\tqueryString = `?${queryString}`;\n\t}\n\n\tlet hash = getHash(object.url);\n\tif (object.fragmentIdentifier) {\n\t\thash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;\n\t}\n\n\treturn `${url}${queryString}${hash}`;\n};\n\nexports.pick = (input, filter, options) => {\n\toptions = Object.assign({\n\t\tparseFragmentIdentifier: true,\n\t\t[encodeFragmentIdentifier]: false\n\t}, options);\n\n\tconst {url, query, fragmentIdentifier} = exports.parseUrl(input, options);\n\treturn exports.stringifyUrl({\n\t\turl,\n\t\tquery: filterObject(query, filter),\n\t\tfragmentIdentifier\n\t}, options);\n};\n\nexports.exclude = (input, filter, options) => {\n\tconst exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);\n\n\treturn exports.pick(input, exclusionFilter, options);\n};\n\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/query-string/index.js?");

/***/ }),

/***/ "./node_modules/split-on-first/index.js":
/*!**********************************************!*\
  !*** ./node_modules/split-on-first/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = (string, separator) => {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (separator === '') {\n\t\treturn [string];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [string];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n};\n\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/split-on-first/index.js?");

/***/ }),

/***/ "./node_modules/strict-uri-encode/index.js":
/*!*************************************************!*\
  !*** ./node_modules/strict-uri-encode/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/strict-uri-encode/index.js?");

/***/ }),

/***/ "./src/sass/main.sass":
/*!****************************!*\
  !*** ./src/sass/main.sass ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_sass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./main.sass */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/sass/main.sass\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_sass__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_sass__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_sass__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_main_sass__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://ChordFiddle/./src/sass/main.sass?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://ChordFiddle/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var chordsheetjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chordsheetjs */ \"./node_modules/chordsheetjs/lib/module.js\");\n/* harmony import */ var _sass_main_sass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sass/main.sass */ \"./src/sass/main.sass\");\n/* harmony import */ var _js_chord_sheet_transformations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/chord_sheet_transformations */ \"./src/js/chord_sheet_transformations.js\");\n/* harmony import */ var _js_location_hash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./js/location_hash */ \"./src/js/location_hash.js\");\n/* harmony import */ var _js_chord_sheet_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./js/chord_sheet_editor */ \"./src/js/chord_sheet_editor.js\");\n/* harmony import */ var _js_chord_sheet_viewer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./js/chord_sheet_viewer */ \"./src/js/chord_sheet_viewer.js\");\n/* harmony import */ var _js_import_dialog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./js/import_dialog */ \"./src/js/import_dialog.js\");\n/* harmony import */ var _js_toolbar__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./js/toolbar */ \"./src/js/toolbar.js\");\n\n\n\n\n\n\n\n\n\n\n\nlet song = null;\n\nconst chordSheetEditor = new _js_chord_sheet_editor__WEBPACK_IMPORTED_MODULE_4__[\"default\"]('chordSheetEditor');\nconst chordSheetViewer = new _js_chord_sheet_viewer__WEBPACK_IMPORTED_MODULE_5__[\"default\"]('chordSheetViewer');\n\nfunction onChordSheetChange(chordSheet) {\n  (0,_js_location_hash__WEBPACK_IMPORTED_MODULE_3__.setChordSheet)(chordSheet);\n\n  try {\n    const parser = new chordsheetjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ChordProParser();\n    song = parser.parse(chordSheet);\n    chordSheetViewer.render(song);\n    chordSheetEditor.resetError();\n  } catch ({ message, location }) {\n    chordSheetEditor.showError(message, location.start.line);\n  }\n}\n\nchordSheetEditor.onChordSheetChange = onChordSheetChange;\n\nchordSheetViewer.onDisplayModeChanged = (displayMode) => {\n  (0,_js_location_hash__WEBPACK_IMPORTED_MODULE_3__.setDisplayMode)(displayMode);\n  chordSheetViewer.render(song);\n};\n\nconst importDialog = new _js_import_dialog__WEBPACK_IMPORTED_MODULE_6__[\"default\"]('importDialog');\n\nimportDialog.onImportConfirmed = (chordSheet) => {\n  const chordProSheet = (0,_js_chord_sheet_transformations__WEBPACK_IMPORTED_MODULE_2__.convertChordSheetToChordPro)(chordSheet);\n  chordSheetEditor.setValue(chordProSheet);\n  onChordSheetChange(chordProSheet);\n};\n\nconst toolbar = new _js_toolbar__WEBPACK_IMPORTED_MODULE_7__[\"default\"]('toolbar');\ntoolbar.onTransformClick = (transform) => chordSheetEditor.transformChordSheet(transform);\ntoolbar.onImportChordSheetClick = () => importDialog.open();\n\nconst { chordSheet, displayMode } = (0,_js_location_hash__WEBPACK_IMPORTED_MODULE_3__.getQueryParams)();\n\nif (displayMode) {\n  chordSheetViewer.setSelectedMode(displayMode);\n}\n\nif (chordSheet) {\n  chordSheetEditor.setValue(chordSheet);\n  onChordSheetChange(chordSheet);\n} else {\n  onChordSheetChange(chordSheetEditor.getValue());\n}\n\nchordSheetEditor.updateLineNumbers();\n\n\n//# sourceURL=webpack://ChordFiddle/./src/index.js?");

/***/ }),

/***/ "./src/js/chord_sheet_editor.js":
/*!**************************************!*\
  !*** ./src/js/chord_sheet_editor.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ \"./src/js/component.js\");\n/* harmony import */ var _value_with_history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./value_with_history */ \"./src/js/value_with_history.js\");\n/* harmony import */ var _debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./debounce */ \"./src/js/debounce.js\");\n\n\n\n\nclass ChordSheetEditor extends _component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  onChordSheetChange = () => {};\n\n  errorLineNumber = (0,_value_with_history__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(null);\n\n  setup() {\n    this.container.addEventListener('input', (0,_debounce__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(() => {\n      this.onChordSheetChange(this.getValue());\n      this.updateLineNumbers();\n    }));\n\n    this.container.addEventListener('scroll', () => {\n      this.lineNumbersContainer.scrollTop = this.container.scrollTop;\n    });\n  }\n\n  get lineNumbersContainer() {\n    return this.element('lineNumbers');\n  }\n\n  updateLineNumbers() {\n    const lineNumbers = this.lineNumbersContainer.innerText.split('\\n').filter((t) => t);\n    const editorLineCount = this.getValue().split('\\n').length;\n    const previousErrorLine = this.errorLineNumber.valueWas;\n    const newErrorLine = this.errorLineNumber.value;\n\n    if (previousErrorLine) {\n      lineNumbers[previousErrorLine - 1] = `${previousErrorLine}`;\n    }\n\n    if (newErrorLine) {\n      lineNumbers[newErrorLine - 1] = `<div class=\"LineNumbers__error\">${newErrorLine}</div>`;\n    }\n\n    if (lineNumbers.length > editorLineCount) {\n      lineNumbers.splice(editorLineCount);\n    }\n\n    while (lineNumbers.length < editorLineCount) {\n      lineNumbers.push(`${lineNumbers.length + 1}`);\n    }\n\n    this.lineNumbersContainer.innerHTML = lineNumbers.join('<br>');\n  }\n\n  getSelectionRange() {\n    const { selectionStart, selectionEnd } = this.container;\n    return [selectionStart, selectionEnd];\n  }\n\n  setSelectionRange(selectionStart, selectionEnd) {\n    this.container.setSelectionRange(selectionStart, selectionEnd);\n  }\n\n  focus() {\n    this.container.focus();\n  }\n\n  getValue() {\n    return this.container.value;\n  }\n\n  setValue(value) {\n    this.container.value = value;\n    this.updateLineNumbers();\n  }\n\n  setError(error) {\n    this.element('errorMessage').innerText = error;\n  }\n\n  showError(message, line) {\n    this.setError(`Line ${line}: ${message}`);\n    this.errorLineNumber.set(line);\n  }\n\n  resetError() {\n    this.setError('');\n    this.errorLineNumber.set(null);\n  }\n\n  transformChordSheet(transformationFunc) {\n    const [selectionStart, selectionEnd] = this.getSelectionRange();\n    const originalChordSheet = this.getValue();\n\n    if (selectionStart === selectionEnd) {\n      const newChordSheet = transformationFunc(originalChordSheet);\n      const newCursorPosition = this.calculateNewCursorPosition(originalChordSheet, newChordSheet, selectionStart);\n      this.setValue(newChordSheet);\n      this.focus();\n      this.setSelectionRange(newCursorPosition, newCursorPosition);\n    } else {\n      const selection = originalChordSheet.slice(selectionStart, selectionEnd);\n      const prefix = originalChordSheet.slice(0, selectionStart);\n      const suffix = originalChordSheet.slice(selectionEnd);\n      const replacement = transformationFunc(selection);\n      this.setValue([prefix, replacement, suffix].join(''));\n      this.focus();\n      this.setSelectionRange(selectionStart, selectionStart + replacement.length);\n    }\n  }\n\n  calculateNewCursorPosition(originalChordSheet, newChordSheet, cursorPosition) {\n    if (cursorPosition === 0) {\n      return 0;\n    }\n\n    if (cursorPosition === originalChordSheet.length - 1) {\n      return newChordSheet.length;\n    }\n\n    return cursorPosition;\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChordSheetEditor);\n\n\n//# sourceURL=webpack://ChordFiddle/./src/js/chord_sheet_editor.js?");

/***/ }),

/***/ "./src/js/chord_sheet_transformations.js":
/*!***********************************************!*\
  !*** ./src/js/chord_sheet_transformations.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"convertChordSheetToChordPro\": () => (/* binding */ convertChordSheetToChordPro),\n/* harmony export */   \"switchToFlat\": () => (/* binding */ switchToFlat),\n/* harmony export */   \"switchToSharp\": () => (/* binding */ switchToSharp),\n/* harmony export */   \"transposeDown\": () => (/* binding */ transposeDown),\n/* harmony export */   \"transposeUp\": () => (/* binding */ transposeUp)\n/* harmony export */ });\n/* harmony import */ var chordsheetjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chordsheetjs */ \"./node_modules/chordsheetjs/lib/module.js\");\n/* harmony import */ var chordjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chordjs */ \"./node_modules/chordjs/lib/index.js\");\n\n\n\nconst processChord = (item, processor) => {\n  if (item instanceof chordsheetjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ChordLyricsPair && item.chords) {\n    const parsedChord = (0,chordjs__WEBPACK_IMPORTED_MODULE_1__.parse)(item.chords);\n\n    if (parsedChord) {\n      const processedChordLyricsPair = item.clone();\n      processedChordLyricsPair.chords = processor(parsedChord).toString();\n      return processedChordLyricsPair;\n    }\n  }\n\n  return item;\n};\n\nconst transformSong = (song, processor) => {\n  const processedSong = song.clone();\n\n  processedSong.lines = song.lines.map((line) => {\n    const processedLine = line.clone();\n    processedLine.items = line.items.map((item) => processChord(item, processor));\n    return processedLine;\n  });\n\n  return processedSong;\n};\n\nconst transformChordSheet = (chordSheet, processor) => {\n  const song = new chordsheetjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ChordProParser().parse(chordSheet);\n  const processedSong = transformSong(song, processor);\n  return new chordsheetjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ChordProFormatter().format(processedSong);\n};\n\nconst transposeUp = (chordSheet) => (\n  transformChordSheet(chordSheet, (chord) => chord.transposeUp())\n);\n\nconst transposeDown = (chordSheet) => (\n  transformChordSheet(chordSheet, (chord) => chord.transposeDown())\n);\n\nconst switchToSharp = (chordSheet) => (\n  transformChordSheet(chordSheet, (chord) => chord.useModifier('#'))\n);\n\nconst switchToFlat = (chordSheet) => (\n  transformChordSheet(chordSheet, (chord) => chord.useModifier('b'))\n);\n\nconst convertChordSheetToChordPro = (chordSheet) => {\n  const parser = new chordsheetjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ChordSheetParser({ preserveWhitespace: false });\n  const formatter = new chordsheetjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ChordProFormatter();\n  const song = parser.parse(chordSheet);\n  return formatter.format(song);\n};\n\n\n//# sourceURL=webpack://ChordFiddle/./src/js/chord_sheet_transformations.js?");

/***/ }),

/***/ "./src/js/chord_sheet_viewer.js":
/*!**************************************!*\
  !*** ./src/js/chord_sheet_viewer.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var chordsheetjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chordsheetjs */ \"./node_modules/chordsheetjs/lib/module.js\");\n/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./component */ \"./src/js/component.js\");\n\n\n\nconst formatters = {\n  html: chordsheetjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].HtmlDivFormatter,\n  text: chordsheetjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].TextFormatter,\n};\n\nclass ChordSheetViewer extends _component__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  onDisplayModeChanged = () => {};\n\n  setup() {\n    this.onChange('displayModeHtml', () => this.displayModeChanged());\n    this.onChange('displayModeText', () => this.displayModeChanged());\n  }\n\n  displayModeChanged() {\n    const displayMode = this.getSelectedMode();\n    this.onDisplayModeChanged(displayMode);\n  }\n\n  render(song) {\n    const displayMode = this.getSelectedMode();\n    const outlet = this.element('outlet');\n    outlet.dataset.mode = displayMode;\n\n    const formatter = new formatters[displayMode]();\n    const formattedSheet = formatter.format(song);\n\n    switch (displayMode) {\n      case 'text':\n        outlet.innerText = formattedSheet;\n        break;\n      default:\n        outlet.innerHTML = formattedSheet;\n    }\n  }\n\n  getDisplayModeRadios() {\n    const element = this.element('displayModeHtml');\n    return Array.from(element.form[element.name]);\n  }\n\n  getSelectedMode() {\n    return this\n      .getDisplayModeRadios()\n      .find((input) => input.checked)\n      .value;\n  }\n\n  setSelectedMode(mode) {\n    this\n      .getDisplayModeRadios()\n      .find((input) => input.value === mode)\n      .checked = true;\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ChordSheetViewer);\n\n\n//# sourceURL=webpack://ChordFiddle/./src/js/chord_sheet_viewer.js?");

/***/ }),

/***/ "./src/js/component.js":
/*!*****************************!*\
  !*** ./src/js/component.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Component {\n  constructor(containerID) {\n    this.containerID = containerID;\n    this.container = document.getElementById(containerID);\n    this.setup();\n  }\n\n  setup() {}\n\n  onClick(elementID, listener) {\n    this.bindEvent(elementID, 'click', listener);\n  }\n\n  onChange(elementID, listener) {\n    this.bindEvent(elementID, 'change', listener);\n  }\n\n  bindEvent(elementID, event, listener) {\n    this.element(elementID).addEventListener(event, listener);\n  }\n\n  element(elementID) {\n    return document.getElementById(`${this.containerID}__${elementID}`);\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Component);\n\n\n//# sourceURL=webpack://ChordFiddle/./src/js/component.js?");

/***/ }),

/***/ "./src/js/debounce.js":
/*!****************************!*\
  !*** ./src/js/debounce.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ debounce)\n/* harmony export */ });\nfunction debounce(func, interval = 100) {\n  let debounceTimer = null;\n\n  return function debouncedFunction(...args) {\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n\n    const boundFunction = func.bind(null, ...args);\n    debounceTimer = setTimeout(boundFunction, interval);\n  };\n}\n\n\n//# sourceURL=webpack://ChordFiddle/./src/js/debounce.js?");

/***/ }),

/***/ "./src/js/import_dialog.js":
/*!*********************************!*\
  !*** ./src/js/import_dialog.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ \"./src/js/component.js\");\n\n\nclass ImportDialog extends _component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  onImportConfirmed = () => {};\n\n  setup() {\n    this.onClick('confirmButton', () => {\n      const editor = this.element('editor');\n      const chordSheet = editor.value;\n      editor.value = '';\n      this.close();\n      this.onImportConfirmed(chordSheet);\n    });\n\n    this.onClick('closeButton', () => this.close());\n  }\n\n  setOpen(open) {\n    this.container.classList.toggle('ImportDialog--visible', open);\n  }\n\n  open() {\n    this.setOpen(true);\n    this.element('editor').focus();\n  }\n\n  close() {\n    this.setOpen(false);\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ImportDialog);\n\n\n//# sourceURL=webpack://ChordFiddle/./src/js/import_dialog.js?");

/***/ }),

/***/ "./src/js/location_hash.js":
/*!*********************************!*\
  !*** ./src/js/location_hash.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getQueryParams\": () => (/* binding */ getQueryParams),\n/* harmony export */   \"setChordSheet\": () => (/* binding */ setChordSheet),\n/* harmony export */   \"setDisplayMode\": () => (/* binding */ setDisplayMode)\n/* harmony export */ });\n/* harmony import */ var query_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! query-string */ \"./node_modules/query-string/index.js\");\n/* harmony import */ var _string_compression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string_compression */ \"./src/js/string_compression.js\");\n\n\n\nfunction getRawQueryParams() {\n  return query_string__WEBPACK_IMPORTED_MODULE_0__.parse(window.location.hash);\n}\n\nfunction setRawQueryParams(rawQueryParams) {\n  window.location.hash = query_string__WEBPACK_IMPORTED_MODULE_0__.stringify(rawQueryParams);\n}\n\nfunction setChordSheet(chordSheet) {\n  const { display_mode: displayMode } = getRawQueryParams();\n\n  setRawQueryParams({\n    display_mode: displayMode,\n    chord_sheet: (0,_string_compression__WEBPACK_IMPORTED_MODULE_1__.compress)(chordSheet),\n  });\n}\n\nfunction setDisplayMode(displayMode) {\n  const { chord_sheet: chordSheet } = getRawQueryParams();\n  setRawQueryParams({ display_mode: displayMode, chord_sheet: chordSheet });\n}\n\nfunction getQueryParams() {\n  const { display_mode: displayMode, chord_sheet: chordSheet } = getRawQueryParams();\n  return { displayMode, chordSheet: (0,_string_compression__WEBPACK_IMPORTED_MODULE_1__.decompress)(chordSheet) };\n}\n\n\n//# sourceURL=webpack://ChordFiddle/./src/js/location_hash.js?");

/***/ }),

/***/ "./src/js/string_compression.js":
/*!**************************************!*\
  !*** ./src/js/string_compression.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compress\": () => (/* binding */ compress),\n/* harmony export */   \"decompress\": () => (/* binding */ decompress)\n/* harmony export */ });\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lz-string */ \"./node_modules/lz-string/libs/lz-string.js\");\n/* harmony import */ var lz_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lz_string__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction compress(input) {\n  return lz_string__WEBPACK_IMPORTED_MODULE_0___default().compressToEncodedURIComponent(input);\n}\n\nfunction decompress(input) {\n  return lz_string__WEBPACK_IMPORTED_MODULE_0___default().decompressFromEncodedURIComponent(input);\n}\n\n\n//# sourceURL=webpack://ChordFiddle/./src/js/string_compression.js?");

/***/ }),

/***/ "./src/js/toolbar.js":
/*!***************************!*\
  !*** ./src/js/toolbar.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./component */ \"./src/js/component.js\");\n/* harmony import */ var _chord_sheet_transformations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chord_sheet_transformations */ \"./src/js/chord_sheet_transformations.js\");\n\n\n\nclass Toolbar extends _component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  onTransformClick = () => {};\n\n  onImportChordSheetClick = () => {};\n\n  setup() {\n    this.onClick('transposeDown', () => this.onTransformClick(_chord_sheet_transformations__WEBPACK_IMPORTED_MODULE_1__.transposeDown));\n    this.onClick('transposeUp', () => this.onTransformClick(_chord_sheet_transformations__WEBPACK_IMPORTED_MODULE_1__.transposeUp));\n    this.onClick('switchToSharp', () => this.onTransformClick(_chord_sheet_transformations__WEBPACK_IMPORTED_MODULE_1__.switchToSharp));\n    this.onClick('switchToFlat', () => this.onTransformClick(_chord_sheet_transformations__WEBPACK_IMPORTED_MODULE_1__.switchToFlat));\n    this.onClick('importChordSheet', () => this.onImportChordSheetClick());\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Toolbar);\n\n\n//# sourceURL=webpack://ChordFiddle/./src/js/toolbar.js?");

/***/ }),

/***/ "./src/js/value_with_history.js":
/*!**************************************!*\
  !*** ./src/js/value_with_history.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass ValueWithHistory {\n  constructor(initialValue) {\n    this.value = initialValue;\n    this.valueWas = undefined;\n  }\n\n  set(newValue) {\n    this.valueWas = this.value;\n    this.value = newValue;\n  }\n}\n\nfunction valueWithHistory(initialValue) {\n  return new ValueWithHistory(initialValue);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (valueWithHistory);\n\n\n//# sourceURL=webpack://ChordFiddle/./src/js/value_with_history.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;